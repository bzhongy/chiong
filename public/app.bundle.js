(function() {"use strict"; const OPTION_FACTORY_ABI = [{"inputs": [{"internalType": "address","name": "_historicalTWAPConsumer","type": "address"}],"stateMutability": "nonpayable","type": "constructor","name": "constructor"},{"inputs": [],"name": "BalanceIncorrect","type": "error"},{"inputs": [],"name": "InsufficientReferralBalance","type": "error"},{"inputs": [],"name": "InvalidOfferHash","type": "error"},{"inputs": [],"name": "InvalidOptionContract","type": "error"},{"inputs": [],"name": "InvalidOptionOwnership","type": "error"},{"inputs": [],"name": "InvalidPriceFeedDecimals","type": "error"},{"inputs": [],"name": "InvalidQuotationId","type": "error"},{"inputs": [],"name": "InvalidReferralId","type": "error"},{"inputs": [],"name": "InvalidShortString","type": "error"},{"inputs": [],"name": "InvalidSignature","type": "error"},{"inputs": [],"name": "NoFeesToWithdraw","type": "error"},{"inputs": [],"name": "NoOfferMade","type": "error"},{"inputs": [],"name": "NoWinnerToAccept","type": "error"},{"inputs": [],"name": "NotReferralOwner","type": "error"},{"inputs": [],"name": "OfferNotCompetitive","type": "error"},{"inputs": [],"name": "OfferPeriodEnded","type": "error"},{"inputs": [],"name": "OnlyRequesterAllowed","type": "error"},{"inputs": [],"name": "OptionExpired","type": "error"},{"inputs": [],"name": "OptionOwnedBySameParty","type": "error"},{"inputs": [],"name": "PriceFeedStale","type": "error"},{"inputs": [],"name": "PriceMustBePositive","type": "error"},{"inputs": [],"name": "QuotationNotActive","type": "error"},{"inputs": [],"name": "RFQExpiryAfterOptionExpiry","type": "error"},{"inputs": [],"name": "ReferralMustBeLong","type": "error"},{"inputs": [],"name": "ReferralParamMismatch","type": "error"},{"inputs": [],"name": "RevealPeriodEnded","type": "error"},{"inputs": [],"name": "RevealPeriodNotEnded","type": "error"},{"inputs": [],"name": "RevealPeriodNotStarted","type": "error"},{"inputs": [],"name": "SelfReferralNotAllowed","type": "error"},{"inputs": [{"internalType": "string","name": "str","type": "string"}],"name": "StringTooLong","type": "error"},{"inputs": [],"name": "SwapFailed","type": "error"},{"inputs": [],"name": "TokenMismatch","type": "error"},{"inputs": [],"name": "UnknownSelector","type": "error"},{"inputs": [],"name": "WrapperTransferFailed","type": "error"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "depositor","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "CollateralDeposited","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "recipient","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "CollateralReturned","type": "event"},{"anonymous": false,"inputs": [],"name": "EIP712DomainChanged","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "referralId","type": "uint256"},{"indexed": true,"internalType": "address","name": "token","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "ExpiredReferralSwept","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "FeePaid","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "recipient","type": "address"},{"indexed": true,"internalType": "address","name": "token","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "FeesWithdrawn","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "offeror","type": "address"},{"indexed": false,"internalType": "uint256","name": "offerAmount","type": "uint256"}],"name": "OfferAcceptedEarly","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "offeror","type": "address"},{"indexed": false,"internalType": "bytes","name": "offerSignature","type": "bytes"}],"name": "OfferCancelled","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "offeror","type": "address"},{"indexed": false,"internalType": "bytes","name": "offerSignature","type": "bytes"},{"indexed": false,"internalType": "string","name": "signingKey","type": "string"},{"indexed": false,"internalType": "string","name": "signedOfferForRequester","type": "string"}],"name": "OfferMade","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "offeror","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "OfferRevealed","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "previousOwner","type": "address"},{"indexed": true,"internalType": "address","name": "newOwner","type": "address"}],"name": "OwnershipTransferred","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "recipient","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "PremiumPaid","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"}],"name": "QuotationCancelled","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "requester","type": "address"},{"indexed": false,"internalType": "string","name": "requesterPublicKey","type": "string"}],"name": "QuotationRequested","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "address","name": "requester","type": "address"},{"indexed": true,"internalType": "address","name": "winner","type": "address"},{"indexed": false,"internalType": "address","name": "optionAddress","type": "address"}],"name": "QuotationSettled","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": true,"internalType": "uint256","name": "referralId","type": "uint256"},{"indexed": true,"internalType": "uint256","name": "tracking","type": "uint256"}],"name": "QuotationTrackers","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "referralId","type": "uint256"},{"indexed": true,"internalType": "uint256","name": "quotationId","type": "uint256"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "ReferralRFQExecuted","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "referralId","type": "uint256"},{"indexed": true,"internalType": "address","name": "referrer","type": "address"}],"name": "ReferralRegistered","type": "event"},{"inputs": [],"name": "OFFER_TYPEHASH","outputs": [{"internalType": "bytes32","name": "","type": "bytes32"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "REVEAL_WINDOW","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "TWAP_PERIOD","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "numContracts","type": "uint256"},{"internalType": "uint256","name": "premium","type": "uint256"},{"internalType": "uint256","name": "price","type": "uint256"}],"name": "calculateFee","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "pure","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"}],"name": "cancelOfferForQuotation","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"}],"name": "cancelQuotation","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "eip712Domain","outputs": [{"internalType": "bytes1","name": "fields","type": "bytes1"},{"internalType": "string","name": "name","type": "string"},{"internalType": "string","name": "version","type": "string"},{"internalType": "uint256","name": "chainId","type": "uint256"},{"internalType": "address","name": "verifyingContract","type": "address"},{"internalType": "bytes32","name": "salt","type": "bytes32"},{"internalType": "uint256[]","name": "extensions","type": "uint256[]"}],"stateMutability": "view","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "requester","type": "address"},{"internalType": "address","name": "existingOptionAddress","type": "address"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "address","name": "collateralPriceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "numContracts","type": "uint256"},{"internalType": "uint256","name": "requesterDeposit","type": "uint256"},{"internalType": "uint256","name": "collateralAmount","type": "uint256"},{"internalType": "uint256","name": "expiryTimestamp","type": "uint256"},{"internalType": "uint256","name": "offerEndTimestamp","type": "uint256"},{"internalType": "bool","name": "isRequestingLongPosition","type": "bool"},{"internalType": "bool","name": "convertToLimitOrder","type": "bool"},{"internalType": "bytes","name": "extraOptionData","type": "bytes"}],"internalType": "struct OptionFactory.QuotationParameters","name": "params","type": "tuple"},{"components": [{"internalType": "uint256","name": "referralId","type": "uint256"},{"internalType": "uint256","name": "eventCode","type": "uint256"}],"internalType": "struct OptionFactory.QuotationTracking","name": "tracking","type": "tuple"},{"internalType": "uint256","name": "reservePrice","type": "uint256"},{"internalType": "string","name": "requesterPublicKey","type": "string"}],"name": "executeReferralRFQ","outputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "getQuotationCount","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "historicalTWAPConsumer","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"},{"internalType": "bytes","name": "signature","type": "bytes"},{"internalType": "string","name": "signingKey","type": "string"},{"internalType": "string","name": "encryptedOfferForRequester","type": "string"}],"name": "makeOfferForQuotation","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "uint256","name": "","type": "uint256"},{"internalType": "address","name": "","type": "address"}],"name": "offerSignatures","outputs": [{"internalType": "bytes","name": "","type": "bytes"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "owner","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "","type": "address"}],"name": "pendingFees","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "","type": "uint256"}],"name": "quotationTracking","outputs": [{"internalType": "uint256","name": "referralId","type": "uint256"},{"internalType": "uint256","name": "eventCode","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"}],"name": "quotations","outputs": [{"components": [{"internalType": "address","name": "requester","type": "address"},{"internalType": "address","name": "existingOptionAddress","type": "address"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "address","name": "collateralPriceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "numContracts","type": "uint256"},{"internalType": "uint256","name": "requesterDeposit","type": "uint256"},{"internalType": "uint256","name": "collateralAmount","type": "uint256"},{"internalType": "uint256","name": "expiryTimestamp","type": "uint256"},{"internalType": "uint256","name": "offerEndTimestamp","type": "uint256"},{"internalType": "bool","name": "isRequestingLongPosition","type": "bool"},{"internalType": "bool","name": "convertToLimitOrder","type": "bool"},{"internalType": "bytes","name": "extraOptionData","type": "bytes"}],"internalType": "struct OptionFactory.QuotationParameters","name": "","type": "tuple"},{"components": [{"internalType": "bool","name": "isActive","type": "bool"},{"internalType": "address","name": "currentWinner","type": "address"},{"internalType": "uint256","name": "currentBestPriceOrReserve","type": "uint256"},{"internalType": "address","name": "optionContract","type": "address"}],"internalType": "struct OptionFactory.QuotationState","name": "","type": "tuple"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "","type": "uint256"}],"name": "referralFees","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "","type": "uint256"}],"name": "referralOwner","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "requester","type": "address"},{"internalType": "address","name": "existingOptionAddress","type": "address"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "address","name": "collateralPriceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "numContracts","type": "uint256"},{"internalType": "uint256","name": "requesterDeposit","type": "uint256"},{"internalType": "uint256","name": "collateralAmount","type": "uint256"},{"internalType": "uint256","name": "expiryTimestamp","type": "uint256"},{"internalType": "uint256","name": "offerEndTimestamp","type": "uint256"},{"internalType": "bool","name": "isRequestingLongPosition","type": "bool"},{"internalType": "bool","name": "convertToLimitOrder","type": "bool"},{"internalType": "bytes","name": "extraOptionData","type": "bytes"}],"internalType": "struct OptionFactory.QuotationParameters","name": "params","type": "tuple"}],"name": "registerReferral","outputs": [{"internalType": "uint256","name": "referralId","type": "uint256"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "renounceOwnership","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "requester","type": "address"},{"internalType": "address","name": "existingOptionAddress","type": "address"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "address","name": "collateralPriceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "numContracts","type": "uint256"},{"internalType": "uint256","name": "requesterDeposit","type": "uint256"},{"internalType": "uint256","name": "collateralAmount","type": "uint256"},{"internalType": "uint256","name": "expiryTimestamp","type": "uint256"},{"internalType": "uint256","name": "offerEndTimestamp","type": "uint256"},{"internalType": "bool","name": "isRequestingLongPosition","type": "bool"},{"internalType": "bool","name": "convertToLimitOrder","type": "bool"},{"internalType": "bytes","name": "extraOptionData","type": "bytes"}],"internalType": "struct OptionFactory.QuotationParameters","name": "params","type": "tuple"},{"components": [{"internalType": "uint256","name": "referralId","type": "uint256"},{"internalType": "uint256","name": "eventCode","type": "uint256"}],"internalType": "struct OptionFactory.QuotationTracking","name": "tracking","type": "tuple"},{"internalType": "uint256","name": "reservePrice","type": "uint256"},{"internalType": "string","name": "requesterPublicKey","type": "string"}],"name": "requestForQuotation","outputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "uint256","name": "referralId","type": "uint256"}],"name": "returnReferralParameters","outputs": [{"internalType": "address","name": "collateral","type": "address"},{"internalType": "address","name": "collateralPriceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiryTimestamp","type": "uint256"},{"internalType": "bool","name": "isRequestingLongPosition","type": "bool"},{"internalType": "bytes","name": "extraOptionData","type": "bytes"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"},{"internalType": "uint256","name": "offerAmount","type": "uint256"},{"internalType": "uint64","name": "nonce","type": "uint64"},{"internalType": "address","name": "offeror","type": "address"}],"name": "revealOffer","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"}],"name": "settleQuotation","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "uint256","name": "quotationId","type": "uint256"},{"internalType": "uint256","name": "offerAmount","type": "uint256"},{"internalType": "uint64","name": "nonce","type": "uint64"},{"internalType": "address","name": "offeror","type": "address"}],"name": "settleQuotationEarly","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "swapRouter","type": "address"},{"internalType": "address","name": "swapSrcToken","type": "address"},{"internalType": "address","name": "swapDstToken","type": "address"},{"internalType": "uint256","name": "swapSrcAmount","type": "uint256"},{"internalType": "bytes","name": "swapCallData","type": "bytes"},{"internalType": "bytes","name": "selfCallData","type": "bytes"}],"name": "swapAndCall","outputs": [],"stateMutability": "payable","type": "function"},{"inputs": [{"internalType": "address","name": "newOwner","type": "address"}],"name": "transferOwnership","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "token","type": "address"},{"internalType": "uint256[]","name": "referralIds","type": "uint256[]"}],"name": "withdrawFees","outputs": [],"stateMutability": "nonpayable","type": "function"}]; const MULTICALL_ABI = [{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall2.Call[]","name":"calls","type":"tuple[]"}],"name":"aggregate","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"bytes[]","name":"returnData","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall2.Call[]","name":"calls","type":"tuple[]"}],"name":"blockAndAggregate","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall2.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"}],"name":"getBlockHash","outputs":[{"internalType":"bytes32","name":"blockHash","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBlockNumber","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockCoinbase","outputs":[{"internalType":"address","name":"coinbase","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockDifficulty","outputs":[{"internalType":"uint256","name":"difficulty","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockGasLimit","outputs":[{"internalType":"uint256","name":"gaslimit","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentBlockTimestamp","outputs":[{"internalType":"uint256","name":"timestamp","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"addr","type":"address"}],"name":"getEthBalance","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getL1BlockNumber","outputs":[{"internalType":"uint256","name":"l1BlockNumber","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLastBlockHash","outputs":[{"internalType":"bytes32","name":"blockHash","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"requireSuccess","type":"bool"},{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall2.Call[]","name":"calls","type":"tuple[]"}],"name":"tryAggregate","outputs":[{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall2.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"requireSuccess","type":"bool"},{"components":[{"internalType":"address","name":"target","type":"address"},{"internalType":"bytes","name":"callData","type":"bytes"}],"internalType":"struct Multicall2.Call[]","name":"calls","type":"tuple[]"}],"name":"tryBlockAndAggregate","outputs":[{"internalType":"uint256","name":"blockNumber","type":"uint256"},{"internalType":"bytes32","name":"blockHash","type":"bytes32"},{"components":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"returnData","type":"bytes"}],"internalType":"struct Multicall2.Result[]","name":"returnData","type":"tuple[]"}],"stateMutability":"nonpayable","type":"function"}]; const OPTION_ABI = [{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "optionAddress","type": "address"},{"indexed": true,"internalType": "address","name": "seller","type": "address"},{"indexed": false,"internalType": "uint256","name": "amountReturned","type": "uint256"}],"name": "CollateralReturned","type": "event"},{"anonymous": false,"inputs": [],"name": "CollateralTokenRescued","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "rescueAddress","type": "address"},{"indexed": false,"internalType": "address","name": "tokenAddress","type": "address"},{"indexed": false,"internalType": "uint256","name": "amount","type": "uint256"}],"name": "ERC20Rescued","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "optionAddress","type": "address"},{"indexed": true,"internalType": "address","name": "closedBy","type": "address"},{"indexed": false,"internalType": "uint256","name": "collateralReturned","type": "uint256"}],"name": "OptionClosed","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "optionAddress","type": "address"},{"indexed": false,"internalType": "uint256","name": "settlementPrice","type": "uint256"}],"name": "OptionExpired","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "optionAddress","type": "address"},{"indexed": true,"internalType": "address","name": "buyer","type": "address"},{"indexed": false,"internalType": "uint256","name": "amountPaidOut","type": "uint256"}],"name": "OptionPayout","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "newOption","type": "address"},{"indexed": false,"internalType": "uint256","name": "collateralAmount","type": "uint256"}],"name": "OptionSplit","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "optionAddress","type": "address"},{"indexed": true,"internalType": "address","name": "from","type": "address"},{"indexed": true,"internalType": "address","name": "to","type": "address"},{"indexed": false,"internalType": "bool","name": "isBuyer","type": "bool"}],"name": "RoleTransferred","type": "event"},{"inputs": [],"name": "PRICE_DECIMALS","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "buyer","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "price","type": "uint256"}],"name": "calculatePayout","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256[]","name": "_strikes","type": "uint256[]"},{"internalType": "uint256","name": "_numContracts","type": "uint256"}],"name": "calculateRequiredCollateral","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "pure","type": "function"},{"inputs": [],"name": "chainlinkPriceFeed","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "close","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "collateralAmount","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "collateralToken","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "expiryTimestamp","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "factory","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "getImplementation","outputs": [{"internalType": "address","name": "implementation","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "getStrikes","outputs": [{"internalType": "uint256[]","name": "","type": "uint256[]"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "getTWAP","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "historicalTWAPConsumer","outputs": [{"internalType": "contract HistoricalPriceConsumerV3_TWAP","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "collateralToken","type": "address"},{"internalType": "address","name": "chainlinkPriceFeed","type": "address"},{"internalType": "address","name": "historicalTWAPConsumer","type": "address"},{"internalType": "address","name": "buyer","type": "address"},{"internalType": "address","name": "seller","type": "address"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiryTimestamp","type": "uint256"},{"internalType": "uint256","name": "twapPeriod","type": "uint256"},{"internalType": "uint256","name": "numContracts","type": "uint256"},{"internalType": "uint256","name": "collateralAmount","type": "uint256"},{"internalType": "address","name": "rescueAddress","type": "address"},{"internalType": "address","name": "factoryAddress","type": "address"},{"internalType": "bytes","name": "extraOptionData","type": "bytes"}],"internalType": "struct BaseOption.OptionParams","name": "params","type": "tuple"}],"name": "initialize","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "numContracts","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "optionSettled","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "optionType","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "pure","type": "function"},{"inputs": [],"name": "packExtraOptionData","outputs": [{"internalType": "bytes","name": "","type": "bytes"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "payout","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "rescueAddress","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "contract IERC20","name": "token","type": "address"}],"name": "rescueERC20","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "seller","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "price","type": "uint256"},{"internalType": "uint256[]","name": "_strikes","type": "uint256[]"},{"internalType": "uint256","name": "_numContracts","type": "uint256"}],"name": "simulatePayout","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "pure","type": "function"},{"inputs": [{"internalType": "uint256","name": "splitCollateralAmount","type": "uint256"}],"name": "split","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "uint256","name": "","type": "uint256"}],"name": "strikes","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "bool","name": "isBuyer","type": "bool"},{"internalType": "address","name": "target","type": "address"}],"name": "transfer","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "twapPeriod","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "unpackOptionType","outputs": [{"internalType": "bool","name": "isQuoteCollateral","type": "bool"},{"internalType": "bool","name": "isPhysicallySettled","type": "bool"},{"internalType": "uint8","name": "optionStyle","type": "uint8"},{"internalType": "uint8","name": "optionStructure","type": "uint8"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256[]","name": "_strikes","type": "uint256[]"}],"name": "validateParams","outputs": [],"stateMutability": "pure","type": "function"}]; const OPTION_BOOK_ABI = [{"inputs": [{"internalType": "address","name": "_factory","type": "address"}],"stateMutability": "nonpayable","type": "constructor","name": "constructor"},{"inputs": [],"name": "InvalidPriceFeedDecimals","type": "error"},{"inputs": [],"name": "InvalidShortString","type": "error"},{"inputs": [],"name": "PriceFeedStale","type": "error"},{"inputs": [],"name": "PriceMustBePositive","type": "error"},{"inputs": [{"internalType": "string","name": "str","type": "string"}],"name": "StringTooLong","type": "error"},{"anonymous": false,"inputs": [],"name": "EIP712DomainChanged","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "nonce","type": "uint256"},{"indexed": true,"internalType": "address","name": "maker","type": "address"}],"name": "OrderCancelled","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "uint256","name": "nonce","type": "uint256"},{"indexed": true,"internalType": "address","name": "buyer","type": "address"},{"indexed": true,"internalType": "address","name": "seller","type": "address"},{"indexed": false,"internalType": "address","name": "optionAddress","type": "address"},{"indexed": false,"internalType": "uint256","name": "premiumAmount","type": "uint256"},{"indexed": false,"internalType": "uint256","name": "feeCollected","type": "uint256"},{"indexed": false,"internalType": "bool","name": "sellerWasMaker","type": "bool"}],"name": "OrderFilled","type": "event"},{"inputs": [],"name": "LIMIT_ORDER_TYPEHASH","outputs": [{"internalType": "bytes32","name": "","type": "bytes32"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "PRICE_DECIMALS","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "","type": "uint256"}],"name": "amountFilled","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "maker","type": "address"},{"internalType": "uint256","name": "orderExpiryTimestamp","type": "uint256"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "bool","name": "isCall","type": "bool"},{"internalType": "address","name": "priceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "bool","name": "isLong","type": "bool"},{"internalType": "uint256","name": "maxCollateralUsable","type": "uint256"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiry","type": "uint256"},{"internalType": "uint256","name": "price","type": "uint256"},{"internalType": "uint256","name": "numContracts","type": "uint256"}],"internalType": "struct OptionBook.Order","name": "order","type": "tuple"}],"name": "cancelOrder","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "maker","type": "address"},{"internalType": "uint256","name": "orderExpiryTimestamp","type": "uint256"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "bool","name": "isCall","type": "bool"},{"internalType": "address","name": "priceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "bool","name": "isLong","type": "bool"},{"internalType": "uint256","name": "maxCollateralUsable","type": "uint256"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiry","type": "uint256"},{"internalType": "uint256","name": "price","type": "uint256"},{"internalType": "uint256","name": "numContracts","type": "uint256"}],"internalType": "struct OptionBook.Order","name": "order","type": "tuple"}],"name": "computeNonce","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "pure","type": "function"},{"inputs": [],"name": "eip712Domain","outputs": [{"internalType": "bytes1","name": "fields","type": "bytes1"},{"internalType": "string","name": "name","type": "string"},{"internalType": "string","name": "version","type": "string"},{"internalType": "uint256","name": "chainId","type": "uint256"},{"internalType": "address","name": "verifyingContract","type": "address"},{"internalType": "bytes32","name": "salt","type": "bytes32"},{"internalType": "uint256[]","name": "extensions","type": "uint256[]"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "factory","outputs": [{"internalType": "contract OptionFactory","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "maker","type": "address"},{"internalType": "uint256","name": "orderExpiryTimestamp","type": "uint256"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "bool","name": "isCall","type": "bool"},{"internalType": "address","name": "priceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "bool","name": "isLong","type": "bool"},{"internalType": "uint256","name": "maxCollateralUsable","type": "uint256"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiry","type": "uint256"},{"internalType": "uint256","name": "price","type": "uint256"},{"internalType": "uint256","name": "numContracts","type": "uint256"}],"internalType": "struct OptionBook.Order","name": "order","type": "tuple"},{"internalType": "bytes","name": "signature","type": "bytes"}],"name": "fillOrder","outputs": [{"internalType": "address","name": "optionAddress","type": "address"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "maker","type": "address"},{"internalType": "uint256","name": "orderExpiryTimestamp","type": "uint256"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "bool","name": "isCall","type": "bool"},{"internalType": "address","name": "priceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "bool","name": "isLong","type": "bool"},{"internalType": "uint256","name": "maxCollateralUsable","type": "uint256"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiry","type": "uint256"},{"internalType": "uint256","name": "price","type": "uint256"},{"internalType": "uint256","name": "numContracts","type": "uint256"}],"internalType": "struct OptionBook.Order","name": "order","type": "tuple"}],"name": "hashOrder","outputs": [{"internalType": "bytes32","name": "","type": "bytes32"}],"stateMutability": "view","type": "function"},{"inputs": [{"components": [{"internalType": "address","name": "maker","type": "address"},{"internalType": "uint256","name": "orderExpiryTimestamp","type": "uint256"},{"internalType": "address","name": "collateral","type": "address"},{"internalType": "bool","name": "isCall","type": "bool"},{"internalType": "address","name": "priceFeed","type": "address"},{"internalType": "address","name": "implementation","type": "address"},{"internalType": "bool","name": "isLong","type": "bool"},{"internalType": "uint256","name": "maxCollateralUsable","type": "uint256"},{"internalType": "uint256[]","name": "strikes","type": "uint256[]"},{"internalType": "uint256","name": "expiry","type": "uint256"},{"internalType": "uint256","name": "price","type": "uint256"},{"internalType": "uint256","name": "numContracts","type": "uint256"}],"internalType": "struct OptionBook.Order","name": "order","type": "tuple"},{"internalType": "bytes","name": "signature","type": "bytes"},{"internalType": "address","name": "swapRouter","type": "address"},{"internalType": "address","name": "swapSrcToken","type": "address"},{"internalType": "uint256","name": "swapSrcAmount","type": "uint256"},{"internalType": "bytes","name": "swapData","type": "bytes"}],"name": "swapAndFillOrder","outputs": [{"internalType": "address","name": "optionAddress","type": "address"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "token","type": "address"}],"name": "sweepFees","outputs": [],"stateMutability": "nonpayable","type": "function"}]; const ERC20ABI = [{"inputs": [{"internalType": "string","name": "name_","type": "string"},{"internalType": "string","name": "symbol_","type": "string"}],"stateMutability": "nonpayable","type": "constructor","name": "constructor"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "owner","type": "address"},{"indexed": true,"internalType": "address","name": "spender","type": "address"},{"indexed": false,"internalType": "uint256","name": "value","type": "uint256"}],"name": "Approval","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "from","type": "address"},{"indexed": true,"internalType": "address","name": "to","type": "address"},{"indexed": false,"internalType": "uint256","name": "value","type": "uint256"}],"name": "Transfer","type": "event"},{"inputs": [{"internalType": "address","name": "owner","type": "address"},{"internalType": "address","name": "spender","type": "address"}],"name": "allowance","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "spender","type": "address"},{"internalType": "uint256","name": "amount","type": "uint256"}],"name": "approve","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "account","type": "address"}],"name": "balanceOf","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "decimals","outputs": [{"internalType": "uint8","name": "","type": "uint8"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "spender","type": "address"},{"internalType": "uint256","name": "subtractedValue","type": "uint256"}],"name": "decreaseAllowance","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "spender","type": "address"},{"internalType": "uint256","name": "addedValue","type": "uint256"}],"name": "increaseAllowance","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "name","outputs": [{"internalType": "string","name": "","type": "string"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "symbol","outputs": [{"internalType": "string","name": "","type": "string"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "totalSupply","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "to","type": "address"},{"internalType": "uint256","name": "amount","type": "uint256"}],"name": "transfer","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "from","type": "address"},{"internalType": "address","name": "to","type": "address"},{"internalType": "uint256","name": "amount","type": "uint256"}],"name": "transferFrom","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "nonpayable","type": "function"}]; const KYBER_ABI = [{"inputs":[{"internalType":"address","name":"_WETH","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes","name":"clientData","type":"bytes"}],"name":"ClientData","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"reason","type":"string"}],"name":"Error","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"pair","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountOut","type":"uint256"},{"indexed":false,"internalType":"address","name":"output","type":"address"}],"name":"Exchange","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"totalAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalFee","type":"uint256"},{"indexed":false,"internalType":"address[]","name":"recipients","type":"address[]"},{"indexed":false,"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"indexed":false,"internalType":"bool","name":"isBps","type":"bool"}],"name":"Fee","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"contract IERC20","name":"srcToken","type":"address"},{"indexed":false,"internalType":"contract IERC20","name":"dstToken","type":"address"},{"indexed":false,"internalType":"address","name":"dstReceiver","type":"address"},{"indexed":false,"internalType":"uint256","name":"spentAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"returnAmount","type":"uint256"}],"name":"Swapped","type":"event"},{"inputs":[],"name":"WETH","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isWhitelist","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"rescueFunds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"callTarget","type":"address"},{"internalType":"address","name":"approveTarget","type":"address"},{"internalType":"bytes","name":"targetData","type":"bytes"},{"components":[{"internalType":"contract IERC20","name":"srcToken","type":"address"},{"internalType":"contract IERC20","name":"dstToken","type":"address"},{"internalType":"address[]","name":"srcReceivers","type":"address[]"},{"internalType":"uint256[]","name":"srcAmounts","type":"uint256[]"},{"internalType":"address[]","name":"feeReceivers","type":"address[]"},{"internalType":"uint256[]","name":"feeAmounts","type":"uint256[]"},{"internalType":"address","name":"dstReceiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"minReturnAmount","type":"uint256"},{"internalType":"uint256","name":"flags","type":"uint256"},{"internalType":"bytes","name":"permit","type":"bytes"}],"internalType":"struct IMetaAggregationRouterV2.SwapDescriptionV2","name":"desc","type":"tuple"},{"internalType":"bytes","name":"clientData","type":"bytes"}],"internalType":"struct IMetaAggregationRouterV2.SwapExecutionParams","name":"execution","type":"tuple"}],"name":"swap","outputs":[{"internalType":"uint256","name":"returnAmount","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"address","name":"callTarget","type":"address"},{"internalType":"address","name":"approveTarget","type":"address"},{"internalType":"bytes","name":"targetData","type":"bytes"},{"components":[{"internalType":"contract IERC20","name":"srcToken","type":"address"},{"internalType":"contract IERC20","name":"dstToken","type":"address"},{"internalType":"address[]","name":"srcReceivers","type":"address[]"},{"internalType":"uint256[]","name":"srcAmounts","type":"uint256[]"},{"internalType":"address[]","name":"feeReceivers","type":"address[]"},{"internalType":"uint256[]","name":"feeAmounts","type":"uint256[]"},{"internalType":"address","name":"dstReceiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"minReturnAmount","type":"uint256"},{"internalType":"uint256","name":"flags","type":"uint256"},{"internalType":"bytes","name":"permit","type":"bytes"}],"internalType":"struct IMetaAggregationRouterV2.SwapDescriptionV2","name":"desc","type":"tuple"},{"internalType":"bytes","name":"clientData","type":"bytes"}],"internalType":"struct IMetaAggregationRouterV2.SwapExecutionParams","name":"execution","type":"tuple"}],"name":"swapGeneric","outputs":[{"internalType":"uint256","name":"returnAmount","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"contract IAggregationExecutor","name":"caller","type":"address"},{"components":[{"internalType":"contract IERC20","name":"srcToken","type":"address"},{"internalType":"contract IERC20","name":"dstToken","type":"address"},{"internalType":"address[]","name":"srcReceivers","type":"address[]"},{"internalType":"uint256[]","name":"srcAmounts","type":"uint256[]"},{"internalType":"address[]","name":"feeReceivers","type":"address[]"},{"internalType":"uint256[]","name":"feeAmounts","type":"uint256[]"},{"internalType":"address","name":"dstReceiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"minReturnAmount","type":"uint256"},{"internalType":"uint256","name":"flags","type":"uint256"},{"internalType":"bytes","name":"permit","type":"bytes"}],"internalType":"struct IMetaAggregationRouterV2.SwapDescriptionV2","name":"desc","type":"tuple"},{"internalType":"bytes","name":"executorData","type":"bytes"},{"internalType":"bytes","name":"clientData","type":"bytes"}],"name":"swapSimpleMode","outputs":[{"internalType":"uint256","name":"returnAmount","type":"uint256"},{"internalType":"uint256","name":"gasUsed","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"addr","type":"address[]"},{"internalType":"bool[]","name":"value","type":"bool[]"}],"name":"updateWhitelist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]; const state = {connectedAddress: null,optionBook: null,orders: [],selectedAsset: 'ETH',market_prices: {},refreshTimer: null,expiryTime: null,selectedOrderIndex: null,selectedPositionSize: 100,viewMode: 'advanced',countDownInterval: 0,selectedPositionPercentage: 50,selectedExpiry: null,selectedStrike: null,}; const MARKET_DATA_API = 'https: const REFRESH_INTERVAL = 30000; const OPTION_BOOK_ADDRESS = "0xA63D2717538834E553cbe811B04a17eC748D71FB"; const MAKER_ADDRESS = "0xf1711BA7E74435032AA103Ef20a4cBeCE40B6df5"; const PRICE_DECIMALS = 8; const TWO_HOURS_IN_SECONDS = 7200; const UTC_EXPIRY_HOUR = 8; const MULTICALL_ADDRESS = "0xfEE958Fa595B4478cea7560C91400A98b83d6C91"; let lastSelectedStrike = null; let lastSelectedSliderPosition = null; const optionCalculator = {calculateLeverage: function(premium,order,collateral) {const MAX_LEVERAGE = 10000; try {if (order.isCall) {const ratio = 1 / parseFloat(premium); return ratio > MAX_LEVERAGE ? `> ${MAX_LEVERAGE}` : ratio.toFixed(2)}else if (!order.isCall) {const asset = CONFIG.getUnderlyingAsset(order.priceFeed); const assetPrice = state.market_prices[asset]; const ratio = assetPrice / parseFloat(premium); const cappedRatio = Math.min(ratio,MAX_LEVERAGE); return cappedRatio.toFixed(2)}else if (parseFloat(premium) === 0 || premium === "0") {return "--"}else {const ratio = 1 / parseFloat(premium); const cappedRatio = Math.min(ratio,MAX_LEVERAGE); console.log(`Default leverage calculation: 1 / ${premium}= ${cappedRatio}`); return cappedRatio.toFixed(2)}}catch (e) {console.error("Error calculating payout ratio:",e); return "--"}},calculateProfitScenarios: function(order,strike,positionSize,numContracts) {console.log("Order:",order); const isCall = order.isCall; const assetPrice = state.market_prices[CONFIG.getCollateralDetails(order.collateral).asset]; const positionSizeInDollars = isCall ? positionSize * assetPrice : positionSize; const lossScenario = {price: parseFloat(strike),direction: isCall ? 'Below' : 'Above',profit: -positionSize,profitInDollars: -positionSizeInDollars,profitPercent: -100 }; const premium = parseFloat(formatUnits(order.price,PRICE_DECIMALS)); const breakeven = this.calculateBreakeven(isCall,parseFloat(strike),positionSizeInDollars / parseFloat(numContracts)); const priceDelta1 = strike * (isCall ? 0.01 : -0.01); const priceDelta2 = strike * (isCall ? 0.02 : -0.02); const price1 = parseFloat(strike) + priceDelta1; const price2 = parseFloat(strike) + priceDelta2; let profit1 = Math.abs(priceDelta1) * parseFloat(numContracts); let profit2 = Math.abs(priceDelta2) * parseFloat(numContracts); const profit1Percent = ((profit1 / positionSizeInDollars) * 100).toFixed(0); const profit2Percent = ((profit2 / positionSizeInDollars) * 100).toFixed(0); return {loss: lossScenario,breakeven: breakeven,profit1: {price: price1,profit: profit1.toFixed(2),profitPercent: profit1Percent },profit2: {price: price2,profit: profit2.toFixed(2),profitPercent: profit2Percent }}},calculateApprovalAmount: function(order,collateral,positionSize) {return ethers.utils.parseUnits(positionSize.toFixed(collateral.decimals),collateral.decimals)},calculateApprovalAmountWithLimit: function(order,collateral,positionSize,useExactApproval) {const requiredAmount = ethers.utils.parseUnits(positionSize.toFixed(collateral.decimals),collateral.decimals); if (useExactApproval) {return requiredAmount}const thousandDollarLimit = this.calculateThousandDollarEquivalent(collateral); return requiredAmount.gt(thousandDollarLimit) ? requiredAmount : thousandDollarLimit},calculateThousandDollarEquivalent: function(collateral) {const THOUSAND_DOLLARS = 1000; switch (collateral.name) {case 'USDC': return ethers.utils.parseUnits('1000',6); case 'WETH': const ethPrice = state.market_prices['ETH'] || 2500; const wethAmount = THOUSAND_DOLLARS / ethPrice; return ethers.utils.parseUnits(wethAmount.toFixed(18),18); case 'CBBTC': const btcPrice = state.market_prices['BTC'] || 100000; const cbbtcAmount = THOUSAND_DOLLARS / btcPrice; return ethers.utils.parseUnits(cbbtcAmount.toFixed(8),8); default: return ethers.utils.parseUnits('1000',18)}},calculateBreakeven: function(isCall,strike,premium) {return isCall ? (parseFloat(strike) + parseFloat(premium)) : (parseFloat(strike) - parseFloat(premium))},calculateMaxContracts: function(order,collateral) {const makerCollateral = parseFloat(formatUnits(order.maxCollateralUsable,collateral.decimals)); const strikePrice = parseFloat(formatUnits(order.strikes[0],PRICE_DECIMALS)); let maxContracts; if (order.isCall) {maxContracts = makerCollateral}else {maxContracts = makerCollateral / strikePrice}return maxContracts * 0.9999},calculatePositionDetails: function(order,collateral,percentage) {const maxContracts = this.calculateMaxContracts(order,collateral); const optionPrice = parseFloat(formatUnits(order.price,PRICE_DECIMALS)); const selectedContracts = (percentage / 100) * maxContracts; const positionCost = selectedContracts * optionPrice; return {positionCost,selectedContracts,maxContracts,optionPrice }},calculateSettlementScenarios: function(position) {try {if (!position || typeof position.strikePrice === 'undefined') {throw new Error("Invalid position data for settlement calculations")}const strikePrice = position.strikePrice; const isCall = position.optionType === 'CALL'; const cost = isCall ? position.cost * state.market_prices[CONFIG.getCollateralDetails(position.collateralToken).asset] : position.cost; const payoutRatio = parseFloat(position.payoutRatio); const breakeven = this.calculateBreakeven(isCall,strikePrice,cost / payoutRatio); if (isCall) {const lossScenario = {price: strikePrice,description: `$${strikePrice.toFixed(2)}or below: Option expires worthless,lose $${cost.toFixed(2)}` }; const breakevenScenario = {price: breakeven,description: `$${breakeven.toFixed(2)}: Break even` }; const profit1Price = strikePrice * 1.05; const profit1Amount = payoutRatio * (profit1Price - strikePrice) - cost; const profit1Percent = (profit1Amount / Math.max(0.01,cost)) * 100; const profit1Scenario = {price: profit1Price,description: `$${profit1Price.toFixed(2)}: Profit $${profit1Amount.toFixed(2)}(${profit1Percent.toFixed(1)}% return)` }; const profit2Price = strikePrice * 1.1; const profit2Amount = payoutRatio * (profit2Price - strikePrice) - cost; const profit2Percent = (profit2Amount / Math.max(0.01,cost)) * 100; const profit2Scenario = {price: profit2Price,description: `$${profit2Price.toFixed(2)}: Profit $${profit2Amount.toFixed(2)}(${profit2Percent.toFixed(1)}% return)` }; return {loss: lossScenario,breakeven: breakevenScenario,profit1: profit1Scenario,profit2: profit2Scenario }}else {const lossScenario = {price: strikePrice,description: `$${strikePrice.toFixed(2)}or above: Option expires worthless,lose $${cost.toFixed(2)}` }; const breakevenScenario = {price: breakeven,description: `$${breakeven.toFixed(2)}: Break even` }; const profit1Price = strikePrice * 0.95; const profit1Amount = payoutRatio * (strikePrice - profit1Price) - cost; const profit1Percent = (profit1Amount / Math.max(0.01,cost)) * 100; const profit1Scenario = {price: profit1Price,description: `$${profit1Price.toFixed(2)}: Profit $${profit1Amount.toFixed(2)}(${profit1Percent.toFixed(1)}% return)` }; const profit2Price = strikePrice * 0.9; const profit2Amount = payoutRatio * (strikePrice - profit2Price) - cost; const profit2Percent = (profit2Amount / Math.max(0.01,cost)) * 100; const profit2Scenario = {price: profit2Price,description: `$${profit2Price.toFixed(2)}: Profit $${profit2Amount.toFixed(2)}(${profit2Percent.toFixed(1)}% return)` }; return {loss: lossScenario,breakeven: breakevenScenario,profit1: profit1Scenario,profit2: profit2Scenario }}}catch (error) {console.error("Error calculating settlement scenarios:",error); return {loss: {description: "Below strike: Option expires worthless" },breakeven: {description: "At breakeven: Recover cost" },profit1: {description: "Above strike: Profit increases" },profit2: {description: "Further increase: Higher profit" }}}}}; const CONFIG = {KYBER_CONTRACT_ADDRESS: '0x6131B5fae19EA4f9D964eAc0408E4408b66337b5',priceFeedsMap: {'ETH': '0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70','BTC': '0x64c911996D3c6aC71f9b455B1E8E7266BcbD848F' },collateralMap: {'ETH': '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee','USDC': '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913','WETH': '0x4200000000000000000000000000000000000006','CBBTC': '0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf' },implementationMap: {"0xb2Bd24F67bFBe083D6380244e770bF51dE3F0051": {name: "INVERSE_CALL",type: "VANILLA",num_strikes: 1 },"0x1418b528954cecAA1920eE61982F4DEB0F5ffE8a": {name: "PUT",type: "VANILLA",num_strikes: 1 },"0x391F2dCF9F9Dab4149B0BFd0e05fbf10ddFE526A": {name: "CALL_SPREAD",type: "SPREAD",num_strikes: 2 },"0x1111111111111111111111111111111111111111": {name: "INVERSE_CALL_SPREAD",type: "SPREAD",num_strikes: 2 },"0x2222222222222222222222222222222222222222": {name: "PUT_SPREAD",type: "SPREAD",num_strikes: 2 },"0xD2cF183474494F413D31b245C037212838904761": {name: "CALL_FLYS",type: "BUTTERFLY",num_strikes: 3 },"0x806D5AaE70f1fA595CaDed5d3181e818b16F3389": {name: "PUT_FLYS",type: "BUTTERFLY",num_strikes: 3 },"0x68D20cE348326f7fBF85101dF3319E870911fdFD": {name: "IRON_CONDOR",type: "IRON_CONDOR",num_strikes: 4 },"0xb36b6361849E87C369F8d6Ea072c3dFaa16A3557": {name: "CALL_CONDOR",type: "CONDOR",num_strikes: 4 },"0x421E7cC6EECC9ab8466E627d2FaAec951523AC9a": {name: "PUT_CONDOR",type: "CONDOR",num_strikes: 4 }},getCollateralDetails: function(tokenAddress) {const tokens = {"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee": {name: "ETH",decimals: 18,asset: "ETH" },"0x4200000000000000000000000000000000000006": {name: "WETH",decimals: 18,asset: "ETH" },"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913": {name: "USDC",decimals: 6,asset: "USD" },"0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf": {name: "CBBTC",decimals: 8,asset: "BTC" }}; return tokens[ethers.utils.getAddress(tokenAddress)] || {name: "UNKNOWN",decimals: 18,asset: "UNKNOWN" }},getOptionDetails: function(implementation) {return CONFIG.implementationMap[implementation] || {name: "UNKNOWN",type: "UNKNOWN",num_strikes: 1 }},getUnderlyingAsset: function(priceFeed) {for (const [asset,feed] of Object.entries(this.priceFeedsMap)) {if (feed === priceFeed) {return asset}}return "UNKNOWN"}}; window.state = state; class UIStateManager {constructor() {this.storagePrefix = 'chiong_ui_'; this.defaultStates = {trollbox_visible: true,trollbox_minimized: false,analytics_collapsed: false,analytics_chart_expanded: false,eth_wrap_collapsed: false }; this.saveState = this.saveState.bind(this); this.loadState = this.loadState.bind(this); this.getState = this.getState.bind(this); this.setState = this.setState.bind(this); this.resetState = this.resetState.bind(this)}saveState(key,value) {try {const storageKey = this.storagePrefix + key; localStorage.setItem(storageKey,JSON.stringify(value))}catch (error) {console.warn(`Failed to save UI state ${key}:`,error)}}loadState(key,defaultValue = null) {try {const storageKey = this.storagePrefix + key; const stored = localStorage.getItem(storageKey); if (stored !== null) {return JSON.parse(stored)}return defaultValue !== null ? defaultValue : this.defaultStates[key]}catch (error) {console.warn(`Failed to load UI state ${key}:`,error); return defaultValue !== null ? defaultValue : this.defaultStates[key]}}getState(key,defaultValue = null) {return this.loadState(key,defaultValue)}setState(key,value) {this.saveState(key,value)}resetState(key) {try {const storageKey = this.storagePrefix + key; localStorage.removeItem(storageKey)}catch (error) {console.warn(`Failed to reset UI state ${key}:`,error)}}resetAllStates() {try {const keysToRemove = []; for (let i = 0; i < localStorage.length; i++) {const key = localStorage.key(i); if (key && key.startsWith(this.storagePrefix)) {keysToRemove.push(key)}}keysToRemove.forEach(key => localStorage.removeItem(key))}catch (error) {console.warn('Failed to reset UI states:',error)}}getAllStates() {const states = {}; Object.keys(this.defaultStates).forEach(key => {states[key] = this.loadState(key)}); return states}initializeFromSavedStates() {this.initializeTrollboxState(); this.initializeAnalyticsState(); this.initializeEthWrapState()}initializeTrollboxState() {const visible = this.loadState('trollbox_visible',true); const minimized = this.loadState('trollbox_minimized',false); const widget = document.getElementById('trollbox-widget'); const toggle = document.getElementById('trollbox-toggle'); if (!widget || !toggle) {setTimeout(() => this.initializeTrollboxState(),1000); return}if (visible) {widget.classList.remove('hidden'); toggle.style.display = 'none'; if (minimized) {widget.classList.add('minimized')}else {widget.classList.remove('minimized')}}else {widget.classList.add('hidden'); toggle.style.display = 'flex'}const updateTrollboxInstance = (retryCount = 0) => {if (window.chiongTrollbox) {window.chiongTrollbox.isHidden = !visible; window.chiongTrollbox.isMinimized = minimized}else if (retryCount < 5) {setTimeout(() => updateTrollboxInstance(retryCount + 1),500 * (retryCount + 1))}}; updateTrollboxInstance()}initializeAnalyticsState() {const collapsed = this.loadState('analytics_collapsed',false); const chartExpanded = this.loadState('analytics_chart_expanded',false); if (collapsed) {this.applyAnalyticsCollapsedState(true)}if (chartExpanded) {this.applyAnalyticsChartExpandedState(true); this.initializeChartWhenReady()}if (window.analyticsManager) {window.analyticsManager.analyticsCollapsed = collapsed; window.analyticsManager.chartExpanded = chartExpanded}}initializeChartWhenReady() {const attemptChartInit = (retryCount = 0) => {if (window.analyticsManager && window.analyticsManager.initializeTradingViewChart) {setTimeout(() => {window.analyticsManager.initializeTradingViewChart(); window.analyticsManager.updateLevelsLegend()},200)}else if (retryCount < 10) {setTimeout(() => attemptChartInit(retryCount + 1),500 * (retryCount + 1))}}; attemptChartInit()}applyAnalyticsCollapsedState(collapsed) {const analyticsContent = document.getElementById('analytics-content'); const toggleBtn = document.getElementById('toggle-analytics-section'); if (!toggleBtn) return; if (collapsed) {if (analyticsContent) {analyticsContent.style.display = 'none'}else {const sections = [ '.support-resistance-section','.pc-ratio-dials','#analytics-status','#analytics-chart-section' ]; sections.forEach(selector => {const element = document.querySelector(selector); if (element) element.style.display = 'none'})}toggleBtn.innerHTML = '<i class="bi bi-chevron-down"></i>'; toggleBtn.setAttribute('title','Show Market Analytics')}else {if (analyticsContent) {analyticsContent.style.display = ''}else {const sections = [ '.support-resistance-section','.pc-ratio-dials','#analytics-status','#analytics-chart-section' ]; sections.forEach(selector => {const element = document.querySelector(selector); if (element) element.style.display = ''})}toggleBtn.innerHTML = '<i class="bi bi-chevron-up"></i>'; toggleBtn.setAttribute('title','Hide Market Analytics')}}applyAnalyticsChartExpandedState(expanded) {const chartSection = document.getElementById('analytics-chart-section'); const toggleBtn = document.getElementById('toggle-analytics-view'); if (!chartSection || !toggleBtn) return; if (expanded) {chartSection.style.display = 'block'; toggleBtn.innerHTML = '<i class="bi bi-arrows-collapse"></i>'; toggleBtn.setAttribute('title','Collapse Chart View')}else {chartSection.style.display = 'none'; toggleBtn.innerHTML = '<i class="bi bi-arrows-fullscreen"></i>'; toggleBtn.setAttribute('title','Expand Chart View')}}initializeEthWrapState() {const collapsed = this.loadState('eth_wrap_collapsed',false); if (collapsed) {this.applyEthWrapCollapsedState(true)}}applyEthWrapCollapsedState(collapsed) {const ethWrapContent = document.getElementById('eth-wrap-content'); const toggleBtn = document.getElementById('toggle-eth-wrap-section'); if (!toggleBtn) return; if (collapsed) {if (ethWrapContent) {ethWrapContent.style.display = 'none'}toggleBtn.innerHTML = '<i class="bi bi-chevron-down"></i>'; toggleBtn.setAttribute('title','Show ETH Wrapping')}else {if (ethWrapContent) {ethWrapContent.style.display = ''}toggleBtn.innerHTML = '<i class="bi bi-chevron-up"></i>'; toggleBtn.setAttribute('title','Hide ETH Wrapping')}}}window.uiStateManager = new UIStateManager(); if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded',() => {setTimeout(() => {window.uiStateManager.initializeFromSavedStates()},500)})}else {setTimeout(() => {window.uiStateManager.initializeFromSavedStates()},500)}async function retryWithExponentialBackoff(fn,options = {}) {const {maxRetries = 3,baseDelayMs = 1000,maxDelayMs = 8000,shouldRetry = defaultShouldRetry }= options; let lastError; for (let attempt = 0; attempt <= maxRetries; attempt++) {try {return await fn()}catch (error) {lastError = error; if (attempt === maxRetries) {break}if (!shouldRetry(error)) {break}const delay = Math.min(baseDelayMs * Math.pow(2,attempt),maxDelayMs); console.warn(`RPC call failed (attempt ${attempt + 1}/${maxRetries + 1}),retrying in ${delay}ms...`,{error: error.message,attempt: attempt + 1,maxRetries: maxRetries + 1 }); await sleep(delay)}}throw lastError}function defaultShouldRetry(error) {if (error.message && error.message.includes('429')) {return true}if (error.message && error.message.includes('Too Many Requests')) {return true}if (error.message && ( error.message.includes('network') || error.message.includes('timeout') || error.message.includes('ECONNRESET') || error.message.includes('ETIMEDOUT') )) {return true}if (error.code === -32603 && error.message && error.message.includes('429')) {return true}return false}function sleep(ms) {return new Promise(resolve => setTimeout(resolve,ms))}async function fetchWithRetry(url,options = {},retryOptions = {}) {return retryWithExponentialBackoff(async () => {const response = await fetch(url,options); if (response.status === 429) {throw new Error(`HTTP ${response.status}: Too Many Requests`)}const result = await response.json(); if (result.error && result.error.code === -32603 && result.error.message && result.error.message.includes('429')) {throw new Error(`RPC request failed: HTTP 429: Too Many Requests`)}return result},retryOptions)}if (typeof module !== 'undefined' && module.exports) {module.exports = {retryWithExponentialBackoff,defaultShouldRetry,sleep,fetchWithRetry }}else {window.retryHelper = {retryWithExponentialBackoff,defaultShouldRetry,sleep,fetchWithRetry }}const TRANSACTION_STORAGE_KEY = 'chiong_transaction_history'; const MAX_STORED_TRANSACTIONS = 100; const NOTIFICATION_DURATION = 5000; const BASESCAN_URL = 'https: const TX_STATUS = {PENDING: 'pending',CONFIRMED: 'confirmed',FAILED: 'failed' }; const FUNCTION_SIGNATURES = {'fillOrder': {abi: OPTION_BOOK_ABI,friendlyName: 'Fill Option Order',description: 'Execute option trade' },'swapAndFillOrder': {abi: OPTION_BOOK_ABI,friendlyName: 'Swap & Fill Order',description: 'Swap tokens and execute option trade' },'approve': {abi: ERC20ABI,friendlyName: 'Token Approval',description: 'Approve token spending' },'deposit': {abi: [{"inputs": [],"name": "deposit","outputs": [],"stateMutability": "payable","type": "function"}],friendlyName: 'Wrap ETH',description: 'Convert ETH to WETH' }}; let transactionHistory = []; let activeNotifications = new Map(); function shortenTxHash(hash) {return `${hash.substring(0,8)}...${hash.substring(hash.length - 6)}`}function formatTimestamp(timestamp) {return new Date(timestamp).toLocaleString()}function getTokenSymbol(address) {if (!address) return 'Unknown Token'; const normalizedAddress = address.toLowerCase(); const tokens = {'0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca': 'USDC','0x833589fcd6edb6e08f4c7c32d4f71b54bda02913': 'USDC','0x4200000000000000000000000000000000000006': 'WETH','0xcbb7c0000ab88b473b1f5afd9ef808440eed33bf': 'CBBTC' }; return tokens[normalizedAddress] || 'Unknown Token'}function isTransactionSuccessful(receipt) {if (!receipt) return false; const status = receipt.status; if (status === 1 || status === '0x1' || status === true || status === 'success') {return true}if (status === 0 || status === '0x0' || status === false || status === 'failed') {return false}console.warn(' Unusual transaction status format:',status,'Type:',typeof status); return true}function clearAllNotifications() {activeNotifications.forEach((notification,hash) => {closeNotificationElement(notification)}); activeNotifications.clear(); updateClearAllButtonVisibility(); const pendingTxs = transactionHistory.filter(tx => tx.status === TX_STATUS.PENDING); if (pendingTxs.length > 0) {const tenMinutesAgo = Date.now() - (10 * 60 * 1000); pendingTxs .filter(tx => tx.timestamp > tenMinutesAgo) .forEach(tx => {checkTransactionStatusFromBlockchain(tx.hash)})}updateTransactionDropdown()}async function refreshPendingTransactions() {const transactions = getStoredTransactions(); const pendingTransactions = transactions.filter(tx => tx.status === TX_STATUS.PENDING); if (pendingTransactions.length === 0) {return}for (const transaction of pendingTransactions) {try {await checkTransactionStatusFromBlockchain(transaction.hash)}catch (error) {console.error(' Error refreshing transaction',transaction.hash,':',error)}await new Promise(resolve => setTimeout(resolve,100))}updateTransactionDropdown(); updateClearAllButtonVisibility()}function clearTransactionHistory() {if (confirm('Are you sure you want to clear all transaction history? This cannot be undone.')) {transactionHistory = []; localStorage.removeItem(TRANSACTION_STORAGE_KEY); updateTransactionDropdown()}}async function checkTransactionStatusFromBlockchain(hash) {try {const provider = window.ethersProvider; if (!provider) {console.error(' No ethersProvider available on window'); return false}try {const receipt = await provider.getTransactionReceipt(hash); if (receipt) {const isSuccess = isTransactionSuccessful(receipt); const status = isSuccess ? TX_STATUS.CONFIRMED : TX_STATUS.FAILED; updateTransactionStatus(hash,status,receipt); return true}}catch (receiptError) {console.error(' Error during getTransactionReceipt:',receiptError); try {const tx = await provider.getTransaction(hash); if (tx && tx.blockNumber) {await new Promise(resolve => setTimeout(resolve,1000)); const delayedReceipt = await provider.getTransactionReceipt(hash); if (delayedReceipt) {const isSuccess = isTransactionSuccessful(delayedReceipt); const status = isSuccess ? TX_STATUS.CONFIRMED : TX_STATUS.FAILED; updateTransactionStatus(hash,status,delayedReceipt); return true}}}catch (txError) {console.error(' Error during getTransaction fallback:',txError)}}return false}catch (error) {console.error(' Error checking blockchain status for',hash,':',error); return false}}function getStoredTransactions() {return transactionHistory}function loadTransactionHistory() {try {const stored = localStorage.getItem(TRANSACTION_STORAGE_KEY); transactionHistory = stored ? JSON.parse(stored) : []}catch (error) {console.error('Error loading transaction history:',error); transactionHistory = []}}function saveTransactionHistory() {try {if (transactionHistory.length > MAX_STORED_TRANSACTIONS) {transactionHistory = transactionHistory.slice(-MAX_STORED_TRANSACTIONS)}localStorage.setItem(TRANSACTION_STORAGE_KEY,JSON.stringify(transactionHistory))}catch (error) {console.error('Error saving transaction history:',error)}}function addTransaction(txData) {transactionHistory.unshift(txData); saveTransactionHistory(); updateTransactionDropdown()}function updateTransaction(hash,updates) {const txIndex = transactionHistory.findIndex(tx => tx.hash === hash); if (txIndex !== -1) {transactionHistory[txIndex] = {...transactionHistory[txIndex],...updates }; saveTransactionHistory(); updateTransactionDropdown()}}function decodeFunctionCall(functionName,args,contractAddress) {const signature = FUNCTION_SIGNATURES[functionName]; if (!signature) {return {functionName: functionName,description: 'Unknown function call',details: [] }}let details = []; try {switch (functionName) {case 'fillOrder': if (args && args.length >= 1) {const order = args[0]; details = [ `Asset: ${order.isCall ? 'CALL' : 'PUT'}`,`Strike: $${ethers.utils.formatUnits(order.strikes[0],8)}`,`Expiry: ${new Date(order.expiry * 1000).toLocaleDateString()}`,`Collateral: ${getTokenSymbol(order.collateral)}` ]}break; case 'swapAndFillOrder': if (args && args.length >= 4) {const order = args[0]; const srcToken = args[3]; details = [ `Swap: ${getTokenSymbol(srcToken)} ${getTokenSymbol(order.collateral)}`,`Asset: ${order.isCall ? 'CALL' : 'PUT'}`,`Strike: $${ethers.utils.formatUnits(order.strikes[0],8)}` ]}break; case 'approve': if (args && args.length >= 2) {const spender = args[0]; const amount = args[1]; const tokenSymbol = getTokenSymbol(contractAddress); const isUnlimited = amount.toString() === ethers.constants.MaxUint256.toString(); details = [ `Token: ${tokenSymbol}`,`Spender: ${spender.substring(0,8)}...${spender.substring(spender.length - 4)}`,`Amount: ${isUnlimited ? 'Unlimited' : 'Limited approval'}` ]}break; case 'deposit': details = ['Converting ETH to WETH']; break}}catch (error) {console.error(' Error decoding function call:',error); if (functionName === 'approve') {details = [`Token: ${getTokenSymbol(contractAddress)}`,'Approving token spending']}}return {functionName: signature.friendlyName,description: signature.description,details }}function createNotificationElement(txData) {const notification = document.createElement('div'); notification.className = 'tx-notification'; notification.setAttribute('data-tx-hash',txData.hash); const statusIcon = getStatusIcon(txData.status); const statusClass = `status-${txData.status}`; notification.innerHTML = ` <div class="tx-notification-content ${statusClass}"> <div class="tx-notification-header"> <div class="tx-notification-icon">${statusIcon}</div> <div class="tx-notification-title">${txData.decodedData.functionName}</div> <button class="tx-notification-close" type="button">&times;</button> </div> <div class="tx-notification-body"> <div class="tx-notification-description">${txData.decodedData.description}</div> ${txData.decodedData.details.length > 0 ? `<div class="tx-notification-details"> ${txData.decodedData.details.map(detail => `<div class="detail-item">${detail}</div>`).join('')}</div>` : '' }<div class="tx-notification-hash"> <a href="${BASESCAN_URL}${txData.hash}" target="_blank" rel="noopener noreferrer"> View on BaseScan: ${shortenTxHash(txData.hash)}</a> </div> </div> </div> `; const closeBtn = notification.querySelector('.tx-notification-close'); if (closeBtn) {closeBtn.addEventListener('click',(e) => {e.stopPropagation(); closeNotificationElement(notification); activeNotifications.delete(txData.hash); updateClearAllButtonVisibility()})}return notification}function getStatusIcon(status) {switch (status) {case TX_STATUS.PENDING: return '<div class="spinner-border spinner-border-sm" role="status"></div>'; case TX_STATUS.CONFIRMED: return '<i class="bi bi-check-circle-fill text-success"></i>'; case TX_STATUS.FAILED: return '<i class="bi bi-x-circle-fill text-danger"></i>'; default: return '<i class="bi bi-clock-fill text-warning"></i>'}}function showNotification(txData) {const existingNotification = activeNotifications.get(txData.hash); if (existingNotification) {closeNotificationElement(existingNotification); activeNotifications.delete(txData.hash)}const container = getNotificationContainer(); const notification = createNotificationElement(txData); container.appendChild(notification); activeNotifications.set(txData.hash,notification); updateClearAllButtonVisibility(); requestAnimationFrame(() => {notification.classList.add('show')}); if (txData.status === TX_STATUS.CONFIRMED || txData.status === TX_STATUS.FAILED) {notification.autoCloseTimeout = setTimeout(() => {closeNotification(txData.hash)},NOTIFICATION_DURATION)}}function closeNotificationElement(notification) {if (!notification) return; if (notification.autoCloseTimeout) {clearTimeout(notification.autoCloseTimeout); notification.autoCloseTimeout = null}notification.classList.add('hide'); setTimeout(() => {if (notification.parentNode) {notification.parentNode.removeChild(notification)}},300)}function closeNotification(hash) {const notification = activeNotifications.get(hash); if (notification) {closeNotificationElement(notification); activeNotifications.delete(hash); updateClearAllButtonVisibility()}}function getNotificationContainer() {let container = document.getElementById('tx-notification-container'); if (!container) {container = document.createElement('div'); container.id = 'tx-notification-container'; container.className = 'tx-notification-container'; const clearAllButton = document.createElement('button'); clearAllButton.id = 'clear-all-notifications-btn'; clearAllButton.className = 'clear-all-notifications-btn'; clearAllButton.innerHTML = '<i class="bi bi-x-circle"></i> Clear All'; clearAllButton.title = 'Clear all notifications and reset state'; clearAllButton.style.display = 'none'; clearAllButton.addEventListener('click',(e) => {e.stopPropagation(); clearAllNotifications()}); container.appendChild(clearAllButton); document.body.appendChild(container)}updateClearAllButtonVisibility(); return container}function updateClearAllButtonVisibility() {const clearAllButton = document.getElementById('clear-all-notifications-btn'); if (clearAllButton) {clearAllButton.style.display = activeNotifications.size > 0 ? 'block' : 'none'}}function createTransactionDropdown() {const walletSection = document.querySelector('.wallet-section'); if (!walletSection) {return}const txButton = document.getElementById('tx-history-btn'); const dropdown = document.getElementById('tx-history-dropdown'); if (!txButton || !dropdown) {return}if (txButton.hasAttribute('data-listeners-attached')) {updateTransactionDropdown(); return}txButton.addEventListener('click',(e) => {e.stopPropagation(); toggleTransactionDropdown()}); document.addEventListener('click',(e) => {if (!dropdown.contains(e.target) && e.target !== txButton) {dropdown.style.display = 'none'}}); txButton.setAttribute('data-listeners-attached','true'); updateTransactionDropdown()}function toggleTransactionDropdown() {const dropdown = document.getElementById('tx-history-dropdown'); if (dropdown) {dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none'}}function updateTransactionDropdown() {const dropdown = document.getElementById('tx-history-dropdown'); const button = document.getElementById('tx-history-btn'); if (!dropdown || !button) return; const pendingCount = transactionHistory.filter(tx => tx.status === TX_STATUS.PENDING).length; const buttonIcon = pendingCount > 0 ? `<i class="bi bi-clock-history"></i><span class="badge bg-warning text-dark">${pendingCount}</span>` : '<i class="bi bi-clock-history"></i>'; button.innerHTML = buttonIcon; if (transactionHistory.length === 0) {dropdown.innerHTML = '<div class="tx-history-empty">No transactions yet</div>'}else {const recentTxs = transactionHistory.slice(0,10); const hasActiveNotifications = activeNotifications.size > 0; const hasPendingTxs = pendingCount > 0; dropdown.innerHTML = ` <div class="tx-history-header"> <span>Recent Transactions</span> <div class="tx-history-actions"> ${hasActiveNotifications ? ` <button class="btn btn-sm btn-outline-danger" onclick="clearAllNotifications()" title="Clear all active notifications"> <i class="bi bi-x-circle"></i> Clear Notifications </button> ` : ''}${hasPendingTxs ? ` <button class="btn btn-sm btn-outline-warning" onclick="refreshPendingTransactions()" title="Refresh status of pending transactions"> <i class="bi bi-arrow-clockwise"></i> Refresh Pending </button> ` : ''}<button class="btn btn-sm btn-outline-secondary" onclick="clearTransactionHistory()" title="Clear transaction history"> <i class="bi bi-trash"></i> Clear History </button> </div> </div> <div class="tx-history-list"> ${recentTxs.map(tx => ` <div class="tx-history-item ${tx.status}"> <div class="tx-history-item-header"> <span class="tx-function">${tx.decodedData.functionName}</span> <span class="tx-status-icon">${getStatusIcon(tx.status)}</span> </div> <div class="tx-history-item-details"> <small class="tx-time">${formatTimestamp(tx.timestamp)}</small> <a href="${BASESCAN_URL}${tx.hash}" target="_blank" class="tx-link"> ${shortenTxHash(tx.hash)}</a> </div> </div> `).join('')}</div> ${transactionHistory.length > 10 ? '<div class="tx-history-footer">Showing 10 most recent</div>' : ''}`}}function trackTransaction(hash,functionName,args,contractAddress) {const decodedData = decodeFunctionCall(functionName,args,contractAddress); const txData = {hash,status: TX_STATUS.PENDING,timestamp: Date.now(),functionName,contractAddress,decodedData }; addTransaction(txData); showNotification(txData); return txData}function updateTransactionStatus(hash,status,receipt = null) {const updates = {status }; if (receipt) {updates.blockNumber = receipt.blockNumber; updates.gasUsed = receipt.gasUsed?.toString(); updates.confirmationTime = Date.now()}updateTransaction(hash,updates); const hasActiveNotification = activeNotifications.has(hash); if (hasActiveNotification || status === TX_STATUS.CONFIRMED || status === TX_STATUS.FAILED) {const tx = transactionHistory.find(t => t.hash === hash); if (tx) {showNotification(tx)}}}function initializeTransactionNotifications() {loadTransactionHistory(); createTransactionDropdown()}window.txNotifications = {trackTransaction,updateTransactionStatus,initializeTransactionNotifications,createTransactionDropdown,closeNotification,clearAllNotifications,refreshPendingTransactions,clearTransactionHistory,checkTransactionStatusFromBlockchain,getStoredTransactions,isTransactionSuccessful,TX_STATUS }; window.closeNotification = closeNotification; window.clearAllNotifications = clearAllNotifications; window.refreshPendingTransactions = refreshPendingTransactions; window.clearTransactionHistory = clearTransactionHistory; let web3OnboardBridge; let ethereumClient; let WagmiCore; function storeRealWagmiFunctions() {if (window.WagmiCore && typeof window.WagmiCore.readContracts === 'function') {window.__WAGMI_READ_CONTRACTS__ = window.WagmiCore.readContracts; console.log('Real Wagmi readContracts detected and stored')}if (window.WagmiCore && typeof window.WagmiCore.readContract === 'function') {window.__WAGMI_READ_CONTRACT__ = window.WagmiCore.readContract; console.log('Real Wagmi readContract detected and stored')}}function loadWeb3OnboardBridge() {return new Promise((resolve,reject) => {if (window.Web3OnboardBridge) {console.log('Web3OnboardBridge already available'); return resolve()}console.log('Loading Web3OnboardBridge script...'); const existing = document.querySelector('script[data-web3onboard-bridge]'); if (existing) {console.log('Script already loading,waiting...'); existing.addEventListener('load',() => {console.log('Existing script loaded'); resolve()}); existing.addEventListener('error',() => {console.error('Existing script failed to load'); reject(new Error('Failed to load web3onboard bridge script'))}); return}const script = document.createElement('script'); script.src = 'dist/web3onboard-bridge.js'; script.async = true; script.setAttribute('data-web3onboard-bridge','true'); script.onload = () => {console.log('Web3OnboardBridge script loaded successfully'); resolve()}; script.onerror = () => {console.error('Failed to load Web3OnboardBridge script'); reject(new Error('Failed to load web3onboard bridge script'))}; document.head.appendChild(script)})}function __getBridge() {return window.Web3OnboardBridge || null}if (!window.ethereumClient) {window.ethereumClient = {getAccount: () => {const b = __getBridge(); const addr = b && b.getAddress ? b.getAddress() : null; return {address: addr,isConnected: !!addr }},watchAccount: (callback) => {let last = null; const interval = setInterval(() => {const b = __getBridge(); const curr = b && b.getAddress ? b.getAddress() : null; if (curr !== last) {last = curr; try {callback({address: curr,isConnected: !!curr })}catch (e) {}}},1000); return () => clearInterval(interval)}}; try {ethereumClient = window.ethereumClient}catch (e) {}}if (!window.WagmiCore) {window.WagmiCore = {readContract: async ({address,abi,functionName,args = [],chainId }) => {const directProvider = new ethers.providers.JsonRpcProvider('https: const contract = new ethers.Contract(address,abi,directProvider); return await contract[functionName](...(args || []))},readContracts: async (params) => {if (window.__WAGMI_READ_CONTRACTS__) {return await window.__WAGMI_READ_CONTRACTS__(params)}const {contracts = [] }= params; const directProvider = new ethers.providers.JsonRpcProvider('https: console.warn('Using fallback sequential calls - real Wagmi multicall not available'); const results = []; for (const c of contracts) {try {const {address,abi,functionName,args = [] }= c; const contract = new ethers.Contract(address,abi,directProvider); const value = await contract[functionName](...(args || [])); results.push({result: value })}catch (error) {console.error(`Sequential call failed for ${c.functionName}:`,error); results.push({result: null,error: error.message })}}return results},writeContract: async ({address,abi,functionName,args = [],chainId,value }) => {const b = __getBridge(); const signer = b && b.getSigner ? b.getSigner() : null; if (!signer) throw new Error('No signer available'); const contract = new ethers.Contract(address,abi,signer); const overrides = value !== undefined ? {value }: {}; const tx = await contract[functionName](...(args || []),overrides); return tx},waitForTransaction: async ({hash }) => {const directProvider = new ethers.providers.JsonRpcProvider('https: return await directProvider.waitForTransaction(hash)},getETHBalance: async (address) => {const directProvider = new ethers.providers.JsonRpcProvider('https: return await directProvider.getBalance(address)},wrapETH: async (amount) => {const b = __getBridge(); const signer = b && b.getSigner ? b.getSigner() : null; if (!signer) throw new Error('No signer available'); const WETH_ADDRESS = CONFIG.collateralMap.WETH; const WETH_ABI = [ 'function deposit() payable','function withdraw(uint256 amount)','function balanceOf(address owner) view returns (uint256)','function transfer(address to,uint256 amount) returns (bool)' ]; const wethContract = new ethers.Contract(WETH_ADDRESS,WETH_ABI,signer); const amountWei = ethers.utils.parseEther(amount.toString()); const tx = await wethContract.deposit({value: amountWei }); return tx},unwrapWETH: async (amount) => {const b = __getBridge(); const signer = b && b.getSigner ? b.getSigner() : null; if (!signer) throw new Error('No signer available'); const WETH_ADDRESS = CONFIG.collateralMap.WETH; const WETH_ABI = [ 'function deposit() payable','function withdraw(uint256 amount)','function balanceOf(address owner) view returns (uint256)','function transfer(address to,uint256 amount) returns (bool)' ]; const wethContract = new ethers.Contract(WETH_ADDRESS,WETH_ABI,signer); const amountWei = ethers.utils.parseEther(amount.toString()); const tx = await wethContract.withdraw(amountWei); return tx},getNetwork: async () => {const directProvider = new ethers.providers.JsonRpcProvider('https: const net = await directProvider.getNetwork(); const chainId = net?.chainId ?? net?.id; return {chain: {id: Number(chainId) }}},switchNetwork: async ({chainId }) => {const b = __getBridge(); const provider = b && b.getProvider ? b.getProvider() : null; const request = provider && provider.provider && provider.provider.request ? provider.provider.request.bind(provider.provider) : (window.ethereum && window.ethereum.request ? window.ethereum.request.bind(window.ethereum) : null); if (!request) throw new Error('No provider request available'); const hexChainId = typeof chainId === 'string' && chainId.toString().startsWith('0x') ? chainId : '0x' + Number(chainId).toString(16); await request({method: 'wallet_switchEthereumChain',params: [{chainId: hexChainId }] })}}; try {WagmiCore = window.WagmiCore}catch (e) {}}function setupOnboardCompatibility() {if (!window.Web3OnboardBridge) return; try {const getAddr = () => (window.Web3OnboardBridge.getAddress && window.Web3OnboardBridge.getAddress()) || null; window.ethereumClient = {getAccount: () => ({address: getAddr(),isConnected: !!getAddr() }),watchAccount: (callback) => {let last = getAddr(); const interval = setInterval(() => {const curr = getAddr(); if (curr !== last) {last = curr; try {callback({address: curr,isConnected: !!curr })}catch (e) {}}},1000); return () => clearInterval(interval)}}; window.WagmiCore = {readContract: async ({address,abi,functionName,args = [],chainId }) => {const directProvider = new ethers.providers.JsonRpcProvider('https: const contract = new ethers.Contract(address,abi,directProvider); return await contract[functionName](...(args || []))},readContracts: async (params) => {const {contracts = [] }= params; const directProvider = new ethers.providers.JsonRpcProvider('https: console.warn('Using fallback sequential calls - real Wagmi multicall not available'); const results = []; for (const c of contracts) {try {const {address,abi,functionName,args = [] }= c; const contract = new ethers.Contract(address,abi,directProvider); const value = await contract[functionName](...(args || [])); results.push({result: value })}catch (error) {console.error(`Sequential call failed for ${c.functionName}:`,error); results.push({result: null,error: error.message })}}return results},writeContract: async ({address,abi,functionName,args = [],chainId,value }) => {const signer = window.Web3OnboardBridge.getSigner && window.Web3OnboardBridge.getSigner(); if (!signer) throw new Error('No signer available'); const contract = new ethers.Contract(address,abi,signer); const tx = await contract[functionName](...(args || []),value !== undefined ? {value }: {}); return tx},waitForTransaction: async ({hash }) => {const directProvider = new ethers.providers.JsonRpcProvider('https: return await directProvider.waitForTransaction(hash)},getETHBalance: async (address) => {const directProvider = new ethers.providers.JsonRpcProvider('https: return await directProvider.getBalance(address)},wrapETH: async (amount) => {const b = __getBridge(); const signer = b && b.getSigner ? b.getSigner() : null; if (!signer) throw new Error('No signer available'); const WETH_ADDRESS = '0x4200000000000000000000000000000000000006'; const WETH_ABI = [ 'function deposit() payable','function withdraw(uint256 amount)','function balanceOf(address owner) view returns (uint256)','function transfer(address to,uint256 amount) returns (bool)' ]; const wethContract = new ethers.Contract(WETH_ADDRESS,WETH_ABI,signer); const amountWei = ethers.utils.parseEther(amount.toString()); const tx = await wethContract.deposit({value: amountWei }); return tx},unwrapWETH: async (amount) => {const b = __getBridge(); const signer = b && b.getSigner ? b.getSigner() : null; if (!signer) throw new Error('No signer available'); const WETH_ADDRESS = '0x4200000000000000000000000000000000000006'; const WETH_ABI = [ 'function deposit() payable','function withdraw(uint256 amount)','function balanceOf(address owner) view returns (uint256)','function transfer(address to,uint256 amount) returns (bool)' ]; const wethContract = new ethers.Contract(WETH_ADDRESS,WETH_ABI,signer); const amountWei = ethers.utils.parseEther(amount.toString()); const tx = await wethContract.withdraw(amountWei); return tx},getNetwork: async () => {const directProvider = new ethers.providers.JsonRpcProvider('https: const net = await directProvider.getNetwork(); const chainId = net?.chainId ?? net?.id; return {chain: {id: Number(chainId) }}},switchNetwork: async ({chainId }) => {const provider = window.Web3OnboardBridge.getProvider && window.Web3OnboardBridge.getProvider(); const request = provider && provider.provider && provider.provider.request ? provider.provider.request.bind(provider.provider) : (window.ethereum && window.ethereum.request ? window.ethereum.request.bind(window.ethereum) : null); if (!request) throw new Error('No provider request available'); const hexChainId = typeof chainId === 'string' && chainId.toString().startsWith('0x') ? chainId : '0x' + Number(chainId).toString(16); await request({method: 'wallet_switchEthereumChain',params: [{chainId: hexChainId }] })}}}catch (e) {console.warn('Failed setting up Web3Onboard compatibility layer',e)}}function shortenAddress(address) {return address ? `${address.substring(0,6)}...${address.substring(address.length - 4)}` : ""}async function setupWeb3Onboard() {try {console.log('Setting up Web3Onboard...'); await loadWeb3OnboardBridge(); await new Promise(resolve => setTimeout(resolve,100)); if (window.Web3OnboardBridge && typeof window.Web3OnboardBridge.init === 'function') {console.log('Web3OnboardBridge found,initializing...'); window.Web3OnboardBridge.init(); setupOnboardCompatibility(); try {ethereumClient = window.ethereumClient; WagmiCore = window.WagmiCore}catch (e) {}storeRealWagmiFunctions(); const address = window.Web3OnboardBridge.getAddress && window.Web3OnboardBridge.getAddress(); if (address) {updateUIForConnectedState(address); state.connectedAddress = address; console.log('Wallet already connected on initialization:',address)}else {console.log('Attempting auto-connect...'); try {const autoConnectResult = await window.Web3OnboardBridge.autoConnect(); if (autoConnectResult && autoConnectResult.address) {console.log('Auto-connect successful:',autoConnectResult.address); updateUIForConnectedState(autoConnectResult.address); state.connectedAddress = autoConnectResult.address}else {console.log('Auto-connect failed - no previous connection found')}}catch (error) {console.log('Auto-connect error:',error)}}setupAccountMonitoring(); console.log('Web3Onboard bridge initialized successfully'); return true}else {console.warn('Web3OnboardBridge not properly available after loading'); return false}}catch (error) {console.error('Failed to initialize Web3Onboard:',error); return false}}function setupAccountMonitoring() {let lastAddress = null; const interval = setInterval(() => {const currentAddress = window.Web3OnboardBridge.getAddress && window.Web3OnboardBridge.getAddress(); if (currentAddress !== lastAddress) {if (currentAddress) {updateUIForConnectedState(currentAddress); state.connectedAddress = currentAddress; refreshData(); verifyAndSwitchNetwork()}else {updateUIForDisconnectedState(); state.connectedAddress = null}lastAddress = currentAddress}},1000); window.accountMonitoringInterval = interval}function updateUIForConnectedState(address) {document.getElementById('wallet-status').classList.remove('not-connected'); document.getElementById('wallet-status').classList.add('connected'); const addrEl = document.getElementById('address-display'); if (addrEl) {addrEl.style.display = 'none'}const disconnectBtn = document.getElementById('disconnect-wallet-btn'); if (disconnectBtn) disconnectBtn.style.display = 'none'; const connectBtn = document.getElementById('connect-web3modal-btn'); if (connectBtn) connectBtn.style.display = 'none'; const connectionAlert = document.getElementById('connection-alert'); if (connectionAlert) connectionAlert.style.display = 'none'}function updateUIForDisconnectedState() {document.getElementById('wallet-status').classList.add('not-connected'); document.getElementById('wallet-status').classList.remove('connected'); const connectBtn = document.getElementById('connect-web3modal-btn'); if (connectBtn) connectBtn.style.display = 'block'; const disconnectBtn = document.getElementById('disconnect-wallet-btn'); if (disconnectBtn) disconnectBtn.style.display = 'none'; const addressDisplay = document.getElementById('address-display'); if (addressDisplay) {addressDisplay.textContent = ''; addressDisplay.style.display = 'none'}const connectionAlert = document.getElementById('connection-alert'); if (connectionAlert) connectionAlert.style.display = 'none'}async function verifyAndSwitchNetwork() {try {const {getNetwork,switchNetwork }= WagmiCore; const net = await getNetwork(); if (net?.chain?.id !== 8453) {console.log("Wrong network detected,switching to Base..."); await switchNetwork({chainId: 8453 })}}catch (error) {console.error("Failed to verify/switch network:",error); $('#connection-alert').text("Please switch to Base network in your wallet.").show()}}async function connectWallet() {try {if (!window.Web3OnboardBridge) {console.log('Web3Onboard bridge not found,attempting to initialize...'); const initialized = await setupWeb3Onboard(); if (!initialized) {console.log('Falling back to direct ethereum connection...'); return await connectWithDirectEthereum()}}if (!window.Web3OnboardBridge || typeof window.Web3OnboardBridge.connect !== 'function') {throw new Error('Web3Onboard bridge not properly initialized')}console.log('Connecting wallet via Web3Onboard...'); const result = await window.Web3OnboardBridge.connect(); if (result && result.address) {updateUIForConnectedState(result.address); state.connectedAddress = result.address; refreshData(); console.log('Wallet connected successfully:',result.address)}else {throw new Error('Failed to connect wallet - no address returned')}}catch (error) {console.error("Error connecting wallet:",error); const alertEl = document.getElementById('connection-alert'); if (alertEl) {alertEl.textContent = `Connection failed: ${error.message}`; alertEl.style.display = 'block'}}}async function connectWithDirectEthereum() {try {if (!window.ethereum) {throw new Error('No ethereum provider available')}console.log('Connecting via direct ethereum...'); const accounts = await window.ethereum.request({method: 'eth_requestAccounts' }); if (accounts && accounts.length > 0) {const address = accounts[0]; updateUIForConnectedState(address); state.connectedAddress = address; refreshData(); console.log('Wallet connected via direct ethereum:',address); if (!window.ethereumClient) {window.ethereumClient = {getAccount: () => ({address,isConnected: true }),watchAccount: (callback) => {window.ethereum.on('accountsChanged',(accounts) => {if (accounts.length > 0) {callback({address: accounts[0],isConnected: true })}else {callback({address: null,isConnected: false })}})}}; ethereumClient = window.ethereumClient}return true}else {throw new Error('No accounts returned')}}catch (error) {console.error('Direct ethereum connection failed:',error); throw error}}async function disconnectWallet() {try {if (window.Web3OnboardBridge && window.Web3OnboardBridge.disconnect) {await window.Web3OnboardBridge.disconnect()}updateUIForDisconnectedState(); state.connectedAddress = null}catch (error) {console.error('Error disconnecting wallet:',error)}}async function attemptAutoConnect() {try {if (window.Web3OnboardBridge && window.Web3OnboardBridge.autoConnect) {const autoConnectResult = await window.Web3OnboardBridge.autoConnect(); if (autoConnectResult && autoConnectResult.address) {updateUIForConnectedState(autoConnectResult.address); state.connectedAddress = autoConnectResult.address; if (typeof refreshData === 'function') {setTimeout(() => refreshData(false),1000)}return true}else {return false}}return false}catch (error) {return false}}window.attemptAutoConnect = attemptAutoConnect; window.testAutoConnect = function() {if (window.Web3OnboardBridge && window.Web3OnboardBridge.testAutoConnect) {return window.Web3OnboardBridge.testAutoConnect()}else {return null}}; window.testMulticall = async function() {if (window.__WAGMI_READ_CONTRACTS__) {return 'Real Wagmi readContracts available - multicall should work automatically'}else {return 'Real Wagmi readContracts not available - using fallback sequential calls'}}; $(document).ready(function() {$('#connect-web3modal-btn').show(); $('#connect-web3modal-btn').on('click',connectWallet); $('#disconnect-wallet-btn').on('click',disconnectWallet); setupWeb3Onboard().then(success => {}).catch(error => {})}); try {window.connectWallet = connectWallet; window.disconnectWallet = disconnectWallet; window.setupWeb3Onboard = setupWeb3Onboard; window.connectWithDirectEthereum = connectWithDirectEthereum}catch (e) {}function initializeNavigationState() {$('#nav-trade-bottom,#nav-positions-bottom,#nav-history-bottom,#nav-scoreboard-bottom').removeClass('active'); $('#nav-trade-bottom').addClass('active'); showSection('trade')}function setupEventListeners() {initializeNavigationState(); const connectWalletBtn = $('#connect-wallet'); if (connectWalletBtn.length > 0) {connectWalletBtn.on('click',() => showSection('trade'))}$('#nav-trade-bottom').on('click',() => showSection('trade')); $('#nav-positions-bottom').on('click',() => showSection('positions')); $('#nav-history-bottom').on('click',() => showSection('history')); $('#nav-scoreboard-bottom').on('click',() => showSection('scoreboard')); $('input[name="asset-selection"]').on('change',function() {const asset = $(this).val(); selectAsset(asset)}); $('input[name="asset-selection"]').on('change',function() {const checkedAsset = $('input[name="asset-selection"]:checked').val(); if (!checkedAsset) {selectAsset(null)}}); $('input[name="payment-asset-selection"]').on('change',function() {const asset = $(this).val(); if (typeof updateAllowanceDisplay === 'function') {updateAllowanceDisplay(asset)}updatePaymentAssetBalanceDisplay(asset); if (asset === 'WETH') {updateETHBalance(); $('#eth-wrap-section').show()}else {$('#eth-wrap-section').hide()}setTimeout(async () => {if (state.selectedOrderIndex !== null) {await updateTradeButtonState()}},100)}); $(document).on('input','#position-size-slider',updatePositionSize); $(document).on('click','.quick-amount-btn',function() {const percentage = parseFloat($(this).data('percentage')); $('#position-size-slider').val(percentage).trigger('input'); $('.quick-amount-btn').removeClass('active'); $(this).addClass('active')}); $(document).on('input','#conviction-slider',updateConviction); $(document).on('click','.option-row',function() {const index = parseInt($(this).attr('data-index')); if (!isNaN(index)) {selectOption(index)}}); $('#trade-now-btn').on('click',showTradeConfirmation); $('#confirm-trade-btn').on('click',executeTrade); $('#approve-max-btn').on('click',approveMaxForTrade); $('#approve-max-btn-main').on('click',approveMaxForTrade); $('#approve-single-btn-main').on('click',approveSingleTrade); $('#exact-approval-checkbox').on('change',function() {const isChecked = $(this).is(':checked'); localStorage.setItem('exactApprovalEnabled',isChecked); const helpText = $(this).siblings('.form-text').find('small'); if (isChecked) {helpText.text('Only the exact amount needed for this trade will be approved. You may need to approve again for future trades.')}else {helpText.text('Up to $1000 worth of tokens will be approved to reduce future approval transactions. When checked,approves only the exact amount needed for this trade.')}}); $('#swap-assets-btn').on('click',openSwapModal); $('#swap-from-asset').on('change',function() {setTimeout(() => {updateSwapFromBalance(); updateSwapCalculations()},100)}); $('#swap-from-amount').on('input',updateSwapCalculations); $('.quick-amounts .btn').on('click',function() {const amount = $(this).data('amount'); const isEthSpecific = $(this).data('eth-specific'); if (isEthSpecific) {$('#swap-from-asset').val('ETH').trigger('change')}$('#swap-from-amount').val(amount); updateSwapCalculations()}); $('#execute-swap-btn').on('click',executeSwap); setupWrapETHListeners(); $('#swap-from-asset').off('change.swap').on('change.swap',function() {updateSwapFromBalance()}); $('#swap-from-amount').off('input.swap').on('input.swap',function() {console.log('Amount changed,checking approval status...'); checkSwapApprovalNeeded().catch(error => {console.error('Error checking approval on amount change:',error)})}); $('#approve-swap-btn').off('click.swap').on('click.swap',function() {approveSwapToken()}); setTimeout(() => {$('.quick-amount-btn[data-percentage="100"]').addClass('active'); if (state.orders && state.orders.length > 0) {updateQuickAmountButtonText()}},100); initializeMainApproveButton()}function showSection(section) {$('.content-section').hide(); $('.nav-link').removeClass('active'); $('#nav-trade-bottom,#nav-positions-bottom,#nav-history-bottom,#nav-scoreboard-bottom').removeClass('active'); if (section === 'trade') {$('#asset-selector-section').show(); $('#quote-status-section').show(); $('.options-table-container').show(); $('#nav-trade-bottom').addClass('active'); setTimeout(() => {switchView('advanced'); if (typeof refreshData === 'function') {refreshData()}},100)}else if (section === 'positions') {$('#positions-section').show(); $('#nav-positions-bottom').addClass('active'); refreshPositions()}else if (section === 'history') {$('#history-section').show(); $('#nav-history-bottom').addClass('active'); loadTradeHistory()}else if (section === 'scoreboard-section') {console.log('Showing scoreboard section...'); $('#scoreboard-section').show(); $('#nav-scoreboard-bottom').addClass('active'); if (window.scoreboard && typeof window.scoreboard.loadData === 'function') {console.log('Loading scoreboard data for user visit'); window.scoreboard.loadData()}else {console.warn('Scoreboard module not available')}}}function switchView(view) {state.viewMode = 'advanced'; $('.options-table-container').show(); populateOptionsTable()}function animateTypewriter(text) {const buyingTextElement = $('#buying-text'); buyingTextElement.empty(); const letters = text.split(''); let currentText = ''; buyingTextElement.html('<span class="typing-cursor">|</span>'); letters.forEach((letter,index) => {setTimeout(() => {currentText += letter; let styledText = ''; const chars = currentText.split(''); chars.forEach((char,charIndex) => {if (char === ' ') {styledText += '<span>&nbsp;</span>'}else {if (text.indexOf('Buying') !== -1 && charIndex < 6) {styledText += `<span class="buying-word">${char}</span>`}else {styledText += `<span class="asset-options">${char}</span>`}}}); buyingTextElement.html(styledText + '<span class="typing-cursor">|</span>')},index * 80)}); setTimeout(() => {buyingTextElement.html(buyingTextElement.html().replace('<span class="typing-cursor">|</span>','')); setTimeout(() => {animateSpotPrice()},300)},letters.length * 80 + 500)}function animateSpotPrice() {const spotPriceElement = $('#spot-price-text'); spotPriceElement.show(); let currentPrice = '--'; if (state.selectedAsset && state.market_prices && state.market_prices[state.selectedAsset]) {currentPrice = state.market_prices[state.selectedAsset].toFixed(2)}const priceText = `Spot Price: $${currentPrice}`; const letters = priceText.split(''); let currentText = ''; spotPriceElement.html('<span class="typing-cursor">|</span>'); letters.forEach((letter,index) => {setTimeout(() => {currentText += letter; let styledText = ''; const labelEnd = currentText.indexOf(': $'); if (labelEnd !== -1) {const label = currentText.substring(0,labelEnd + 2); const value = currentText.substring(labelEnd + 2); styledText = `<span class="spot-label">${label}</span><span class="spot-value">${value}</span>`}else {styledText = `<span class="spot-label">${currentText}</span>`}spotPriceElement.html(styledText + '<span class="typing-cursor">|</span>')},index * 60)}); setTimeout(() => {spotPriceElement.html(spotPriceElement.html().replace('<span class="typing-cursor">|</span>',''))},letters.length * 60 + 500)}function selectAsset(asset) {if (!asset) {state.selectedAsset = null; updateUI('#selected-asset,#positions-selected-asset',''); updateUI('#asset-symbol',''); $('input[name="asset-selection"]').prop('checked',false); updateUI('#current-price','--'); $('#asset-selector-section').removeClass('hidden'); $('#buying-text').hide(); $('#spot-price-text').hide(); $('#conviction-slider').prop('disabled',true); $('#position-size-slider').prop('disabled',true); $('.quick-amount-btn').prop('disabled',true); $('#trade-now-btn').prop('disabled',true).text('SELECT ASSET TO TRADE'); state.selectedOrderIndex = null; $('.option-row').removeClass('selected'); return}state.selectedAsset = asset; updateUI('#selected-asset,#positions-selected-asset',asset); updateUI('#asset-symbol',asset); $(`input[name="asset-selection"][value="${asset}"]`).prop('checked',true); $('#asset-selector-section').addClass('hidden'); $('#buying-text').show(); animateTypewriter(`Buying ${asset}Options`); $('#conviction-slider').prop('disabled',false); $('#position-size-slider').prop('disabled',false); $('.quick-amount-btn').prop('disabled',false); refreshData()}function calculateAndUpdatePositionCost(order,collateral,percentage) {const {positionCost,selectedContracts,maxContracts,optionPrice }= optionCalculator.calculatePositionDetails(order,collateral,percentage); const formattedCost = positionCost.toFixed(collateral.decimals === 6 ? 2 : 6); updateDualUI('current-size',`${formattedCost}${collateral.asset}`); state.selectedPositionSize = positionCost; state.selectedContracts = selectedContracts; return {positionCost,selectedContracts }}async function updatePositionSize() {const percentage = document.getElementById('position-size-slider').value; const orderIndex = state.selectedOrderIndex; if (orderIndex === null) return; const order = state.orders[orderIndex].order; const collateral = CONFIG.getCollateralDetails(order.collateral); const {positionCost,selectedContracts }= optionCalculator.calculatePositionDetails( order,collateral,percentage ); state.selectedPositionPercentage = percentage; const selectedPositionSize = positionCost; state.selectedPositionSize = selectedPositionSize; const sizeDisplay = document.getElementById('current-size'); sizeDisplay.innerText = selectedPositionSize.toFixed(collateral.decimals === 6 ? 2 : 4); updateOptionPreview(); setTimeout(() => {try {kyberSwap.updateSwapInfo(order,selectedPositionSize)}catch (error) {console.warn('Background swap info update failed:',error)}},50); refreshFundStatus(); if (state.selectedOrderIndex !== null) {await updateTradeButtonState()}}function updateQuickAmountButtonText() {const orderIndex = state.selectedOrderIndex; if (orderIndex === null || !state.orders || state.orders.length === 0) return; const order = state.orders[orderIndex].order; const collateral = CONFIG.getCollateralDetails(order.collateral); console.log('updateQuickAmountButtonText - order:',order); console.log('updateQuickAmountButtonText - collateral:',collateral); $('.quick-amount-btn').each(function() {const percentage = parseFloat($(this).data('percentage')); console.log(`Button ${percentage}% - calculating with percentage:`,percentage); const {positionCost,selectedContracts }= optionCalculator.calculatePositionDetails( order,collateral,percentage ); console.log(`Button ${percentage}% - positionCost:`,positionCost,'selectedContracts:',selectedContracts); const formattedCost = positionCost.toFixed(collateral.decimals === 6 ? 2 : 4); $(this).text(`${percentage}% (${formattedCost}${collateral.asset})`)})}let isSelectingOption = false; function updatePaymentAsset(skipPreviewUpdate = false) {const selectedCollateral = getSelectedPaymentAsset(); const orderIndex = state.selectedOrderIndex; if (orderIndex === null) return; const order = state.orders[orderIndex]; const needsSwap = kyberSwap.isSwapNeeded(selectedCollateral,order.order); if (!needsSwap) {kyberSwap.hideSwapDisplay()}else {setTimeout(() => {try {kyberSwap.updateSwapInfo(order.order,state.selectedPositionSize)}catch (error) {console.warn('Background swap info update failed:',error)}},50)}if (!skipPreviewUpdate && !isSelectingOption) {updateOptionPreview()}refreshFundStatus()}function setupConvictionSlider() {if (!state.orders || state.orders.length === 0) return; const strikes = state.orders.map(order => {return parseFloat(formatUnits(order.order.strikes[0],PRICE_DECIMALS))}).sort((a,b) => a - b); const uniqueStrikes = [...new Set(strikes)]; if (uniqueStrikes.length === 0) return; state.sliderTicks = []; state.priceTicks = []; state.priceTicks = uniqueStrikes; const numStrikes = uniqueStrikes.length; for (let i = 0; i < numStrikes; i++) {const tickPosition = Math.round((i / (numStrikes - 1)) * 100); state.sliderTicks.push(tickPosition)}if ($('#conviction-datalist').length === 0) {$('<datalist id="conviction-datalist"></datalist>').insertAfter('#conviction-slider'); $('#conviction-slider').attr('list','conviction-datalist')}if ($('#adv-conviction-datalist').length === 0) {$('<datalist id="adv-conviction-datalist"></datalist>').insertAfter('#adv-conviction-slider'); $('#adv-conviction-slider').attr('list','adv-conviction-datalist')}$('#conviction-datalist,#adv-conviction-datalist').empty(); state.sliderTicks.forEach(tick => {$('#conviction-datalist,#adv-conviction-datalist').append(`<option value="${tick}"></option>`)}); updateDualUI('low-price',`$${formatNumber(uniqueStrikes[0])}`); updateDualUI('high-price',`$${formatNumber(uniqueStrikes[uniqueStrikes.length - 1])}`); let initialSliderIndex = Math.floor(uniqueStrikes.length / 2); let initialSliderTickValue = state.sliderTicks[initialSliderIndex] || 50; if (lastSelectedStrike !== null) {let closestIndex = 0; let minDiff = Math.abs(uniqueStrikes[0] - lastSelectedStrike); for (let i = 1; i < uniqueStrikes.length; i++) {const diff = Math.abs(uniqueStrikes[i] - lastSelectedStrike); if (diff < minDiff) {minDiff = diff; closestIndex = i}}initialSliderIndex = closestIndex; initialSliderTickValue = state.sliderTicks[closestIndex]}updateDualUI('current-target',`$${formatNumber(uniqueStrikes[initialSliderIndex])}`); updateDualUI('conviction-slider',initialSliderTickValue,'val'); if (lastSelectedSliderPosition !== null) {let closestTick = state.sliderTicks[0]; let minDistance = Math.abs(lastSelectedSliderPosition - closestTick); for (let i = 1; i < state.sliderTicks.length; i++) {const distance = Math.abs(lastSelectedSliderPosition - state.sliderTicks[i]); if (distance < minDistance) {minDistance = distance; closestTick = state.sliderTicks[i]}}updateDualUI('conviction-slider',closestTick,'val')}}function updateConviction(e) {const sliderValue = parseInt($(this).val()); if (state.sliderTicks && state.sliderTicks.length > 0) {let closestTick = state.sliderTicks[0]; let minDistance = Math.abs(sliderValue - closestTick); for (let i = 1; i < state.sliderTicks.length; i++) {const distance = Math.abs(sliderValue - state.sliderTicks[i]); if (distance < minDistance) {minDistance = distance; closestTick = state.sliderTicks[i]}}$(this).val(closestTick); const priceIndex = state.sliderTicks.indexOf(closestTick); if (priceIndex >= 0) {updateDualUI('current-target',`$${formatNumber(state.priceTicks[priceIndex])}`)}}setTimeout(() => {selectOptionBasedOnConviction().catch(error => {console.error("Error in background option selection:",error)})},50)}async function selectOptionBasedOnConviction(updatePaymentAsset = false) {let sliderValue; if ($('#advanced-view-container').is(':visible')) {sliderValue = parseInt($('#adv-conviction-slider').val())}else {sliderValue = parseInt($('#conviction-slider').val())}if (!state.orders || state.orders.length === 0 || !state.sliderTicks || state.sliderTicks.length === 0) return; const tickIndex = state.sliderTicks.indexOf(sliderValue); if (tickIndex === -1) return; const targetPrice = state.priceTicks[tickIndex]; if (!targetPrice) return; if (!state.orders || state.orders.length === 0) {console.warn("No orders available for selection"); return}const extractStrike = order => parseFloat(formatUnits(order.order.strikes[0],PRICE_DECIMALS)); const bestOrderIndex = findNearestOption(targetPrice,state.orders,extractStrike); selectOption(bestOrderIndex).catch(error => {console.error("Error in background option selection:",error)})}function findNearestOption(targetValue,optionArray,valueExtractor) {if (!optionArray || optionArray.length === 0) return null; let bestIndex = 0; let bestDiff = Infinity; for (let i = 0; i < optionArray.length; i++) {const value = valueExtractor(optionArray[i]); const diff = Math.abs(value - targetValue); if (diff < bestDiff) {bestDiff = diff; bestIndex = i}}return bestIndex}async function selectOption(index) {if (!state.selectedAsset) {showNotification("Please select an asset (ETH or BTC) first.","warning"); return}isSelectingOption = true; try {state.selectedOrderIndex = index; $('.option-row').removeClass('selected'); $(`.option-row[data-index="${index}"]`).addClass('selected'); const orderData = state.orders[index]; const order = orderData.order; console.log('Selecting option at index:',index,'Order data:',{strike: formatUnits(order.strikes[0],PRICE_DECIMALS),type: order.isCall ? 'CALL' : 'PUT',expiry: new Date(parseInt(order.expiry) * 1000).toISOString() }); const collateral = CONFIG.getCollateralDetails(order.collateral); const currentPositionSize = state.selectedPositionSize || 100; const requiredAmountUSD = collateral.name === 'USDC' ? currentPositionSize : currentPositionSize * (state.market_prices[collateral.asset] || 1); let initialPaymentAsset = 'USDC'; if (order.isCall) {const collateralDetails = CONFIG.getCollateralDetails(order.collateral); if (collateralDetails.name === 'WETH') {initialPaymentAsset = 'WETH'}else if (collateralDetails.name === 'CBBTC') {initialPaymentAsset = 'CBBTC'}}$(`input[name="payment-asset-selection"][value="${initialPaymentAsset}"]`).prop('checked',true).trigger('change'); const button = $('#adv-trade-btn'); if (index !== null) {button.prop('disabled',false).text('TRADE NOW')}else {button.prop('disabled',true).text('SELECT OPTION TO TRADE')}updateOptionPreview(); updateQuickAmountButtonText(); await updateTradeButtonState()}catch (error) {console.error("Error in selectOption:",error); showNotification("Error selecting option. Please try again.","error")}finally {isSelectingOption = false}}function selectBestPaymentAssetFromCache(order,requiredAmountUSD) {if (!state.connectedAddress || !state.paymentAssetBalances) {return null}try {const requiredCollateral = CONFIG.getCollateralDetails(order.collateral); const preferredAsset = requiredCollateral.name; if (state.paymentAssetBalances[preferredAsset]) {const balance = parseFloat(state.paymentAssetBalances[preferredAsset]); const dollarValue = convertToDollarValue(balance,preferredAsset); if (dollarValue >= requiredAmountUSD) {return preferredAsset}}let bestAsset = null; let bestDollarValue = 0; Object.entries(state.paymentAssetBalances).forEach(([asset,balance]) => {if (asset === 'ETH') return; const balanceNum = parseFloat(balance); if (balanceNum > 0) {const dollarValue = convertToDollarValue(balanceNum,asset); if (dollarValue >= requiredAmountUSD && dollarValue > bestDollarValue) {bestAsset = asset; bestDollarValue = dollarValue}}}); if (!bestAsset) {Object.entries(state.paymentAssetBalances).forEach(([asset,balance]) => {if (asset === 'ETH') return; const balanceNum = parseFloat(balance); if (balanceNum > 0) {const dollarValue = convertToDollarValue(balanceNum,asset); if (dollarValue > bestDollarValue) {bestAsset = asset; bestDollarValue = dollarValue}}})}return bestAsset || preferredAsset}catch (error) {console.warn('Error in fast asset selection:',error); try {const requiredCollateral = CONFIG.getCollateralDetails(order.collateral); return requiredCollateral.name}catch (fallbackError) {console.error("Error in fallback asset selection:",fallbackError); return null}}}function updateOptionPreview() {if (state.selectedOrderIndex === null || !state.orders || state.orders.length === 0) {console.warn("updateOptionPreview called with no selected order."); return}const orderData = state.orders[state.selectedOrderIndex]; const order = orderData.order; const optionTypeDetails = CONFIG.getOptionDetails(order.implementation); const asset = CONFIG.getUnderlyingAsset(order.priceFeed); const strike = formatUnits(order.strikes[0],PRICE_DECIMALS); const collateral = CONFIG.getCollateralDetails(order.collateral); lastSelectedStrike = parseFloat(strike); $('#position-size-slider,#adv-position-size-slider').attr('min',1).attr('max',100).attr('step',1); $('.size-label.min').text('1%'); $('.size-label.max').text('100%'); if (!state.selectedPositionPercentage) {state.selectedPositionPercentage = 50; updateDualUI('position-size-slider',state.selectedPositionPercentage,'val'); updateDualUI('current-percentage',`${state.selectedPositionPercentage}%`)}else {updateDualUI('position-size-slider',state.selectedPositionPercentage,'val'); updateDualUI('current-percentage',`${state.selectedPositionPercentage}%`)}const {positionCost,selectedContracts }= calculateAndUpdatePositionCost(order,collateral,state.selectedPositionPercentage); const premium = parseFloat(formatUnits(order.price,PRICE_DECIMALS)); const rawPayoutRatio = optionCalculator.calculateLeverage(premium,order,collateral); $('.leverage-indicator').each(function() {$(this).html(`<span class="leverage-value">${rawPayoutRatio}x</span> LEVERAGE`)}); const optionTypeDisplay = order.isCall ? "CALL" : "PUT"; const direction = order.isCall ? "above" : "below"; const formattedContracts = selectedContracts.toFixed(4); updateDualUI('option-action-text',`BUY ${formattedContracts}${optionTypeDisplay}`); $('#leverage-value').text(rawPayoutRatio); $('#adjusted-leverage-value').text(rawPayoutRatio); $('#num-contracts').text(formattedContracts); updateDualUI('strike-price',strike,'text',formatNumber); updateDualUI('option-cost',`${positionCost.toFixed(collateral.decimals === 6 ? 2 : 4)}${collateral.name}`); updateDualUI('payout-ratio',formattedContracts); updateDualUI('payout-threshold',strike,'text',formatNumber); updateDualUI('payout-asset',collateral.name); $('#payout-direction').text(direction); setTimeout(() => {try {if (typeof updateTradeDetails === 'function') {updateTradeDetails(orderData,strike,rawPayoutRatio)}const {delta,iv }= orderData.greeks; const tableRow = $(`.option-row[data-index="${state.selectedOrderIndex}"]`); const tableBreakeven = tableRow.find('td:nth-child(6)').text().replace('$',''); updateDualUI('option-breakeven',tableBreakeven,'text',formatNumber); updateDualUI('option-delta',delta.toFixed(2)); updateDualUI('option-iv',`${parseInt(iv * 100)}%`); const mainExpirySeconds = state.expiryTime ? Math.floor(state.expiryTime / 1000) : 0; $('#time-left,#adv-time-left') .attr('data-countdown-expiry',mainExpirySeconds) .data('expiry',mainExpirySeconds); if (isNearExpiry()) {$('.expiry-warning').show()}else {$('.expiry-warning').hide()}}catch (error) {console.warn('Background option preview update failed:',error)}},25); refreshFundStatus()}async function showTradeConfirmation() {if (!state || state.selectedOrderIndex === null || !state.orders || state.orders.length === 0 || !state.selectedPositionSize || !state.selectedContracts) {showNotification("App is still loading. Please wait a moment and try again.","warning"); return}const baseOrder = state.orders[state.selectedOrderIndex]; const order = baseOrder.order; const asset = CONFIG.getUnderlyingAsset(order.priceFeed); const strike = formatUnits(order.strikes[0],PRICE_DECIMALS); const collateral = CONFIG.getCollateralDetails(order.collateral); const optionType = order.isCall ? "CALL" : "PUT"; const tradeButton = $('#trade-now-btn'); if (tradeButton.text().includes('LOADING SWAP')) {showNotification("Please wait for swap data to load before confirming the trade.","warning"); return}if (isOrderExpired(order.orderExpiryTimestamp)) {showNotification("Quotes are stale,please try again later.","warning"); $('#trade-confirm-modal').modal('hide'); return}else if (isOrderExpiringSoon(order.orderExpiryTimestamp)) {showNotification("This order is about to expire. Refreshing quote...","info"); refreshData().then(async () => {await selectOptionBasedOnConviction(); showTradeConfirmation()}); return}const positionSize = state.selectedPositionSize; const leverageValue = $('#leverage-value').text(); const selectedContracts = state.selectedContracts; const displayContracts = selectedContracts.toFixed(4); $('#modal-contracts').text(displayContracts); $('#tradeConfirmModalLabel').text('Confirm Trade'); $('#modal-option-type').text(`BUY ${displayContracts}${optionType}@ $${formatNumber(strike)}`); $('#modal-position-size').text(`${positionSize.toFixed(collateral.decimals === 6 ? 2 : 4)}${collateral.name}`); $('#modal-leverage').text(`${leverageValue}x`); $('#modal-expiry').text('08:00 UTC'); $('#modal-direction').text(order.isCall ? 'ABOVE' : 'BELOW'); $('#modal-strike').text(formatNumber(strike)); $('#modal-max-loss').text(`${positionSize.toFixed(collateral.decimals === 6 ? 2 : 6)}${collateral.asset}`); const timeLeft = getTimeToExpiry(); const formattedTime = formatTimeDisplay(timeLeft); const orderTimeLeft = getOrderTimeRemaining(order.orderExpiryTimestamp); const formattedOrderTime = formatTimeDisplay(orderTimeLeft); $('#modal-countdown').html(` <div>Order valid for: <span class="order-countdown">${formattedOrderTime}</span></div> <div>Option expires in: <span class="option-countdown" data-countdown-expiry="${order.expiry}">${formattedTime}</span></div> `); if (state.orderExpiryTimer) {clearInterval(state.orderExpiryTimer)}state.orderExpiryTimer = setInterval(() => {const newOrderTimeLeft = getOrderTimeRemaining(order.orderExpiryTimestamp); if (newOrderTimeLeft < 30) {clearInterval(state.orderExpiryTimer); $('#trade-confirm-modal').modal('hide'); setTimeout(() => {showNotification("Order quote expired. Refreshing data...","info"); refreshData().then(async () => {await selectOptionBasedOnConviction(); showTradeConfirmation()})},500); return}$('.order-countdown').text(formatTimeDisplay(newOrderTimeLeft))},1000); const scenarios = optionCalculator.calculateProfitScenarios( order,strike,positionSize,selectedContracts ); console.log("Scenarios:",scenarios); $('#scenario-loss').text(`${order.isCall ? 'Below' : 'Above'}$${formatNumber(strike)}: Lose ${positionSize.toFixed(collateral.decimals === 6 ? 2 : 4)}${collateral.name}(100% loss)`); $('#scenario-breakeven').text(`$${formatNumber(scenarios.breakeven)}: Break even`); $('#scenario-profit1').text(`$${formatNumber(scenarios.profit1.price)}: Profit $${scenarios.profit1.profit}in ${collateral.name}(${scenarios.profit1.profitPercent}% return)`); $('#scenario-profit2').text(`$${formatNumber(scenarios.profit2.price)}: Profit $${scenarios.profit2.profit}in ${collateral.name}(${scenarios.profit2.profitPercent}% return)`); const approvalNeeded = await checkApprovalNeeded(); if (approvalNeeded) {$('#approve-max-btn').show(); $('#confirm-trade-btn').hide()}else {$('#approve-max-btn').hide(); $('#confirm-trade-btn').show()}$('#trade-confirm-modal').modal('show'); $('#trade-confirm-modal').on('hidden.bs.modal',function() {if (state.orderExpiryTimer) {clearInterval(state.orderExpiryTimer); state.orderExpiryTimer = null}}); getOrderFillInfo(baseOrder).then(fillInfo => {if (fillInfo) {$('#modal-batch-info').show(); $('#modal-batch-capacity').text( `${fillInfo.fillPercentage}% of this order batch has been filled`); $('#modal-remaining-capacity').text( `${fillInfo.remainingCapacity}${fillInfo.collateralSymbol}available`)}else {$('#modal-batch-info').hide()}})}async function approveMaxForTrade() {try {if (!ethereumClient.getAccount().isConnected) {throw new Error("Wallet not connected. Please connect your wallet first.")}if (state.selectedOrderIndex === null) return; const baseOrder = state.orders[state.selectedOrderIndex]; const order = baseOrder.order; const requiredCollateralDetails = CONFIG.getCollateralDetails(order.collateral); const selectedPaymentAssetName = getSelectedPaymentAsset(); const isSwapRequired = selectedPaymentAssetName !== CONFIG.getCollateralDetails(order.collateral).name; let approvalAddress,tokenSymbol; if (isSwapRequired) {if (!state.currentSwapInfo || !state.currentSwapInfo.swapData) {throw new Error("Swap is required,but swap information is missing. Please select the payment asset again or wait for swap data to load.")}const swapInfo = state.currentSwapInfo.swapData; const inputTokenAddress = swapInfo.swaps[0][0].tokenIn; if (!swapInfo.tokens[inputTokenAddress]) {throw new Error("Input token details not found in swap data.")}const inputTokenDetails = swapInfo.tokens[inputTokenAddress]; approvalAddress = inputTokenAddress; tokenSymbol = inputTokenDetails.symbol}else {approvalAddress = order.collateral; tokenSymbol = requiredCollateralDetails.symbol}$('#approve-max-btn,#approve-max-btn-main').text('Approving...').prop('disabled',true); const {writeContract,waitForTransaction }= WagmiCore; const maxApproval = ethers.constants.MaxUint256; const approveTx = await writeContract({address: approvalAddress,abi: ERC20ABI,functionName: 'approve',args: [OPTION_BOOK_ADDRESS,maxApproval.toString()],chainId: 8453 }); showNotification(`Max approval submitted for ${tokenSymbol}! Transaction Hash: ${approveTx.hash.substring(0,10)}...`,"info",approveTx.hash); await waitForTransaction({hash: approveTx.hash,chainId: 8453 }); showNotification(`Max approval confirmed for ${tokenSymbol}! `,"success",approveTx.hash); const tokenSymbolForRefresh = Object.keys(CONFIG.collateralMap).find(key => CONFIG.collateralMap[key] === approvalAddress ); if (tokenSymbolForRefresh) {await refreshTokenAllowance(approvalAddress,tokenSymbolForRefresh,OPTION_BOOK_ADDRESS,'OptionBook')}await updateTradeButtonState()}catch (error) {console.error('Error in approveMaxForTrade:',error); showNotification(`Approval failed: ${error.message}`,"error"); $('#approve-max-btn,#approve-max-btn-main').text('Approve Max').prop('disabled',false); $('#approve-single-btn-main').text('Approve Single Trade').prop('disabled',false)}}async function approveSingleTrade() {try {if (state.selectedOrderIndex === null) {showNotification('No option selected for approval',"error"); return}const baseOrder = state.orders[state.selectedOrderIndex]; const order = baseOrder.order; const requiredCollateralDetails = CONFIG.getCollateralDetails(order.collateral); const selectedPaymentAssetName = getSelectedPaymentAsset(); const isSwapRequired = selectedPaymentAssetName !== CONFIG.getCollateralDetails(order.collateral).name; let approvalAddress,approvalAmountBN,tokenSymbol,tokenDecimals; if (isSwapRequired) {if (!state.currentSwapInfo || !state.currentSwapInfo.swapData) {throw new Error("Swap is required,but swap information is missing. Please select the payment asset again or wait for swap data to load.")}const swapInfo = state.currentSwapInfo.swapData; const inputTokenAddress = swapInfo.swaps[0][0].tokenIn; const inputAmount = swapInfo.inputAmount; if (!swapInfo.tokens[inputTokenAddress]) {throw new Error("Input token details not found in swap data.")}const inputTokenDetails = swapInfo.tokens[inputTokenAddress]; approvalAddress = inputTokenAddress; approvalAmountBN = ethers.BigNumber.from(inputAmount); tokenSymbol = inputTokenDetails.symbol; tokenDecimals = inputTokenDetails.decimals}else {approvalAmountBN = optionCalculator.calculateApprovalAmount( order,requiredCollateralDetails,state.selectedPositionSize ); approvalAddress = order.collateral; tokenSymbol = requiredCollateralDetails.symbol; tokenDecimals = requiredCollateralDetails.decimals}$('#approve-single-btn-main').text('Approving...').prop('disabled',true); const {writeContract }= WagmiCore; const txResponse = await writeContract({address: approvalAddress,abi: ERC20ABI,functionName: 'approve',args: [OPTION_BOOK_ADDRESS,approvalAmountBN],chainId: 8453 }); const {waitForTransaction }= WagmiCore; await waitForTransaction({hash: txResponse.hash,chainId: 8453 }); showNotification(`Single trade approval successful for ${ethers.utils.formatUnits(approvalAmountBN,tokenDecimals)}${tokenSymbol}`,"success"); console.log('Using targeted OptionBook allowance refresh instead of heavy multicall'); const tokenSymbolForRefresh = Object.keys(CONFIG.collateralMap).find(key => CONFIG.collateralMap[key] === approvalAddress ); if (tokenSymbolForRefresh) {await refreshTokenAllowance(approvalAddress,tokenSymbolForRefresh,OPTION_BOOK_ADDRESS,'OptionBook')}await updateTradeButtonState()}catch (error) {console.error('Error in approveSingleTrade:',error); showNotification(`Single trade approval failed: ${error.message}`,"error"); $('#approve-single-btn-main').text('Approve Single Trade').prop('disabled',false)}}async function checkApprovalNeeded() {try {if (state.selectedOrderIndex === null) {console.log('checkApprovalNeeded: No order selected'); return false}const baseOrder = state.orders[state.selectedOrderIndex]; const order = baseOrder.order; const requiredCollateralDetails = CONFIG.getCollateralDetails(order.collateral); const selectedPaymentAssetName = getSelectedPaymentAsset(); const isSwapRequired = selectedPaymentAssetName !== CONFIG.getCollateralDetails(order.collateral).name; console.log('checkApprovalNeeded:',{selectedPaymentAsset: selectedPaymentAssetName,requiredCollateral: requiredCollateralDetails.name,isSwapRequired: isSwapRequired,positionSize: state.selectedPositionSize }); if (isSwapRequired) {if (!state.currentSwapInfo || !state.currentSwapInfo.swapData) {console.log('checkApprovalNeeded: Swap required but no swap data available,trying to load swap data...'); try {if (state.selectedOrderIndex !== null && state.selectedPositionSize) {const orderData = state.orders[state.selectedOrderIndex]; await kyberSwap.updateSwapInfo(orderData.order,state.selectedPositionSize); if (state.currentSwapInfo && state.currentSwapInfo.swapData) {console.log('checkApprovalNeeded: Successfully loaded swap data')}else {console.log('checkApprovalNeeded: Still no swap data after trying to load'); return false}}else {console.log('checkApprovalNeeded: No order or position size available for swap data loading'); return false}}catch (error) {console.log('checkApprovalNeeded: Error loading swap data:',error); return false}}const swapInfo = state.currentSwapInfo.swapData; const inputTokenAddress = swapInfo.swaps[0][0].tokenIn; const inputAmount = swapInfo.inputAmount; console.log('checkApprovalNeeded: Swap details:',{inputTokenAddress: inputTokenAddress,inputAmount: inputAmount.toString() }); const {readContract }= WagmiCore; const inputAllowance = await readContract({address: inputTokenAddress,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,OPTION_BOOK_ADDRESS],chainId: 8453 }); const inputAllowanceBN = ethers.BigNumber.from(inputAllowance.toString()); const inputAmountBN = ethers.BigNumber.from(inputAmount); const approvalNeeded = inputAllowanceBN.lt(inputAmountBN); console.log('checkApprovalNeeded: Input token allowance check:',{allowance: inputAllowanceBN.toString(),required: inputAmountBN.toString(),approvalNeeded: approvalNeeded }); return approvalNeeded}else {const actualRequiredAmountBN = optionCalculator.calculateApprovalAmount( order,requiredCollateralDetails,state.selectedPositionSize ); console.log('checkApprovalNeeded: Direct collateral check:',{collateralAddress: order.collateral,requiredAmount: actualRequiredAmountBN.toString() }); const {readContract }= WagmiCore; const collateralAllowance = await readContract({address: order.collateral,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,OPTION_BOOK_ADDRESS],chainId: 8453 }); const collateralAllowanceBN = ethers.BigNumber.from(collateralAllowance.toString()); const approvalNeeded = collateralAllowanceBN.lt(actualRequiredAmountBN); console.log('checkApprovalNeeded: Collateral allowance check:',{allowance: collateralAllowanceBN.toString(),required: actualRequiredAmountBN.toString(),approvalNeeded: approvalNeeded }); return approvalNeeded}}catch (error) {console.error('Error checking approval:',error); return false}}function isOrderExpiringSoon(orderExpiryTimestamp) {const timeLeft = getOrderTimeRemaining(orderExpiryTimestamp); return timeLeft < 30}function isOrderExpired(orderExpiryTimestamp) {return getOrderTimeRemaining(orderExpiryTimestamp) == 0 }function getOrderTimeRemaining(orderExpiryTimestamp) {const now = Math.floor(Date.now() / 1000); const expiryTime = parseInt(orderExpiryTimestamp); return Math.max(0,expiryTime - now)}async function handlePriceSlippageRetry() {console.log("Handling price slippage - price moved during trade execution"); $('#trade-error-message').html(` <div class="d-flex align-items-center"> <div class="spinner-border spinner-border-sm me-2" role="status"> <span class="visually-hidden">Loading...</span> </div> <span>Price moved during trade execution. Recalculating with current market price...</span> </div> `); $('#trade-error-alert').removeClass('alert-danger').addClass('alert-info').show(); $('#confirm-trade-btn').text('Recalculating...').prop('disabled',true); try {state.currentSwapInfo = null; await refreshData(); if (state.selectedOrderIndex !== null) {await selectOptionBasedOnConviction(); await new Promise(resolve => setTimeout(resolve,2000)); const swapCheck = checkSwapReadiness(); if (swapCheck.ready) {$('#trade-error-alert').hide(); $('#confirm-trade-btn').text('Confirm Trade').prop('disabled',false); $('#trade-error-message').text('Quote updated successfully! You can now proceed with the trade.'); $('#trade-error-alert').removeClass('alert-info').addClass('alert-success').show(); setTimeout(() => {$('#trade-error-alert').hide()},3000)}else {$('#trade-error-message').text('Still calculating swap data. Please wait a moment and try again.'); $('#trade-error-alert').removeClass('alert-info').addClass('alert-warning').show(); $('#confirm-trade-btn').text('Try Again').prop('disabled',false)}}}catch (error) {console.error("Error during price slippage retry:",error); $('#trade-error-message').text('Failed to recalculate quote. Please close this dialog and try again.'); $('#trade-error-alert').removeClass('alert-info').addClass('alert-danger').show(); $('#confirm-trade-btn').text('Close & Retry').prop('disabled',false)}}const loggedExpiredOrders = new Set(); async function executeTrade() {$('#trade-error-alert').hide(); try {if (!ethereumClient.getAccount().isConnected) {throw new Error("Wallet not connected. Please connect your wallet first.")}$('#confirm-trade-btn').text(' ...').prop('disabled',true); if (state.selectedOrderIndex === null) return; const orderData = state.orders[state.selectedOrderIndex]; const order = orderData.order; const signature = orderData.signature; const requiredCollateralDetails = CONFIG.getCollateralDetails(order.collateral); if (isOrderExpiringSoon(order.orderExpiryTimestamp)) {$('#trade-confirm-modal').modal('hide'); showNotification("Order expired during confirmation. Refreshing quote...","info"); await refreshData(); await selectOptionBasedOnConviction(); showTradeConfirmation(); return}$('#confirm-trade-btn').text('Processing...').prop('disabled',true); const selectedPaymentAssetName = getSelectedPaymentAsset(); const isSwapRequired = selectedPaymentAssetName !== CONFIG.getCollateralDetails(order.collateral).name; let swapInfo = null; let inputTokenDetails = null; if (isSwapRequired) {if (!state.currentSwapInfo || !state.currentSwapInfo.swapData) {throw new Error("Swap is required,but swap information is missing. Please select the payment asset again or wait for swap data to load.")}swapInfo = state.currentSwapInfo.swapData; const inputTokenAddress = swapInfo.swaps[0][0].tokenIn; if (!swapInfo.tokens[inputTokenAddress]) {throw new Error("Input token details not found in swap data.")}inputTokenDetails = swapInfo.tokens[inputTokenAddress]}const {readContract,writeContract,waitForTransaction }= WagmiCore; if (isSwapRequired && swapInfo && inputTokenDetails) {const swapRouterAddress = swapInfo.routerAddress; const inputTokenAddress = inputTokenDetails.address; const inputAmount = swapInfo.inputAmount; const inputTokenDecimals = inputTokenDetails.decimals; const inputAllowance = await readContract({address: inputTokenAddress,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,OPTION_BOOK_ADDRESS],chainId: 8453 }); const inputAllowanceBN = ethers.BigNumber.from(inputAllowance.toString()); const inputAmountBN = ethers.BigNumber.from(inputAmount); if (inputAllowanceBN.lt(inputAmountBN)) {const useExactApproval = $('#exact-approval-checkbox').is(':checked'); const inputCollateralDetails = CONFIG.getCollateralDetails(inputTokenAddress); const inputPositionSize = parseFloat(ethers.utils.formatUnits(inputAmountBN,inputTokenDecimals)); const approvalAmountBN = optionCalculator.calculateApprovalAmountWithLimit( order,inputCollateralDetails,inputPositionSize,useExactApproval ); const approveInputTx = await writeContract({address: inputTokenAddress,abi: ERC20ABI,functionName: 'approve',args: [OPTION_BOOK_ADDRESS,approvalAmountBN.toString()],chainId: 8453 }); showNotification(`Input token approval submitted! Transaction Hash: ${approveInputTx.hash.substring(0,10)}...`,"info",approveInputTx.hash); await waitForTransaction({hash: approveInputTx.hash }); showNotification("Input token approval confirmed! ","success",approveInputTx.hash); console.log('Using targeted OptionBook allowance refresh instead of heavy multicall'); const inputTokenSymbol = Object.keys(CONFIG.collateralMap).find(key => CONFIG.collateralMap[key] === inputTokenAddress ); if (inputTokenSymbol) {await refreshTokenAllowance(inputTokenAddress,inputTokenSymbol,OPTION_BOOK_ADDRESS,'OptionBook')}}}const actualRequiredAmountBN = optionCalculator.calculateApprovalAmount( order,requiredCollateralDetails,state.selectedPositionSize ); const collateralAllowance = await readContract({address: order.collateral,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,OPTION_BOOK_ADDRESS],chainId: 8453 }); const collateralAllowanceBN = ethers.BigNumber.from(collateralAllowance.toString()); if (collateralAllowanceBN.lt(actualRequiredAmountBN)) {const useExactApproval = $('#exact-approval-checkbox').is(':checked'); const approvalAmountBN = optionCalculator.calculateApprovalAmountWithLimit( order,requiredCollateralDetails,state.selectedPositionSize,useExactApproval ); const approveCollateralTx = await writeContract({address: order.collateral,abi: ERC20ABI,functionName: 'approve',args: [OPTION_BOOK_ADDRESS,approvalAmountBN.toString()],chainId: 8453 }); showNotification(`Collateral approval submitted! Transaction Hash: ${approveCollateralTx.hash.substring(0,10)}...`,"info",approveCollateralTx.hash); await waitForTransaction({hash: approveCollateralTx.hash }); showNotification("Collateral approval confirmed! ","success",approveCollateralTx.hash); console.log('Using targeted OptionBook allowance refresh instead of heavy multicall'); const collateralTokenSymbol = Object.keys(CONFIG.collateralMap).find(key => CONFIG.collateralMap[key] === order.collateral ); if (collateralTokenSymbol) {await refreshTokenAllowance(order.collateral,collateralTokenSymbol,OPTION_BOOK_ADDRESS,'OptionBook')}}const numContracts = ethers.utils.parseUnits( state.selectedContracts.toFixed(requiredCollateralDetails.decimals),requiredCollateralDetails.decimals ); const orderParams = {maker: order.maker,orderExpiryTimestamp: order.orderExpiryTimestamp,collateral: order.collateral,isCall: order.isCall,priceFeed: order.priceFeed,implementation: order.implementation,isLong: order.isLong,maxCollateralUsable: order.maxCollateralUsable.toString(),strikes: order.strikes.map(s => s.toString()),expiry: order.expiry,price: order.price.toString(),numContracts: numContracts.toString() }; let tx; if (isSwapRequired && swapInfo) {const swapRouterAddress = swapInfo.routerAddress; const encodedSwapData = swapInfo.encodedSwapData; const swapSrcTokenAddress = inputTokenDetails.address; const swapSrcAmount = swapInfo.inputAmount; showNotification("Submitting swap and fill trade...","info"); tx = await writeContract({address: OPTION_BOOK_ADDRESS,abi: OPTION_BOOK_ABI,functionName: 'swapAndFillOrder',args: [ orderParams,signature,swapRouterAddress,swapSrcTokenAddress,swapSrcAmount,encodedSwapData ],chainId: 8453 }); showNotification(`Trade submitted successfully! Transaction Hash: ${tx.hash.substring(0,10)}...`,"success",tx.hash)}else {showNotification("Submitting trade...","info"); tx = await writeContract({address: OPTION_BOOK_ADDRESS,abi: OPTION_BOOK_ABI,functionName: 'fillOrder',args: [orderParams,signature],chainId: 8453 }); showNotification(`Trade submitted successfully! Transaction Hash: ${tx.hash.substring(0,10)}...`,"success",tx.hash)}const receipt = await waitForTransaction({hash: tx.hash }); if (isSwapRequired && swapInfo) {showNotification("Trade completed","success",tx.hash)}else {showNotification("Trade completed","success",tx.hash)}$('#trade-confirm-modal').modal('hide'); const asset = CONFIG.getUnderlyingAsset(order.priceFeed); const strike = formatUnits(order.strikes[0],PRICE_DECIMALS); const optionType = order.isCall ? "CALL" : "PUT"; const leverageValue = $('#leverage-value').text(); const position = {id: `pos-${Date.now()}`,txHash: tx.hash,asset: asset,type: optionType,strike: strike,size: state.selectedPositionSize,leverage: leverageValue,timestamp: Date.now(),status: 'open',pnl: 0 }; $('#trade-success-alert').fadeIn().delay(3000).fadeOut(); refreshBackend(); if ($('#positions-section').is(':visible')) {refreshPositions()}$('#confirm-trade-btn').text('Confirm Trade').prop('disabled',false)}catch (error) {console.error('Error executing trade:',error); $('#confirm-trade-btn').text('Confirm Trade').prop('disabled',false); let errorMessage = "Unknown error occurred"; if (error.code === 4001) {errorMessage = "Transaction rejected by user"}else if (error.error && error.error.message) {errorMessage = error.error.message}else if (error.message) {const reasonMatch = error.message.match(/reason="([^"]+)"/); if (reasonMatch && reasonMatch[1]) {errorMessage = reasonMatch[1]}else {if (error.shortMessage) {errorMessage = error.shortMessage}else {errorMessage = error.message}}}if (errorMessage.includes("Swap failed")) {errorMessage = "The token swap failed. This could be due to price changes or insufficient liquidity. Please try again."}else if (errorMessage.includes("Router not authorized")) {errorMessage = "Internal configuration error: The swap router is not authorized."}else if (errorMessage.includes("Exceeds max collateral")) {errorMessage = "This order batch is now full. Please try another option."; setTimeout(() => {refreshData(); $('#trade-confirm-modal').modal('hide')},3000)}else if (errorMessage.includes("insufficient allowance")) {errorMessage = "Insufficient token allowance. Please try the transaction again to grant permission."}else if (errorMessage.includes("transfer amount exceeds balance") || errorMessage.includes("ERC20 amount transfer exceeds balance") || errorMessage.includes("amount exceeds balance")) {handlePriceSlippageRetry(); return}$('#trade-error-message').text(errorMessage); $('#trade-error-alert').show(); console.log("Error details:",{message: errorMessage,originalError: error,})}}function refreshBackend() {$.get("https: if (x.status == "skipped") {console.log("Update skipped,retrying in 10 seconds..."); setTimeout(refreshBackend,10000)}else {console.log("Update successful.")}})}function updateTradeDetails(orderData,strike,rawLeverage) {updateDualUI('current-target',`$${formatNumber(strike)}`); const order = orderData.order; let putCount = 0; let callCount = 0; let minStrike = Infinity; let maxStrike = 0; if (state.orders && state.orders.length > 0) {state.orders.forEach(orderData => {if (orderData.order.isCall) {callCount++}else {putCount++}const strikePrice = parseFloat(formatUnits(orderData.order.strikes[0],PRICE_DECIMALS)); minStrike = Math.min(minStrike,strikePrice); maxStrike = Math.max(maxStrike,strikePrice)})}const currentPrice = state.market_prices[state.selectedAsset] || 0; const totalRange = maxStrike - minStrike; let currentPricePercent = 50; if (totalRange > 0 && currentPrice > 0) {currentPricePercent = Math.min(100,Math.max(0,((currentPrice - minStrike) / totalRange) * 100))}const YELLOW_ZONE_WIDTH = 10; const leftYellow = Math.max(0,currentPricePercent - YELLOW_ZONE_WIDTH/2); const rightYellow = Math.min(100,currentPricePercent + YELLOW_ZONE_WIDTH/2); const backgroundStyle = `linear-gradient(to right,var(--negative) 0%,var(--negative) ${leftYellow}%,yellow ${currentPricePercent}%,var(--positive) ${rightYellow}%,var(--positive) 100%)`; $('#conviction-slider,#adv-conviction-slider').css('background',backgroundStyle); if (rawLeverage) {$('#adjusted-leverage-value').text(rawLeverage)}if (orderData) {const order = orderData.order; if (!order) {console.error("Order object missing in orderData for updateTradeDetails"); $('#trade-now-btn,#adv-trade-btn').prop('disabled',true).text('Error Loading Order'); return}if (isOrderExpired(order.orderExpiryTimestamp)) {const orderKey = `${orderData.nonce}-expired`; if (!loggedExpiredOrders.has(orderKey)) {console.log(`Order ${orderData.nonce}quote expired. Disabling trade button.`); loggedExpiredOrders.add(orderKey)}$('#trade-now-btn,#adv-trade-btn').prop('disabled',true).text('MM Quote Expired'); updateUI('#fill-capacity','Quote expired'); updateUI('#available-capacity','-'); $('#fill-progress').css('width','0%'); $('#capacity-warning').hide()}else {getOrderFillInfo(orderData).then(fillInfo => {if (fillInfo) {updateUI('#fill-capacity',`${fillInfo.fillPercentage}% filled (${parseFloat(fillInfo.amountFilled).toFixed(6)}/${parseFloat(fillInfo.maxCollateralUsable).toFixed(6)}${fillInfo.collateralSymbol})`); updateUI('#available-capacity',`${parseFloat(fillInfo.remainingCapacity).toFixed(6)}${fillInfo.collateralSymbol}available`); $('#fill-progress').css('width',`${fillInfo.fillPercentage}%`); if (parseFloat(fillInfo.fillPercentage) > 80) {$('#capacity-warning').show()}else {$('#capacity-warning').hide()}if (fillInfo.isFull) {$('#trade-now-btn,#adv-trade-btn').prop('disabled',true).text('ORDER CAPACITY FULL')}else {$('#trade-now-btn,#adv-trade-btn').prop('disabled',false).text('TRADE NOW')}}else {updateUI('#fill-capacity','Unable to fetch capacity data'); updateUI('#available-capacity','Try refreshing the page'); $('#fill-progress').css('width','0%'); $('#capacity-warning').hide(); $('#trade-now-btn,#adv-trade-btn').prop('disabled',true).text('Error Checking Capacity')}}).catch(error => {console.error("Error in fill info promise:",error); updateUI('#fill-capacity','Error fetching capacity data'); updateUI('#available-capacity','Try refreshing the page'); $('#fill-progress').css('width','0%'); $('#capacity-warning').hide(); $('#trade-now-btn,#adv-trade-btn').prop('disabled',true).text('Error Checking Capacity')})}}}async function getOrderFillInfo(order) {try {if (!order || !order.order || !order.nonce) {console.warn("Missing order or nonce in getOrderFillInfo"); return null}if (!ethereumClient.getAccount().isConnected) {console.warn("Wallet not connected in getOrderFillInfo"); return null}const collateralAddress = order.order.collateral; const collateralDetails = CONFIG.getCollateralDetails(collateralAddress); const collateralSymbol = collateralDetails ? collateralDetails.name : 'UNKNOWN'; const collateralDecimals = collateralDetails ? collateralDetails.decimals : 18; const {readContract }= WagmiCore; const nonce = ethers.BigNumber.from(order.nonce); const amountFilled = await readContract({address: OPTION_BOOK_ADDRESS,abi: OPTION_BOOK_ABI,functionName: 'amountFilled',args: [nonce.toString()],chainId: 8453 }); const amountFilledBN = ethers.BigNumber.from(amountFilled.toString()); const maxCollateralUsable = ethers.BigNumber.from(order.order.maxCollateralUsable); const remainingCapacity = maxCollateralUsable.sub(amountFilledBN); const fillPercentage = maxCollateralUsable.gt(0) ? (parseFloat(amountFilledBN.mul(10000).div(maxCollateralUsable).toString()) / 100).toFixed(2) : "0"; return {amountFilled: formatUnits(amountFilledBN,collateralDecimals),maxCollateralUsable: formatUnits(maxCollateralUsable,collateralDecimals),remainingCapacity: formatUnits(remainingCapacity,collateralDecimals),fillPercentage: fillPercentage,isFull: remainingCapacity.lte(0),collateralSymbol: collateralSymbol }}catch (error) {console.error("Error fetching order fill info:",error); console.error("Error details:",{orderCollateral: order?.order?.collateral,isConnected: ethereumClient.getAccount().isConnected,contractAddress: OPTION_BOOK_ADDRESS }); return null}}async function settleOption(event) {const button = event.target; const positionId = $(button).data("positionId"); const positionType = $(button).data("positionType"); button.disabled = true; button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Settling...'; try {const position = state.userPositions.openPositions.find(p => p.entryTxHash === positionId); if (!position) {throw new Error('Position not found')}console.log(position); const {writeContract,waitForTransaction }= WagmiCore; const tx = await writeContract({address: position.address,abi: OPTION_ABI,functionName: 'payout',args: [],chainId: 8453 }); button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Transaction pending...'; await waitForTransaction({hash: tx.hash }); button.className = 'btn btn-success'; button.innerHTML = '<i class="bi bi-check-circle"></i> Option Settled'; const localPositionIndex = state.userPositions.openPositions.findIndex(p => p.entryTxHash === positionId); if (localPositionIndex > -1) {state.userPositions.openPositions[localPositionIndex].settled = true; state.userPositions.openPositions[localPositionIndex].status = 'settled'; if ($('#position-details-modal').is(':visible')) {updateSettlementInfo(state.userPositions.openPositions[localPositionIndex])}}await refreshPositions(); $('#positions-container').prepend(` <div class="alert alert-success alert-dismissible fade show" role="alert"> Option settled successfully! <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button> </div> `); await fetch('https: }catch (error) {console.error('Error settling option:',error); button.disabled = false; button.innerHTML = 'Settle Option'; $('#positions-container').prepend(` <div class="alert alert-danger alert-dismissible fade show" role="alert"> Failed to settle option: ${error.message}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button> </div> `)}}async function updateETHBalance() {try {if (!state.connectedAddress) {$('#eth-balance-display').text('--'); $('#eth-balance-display-main').text('--'); $('#eth-usd-value').text('($--)'); return}const balance = await WagmiCore.getETHBalance(state.connectedAddress); const ethBalance = parseFloat(ethers.utils.formatEther(balance)); $('#eth-balance-display').text(ethBalance.toFixed(4)); $('#eth-balance-display-main').text(ethBalance.toFixed(4)); if (state.market_prices && state.market_prices['ETH']) {const usdValue = (ethBalance * state.market_prices['ETH']).toFixed(2); $('#eth-usd-value').text(`($${usdValue})`)}else {$('#eth-usd-value').text('($--)')}const selectedPayment = getSelectedPaymentAsset(); if (selectedPayment === 'WETH' && ethBalance > 0.00001) {$('#eth-wrap-section').slideDown()}else if (selectedPayment !== 'WETH') {$('#eth-wrap-section').slideUp()}}catch (error) {console.error('Error updating ETH balance:',error); $('#eth-balance-display').text('Error'); $('#eth-balance-display-main').text('Error'); $('#eth-usd-value').text('($--)')}}async function wrapETH() {const wrapButton = $('#wrap-eth-btn'); const statusDiv = $('#wrap-status'); const amountInput = $('#eth-wrap-amount'); try {const ethAmount = parseFloat(amountInput.val()); if (!ethAmount || ethAmount <= 0) {throw new Error('Please enter a valid ETH amount')}const ethBalance = await WagmiCore.getETHBalance(state.connectedAddress); const ethBalanceFormatted = parseFloat(ethers.utils.formatEther(ethBalance)); if (ethAmount > ethBalanceFormatted - 0.001) {throw new Error(`Insufficient ETH balance. You have ${ethBalanceFormatted.toFixed(4)}ETH,but need to keep some for gas fees.`)}wrapButton.prop('disabled',true); wrapButton.html('<span class="spinner-border spinner-border-sm"></span> Wrapping...'); statusDiv.removeClass('alert-danger alert-success').addClass('alert-info'); statusDiv.text('Wrapping ETH to WETH...').show(); const tx = await WagmiCore.wrapETH(ethAmount); statusDiv.text(`Transaction sent! Hash: ${tx.hash.substring(0,10)}...`); await tx.wait(1); statusDiv.removeClass('alert-info').addClass('alert-success'); statusDiv.text(`Successfully wrapped ${ethAmount}ETH to WETH!`); wrapButton.html('<i class="bi bi-check-circle"></i> Wrapped!'); amountInput.val(''); await updateETHBalance(); await updateWalletBalance(); setTimeout(() => {wrapButton.prop('disabled',false); wrapButton.html('<i class="bi bi-arrow-repeat"></i> Wrap ETH'); statusDiv.hide()},3000)}catch (error) {console.error('Error wrapping ETH:',error); statusDiv.removeClass('alert-info alert-success').addClass('alert-danger'); statusDiv.text(`Error: ${error.message}`).show(); wrapButton.prop('disabled',false); wrapButton.html('<i class="bi bi-arrow-repeat"></i> Wrap ETH'); setTimeout(() => {statusDiv.hide()},5000)}}function setupWrapETHListeners() {$('#wrap-eth-btn').on('click',wrapETH); $(document).on('click','[data-eth-amount]',function() {const amount = $(this).data('eth-amount'); $('#eth-wrap-amount').val(amount)})}async function selectBestPaymentAsset(order,requiredAmountUSD) {if (!state.connectedAddress) {return null}try {const requiredCollateral = CONFIG.getCollateralDetails(order.collateral); const preferredAsset = requiredCollateral.name; const availableAssets = ['USDC','CBBTC','WETH']; const balanceResults = await Promise.allSettled( availableAssets.map(async (asset) => {try {const balance = await kyberSwap.getUserBalance(asset); const dollarValue = convertToDollarValue(balance,asset); return {symbol: asset,balance: parseFloat(balance) || 0,dollarValue: dollarValue || 0,isSufficient: (dollarValue || 0) >= requiredAmountUSD }}catch (error) {console.warn(`Failed to get balance for ${asset}:`,error); return {symbol: asset,balance: 0,dollarValue: 0,isSufficient: false }}}) ); const assetBalances = balanceResults.map((result,index) => {if (result.status === 'fulfilled') {return result.value}else {console.warn(`Failed to get balance for ${availableAssets[index]}:`,result.reason); return {symbol: availableAssets[index],balance: 0,dollarValue: 0,isSufficient: false }}}); let wethData = assetBalances.find(a => a.symbol === 'WETH'); if (wethData && preferredAsset === 'WETH') {try {const ethBalance = await getETHBalance(); const ethDollarValue = convertToDollarValue(ethBalance,'ETH'); const combinedValue = wethData.dollarValue + ethDollarValue; wethData.combinedValue = combinedValue; wethData.ethBalance = ethBalance; wethData.isSufficientWithETH = combinedValue >= requiredAmountUSD}catch (error) {console.error("Error getting ETH balance:",error)}}let selectedAsset = null; if (preferredAsset === 'WETH' && wethData) {if (wethData.isSufficient) {selectedAsset = 'WETH'}else if (wethData.isSufficientWithETH) {selectedAsset = 'WETH'; if (wethData.balance * (state.market_prices['ETH'] || 2500) < requiredAmountUSD) {showETHWrappingInterface()}}}if (!selectedAsset && preferredAsset !== 'WETH') {const preferredAssetData = assetBalances.find(a => a.symbol === preferredAsset); if (preferredAssetData && preferredAssetData.isSufficient) {selectedAsset = preferredAsset}}if (!selectedAsset) {const sufficientAssets = assetBalances .filter(asset => asset.isSufficient) .sort((a,b) => b.dollarValue - a.dollarValue); if (sufficientAssets.length > 0) {selectedAsset = sufficientAssets[0].symbol}else {const highestValueAsset = assetBalances .filter(asset => asset.dollarValue > 0) .sort((a,b) => b.dollarValue - a.dollarValue)[0]; if (highestValueAsset) {selectedAsset = highestValueAsset.symbol}else {selectedAsset = preferredAsset}}}if (selectedAsset) {$(`input[name="payment-asset-selection"][value="${selectedAsset}"]`).prop('checked',true); updatePaymentAssetBalanceDisplay(selectedAsset); updatePaymentAsset()}return selectedAsset}catch (error) {console.error("Error in smart asset selection:",error); try {const requiredCollateral = CONFIG.getCollateralDetails(order.collateral); $(`input[name="payment-asset-selection"][value="${requiredCollateral.name}"]`).prop('checked',true); updatePaymentAssetBalanceDisplay(requiredCollateral.name); return requiredCollateral.name}catch (fallbackError) {console.error("Error in fallback asset selection:",fallbackError); return null}}}function convertToDollarValue(balance,assetSymbol) {if (!balance || balance === 0) return 0; const numericBalance = parseFloat(balance); if (isNaN(numericBalance)) return 0; switch (assetSymbol) {case 'USDC': case 'USD': return numericBalance; case 'WETH': case 'ETH': return numericBalance * (state.market_prices['ETH'] || 2500); case 'CBBTC': case 'BTC': return numericBalance * (state.market_prices['BTC'] || 50000); default: console.warn(`Unknown asset symbol: ${assetSymbol}`); return 0}}async function getETHBalance() {if (!state.connectedAddress) return 0; try {const balance = await WagmiCore.getETHBalance(state.connectedAddress); return parseFloat(ethers.utils.formatEther(balance))}catch (error) {console.error("Error getting ETH balance:",error); return 0}}function showETHWrappingInterface() {const ethWrapSection = document.getElementById('eth-wrap-section'); if (ethWrapSection) {ethWrapSection.style.display = 'block'}}function toggleEthWrapSection() {const ethWrapContent = document.getElementById('eth-wrap-content'); const toggleBtn = document.getElementById('toggle-eth-wrap-section'); if (!ethWrapContent || !toggleBtn) return; const isCurrentlyVisible = ethWrapContent.style.display !== 'none'; const newCollapsedState = isCurrentlyVisible; if (newCollapsedState) {ethWrapContent.style.display = 'none'; toggleBtn.innerHTML = '<i class="bi bi-chevron-down"></i>'; toggleBtn.setAttribute('title','Show ETH Wrapping')}else {ethWrapContent.style.display = ''; toggleBtn.innerHTML = '<i class="bi bi-chevron-up"></i>'; toggleBtn.setAttribute('title','Hide ETH Wrapping')}if (window.uiStateManager) {window.uiStateManager.saveState('eth_wrap_collapsed',newCollapsedState)}}async function checkSufficientFunds() {if (state.selectedOrderIndex === null || !state.selectedPositionSize) {return {sufficient: true,reason: null }}const orderData = state.orders[state.selectedOrderIndex]; const order = orderData.order; const requiredCollateral = CONFIG.getCollateralDetails(order.collateral); const selectedPaymentAsset = getSelectedPaymentAsset(); const tradeCostInCollateral = state.selectedPositionSize; if (!selectedPaymentAsset || selectedPaymentAsset === 'init') {return {sufficient: true,reason: null }}try {const needsSwap = selectedPaymentAsset !== requiredCollateral.name; if (!needsSwap) {const balance = await kyberSwap.getUserBalance(selectedPaymentAsset); const balanceNum = parseFloat(balance) || 0; if (balanceNum >= tradeCostInCollateral) {return {sufficient: true,reason: null }}else {const deficit = tradeCostInCollateral - balanceNum; return {sufficient: false,reason: `Insufficient ${selectedPaymentAsset}. Need ${deficit.toFixed(requiredCollateral.decimals === 6 ? 2 : 4)}more ${selectedPaymentAsset}`,balanceInfo: {balance: balanceNum,required: tradeCostInCollateral,asset: selectedPaymentAsset }}}}else {const paymentBalance = await kyberSwap.getUserBalance(selectedPaymentAsset); const paymentBalanceNum = parseFloat(paymentBalance) || 0; if (paymentBalanceNum === 0) {return {sufficient: false,reason: `No ${selectedPaymentAsset}balance available for swap`,balanceInfo: {balance: 0,required: 'N/A',asset: selectedPaymentAsset }}}const requiredUSD = convertToDollarValue(tradeCostInCollateral,requiredCollateral.asset); const paymentUSDValue = convertToDollarValue(paymentBalanceNum,selectedPaymentAsset); const requiredUSDWithBuffer = requiredUSD * 1.05; if (paymentUSDValue >= requiredUSDWithBuffer) {return {sufficient: true,reason: null }}else {const deficitUSD = requiredUSDWithBuffer - paymentUSDValue; const deficitInPaymentAsset = deficitUSD / convertToDollarValue(1,selectedPaymentAsset); return {sufficient: false,reason: `Insufficient ${selectedPaymentAsset}for swap. Need ~${deficitInPaymentAsset.toFixed(selectedPaymentAsset === 'USDC' ? 2 : 4)}more ${selectedPaymentAsset}`,balanceInfo: {balance: paymentBalanceNum,required: `~${(requiredUSDWithBuffer / convertToDollarValue(1,selectedPaymentAsset)).toFixed(selectedPaymentAsset === 'USDC' ? 2 : 4)}`,asset: selectedPaymentAsset }}}}}catch (error) {console.error("Error checking sufficient funds:",error); return {sufficient: true,reason: "Error checking balance - will verify on transaction" }}}function toggleButtonReadiness(ready,message = 'TRADE NOW') {const tradeButton = $('#trade-now-btn'); const tradeButtonAdv = $('#adv-trade-btn'); if (ready) {tradeButton.prop('disabled',false) .removeClass('btn-secondary btn-warning') .addClass('btn-primary') .text(message); tradeButtonAdv.prop('disabled',false) .removeClass('btn-secondary btn-warning') .addClass('btn-primary') .text(message)}else {tradeButton.prop('disabled',true) .removeClass('btn-primary') .addClass('btn-secondary') .text(message); tradeButtonAdv.prop('disabled',true) .removeClass('btn-primary') .addClass('btn-secondary') .text(message)}}function showSwapLoadingWarning(reason = 'Calculating optimal swap route and pricing. This usually takes a few seconds.') {let warningDiv = $('#swap-loading-warning'); if (warningDiv.length === 0) {warningDiv = $(` <div id="swap-loading-warning" class="alert alert-info mt-3" role="alert"> <i class="bi bi-clock-fill me-2"></i> <span id="swap-loading-message">Preparing swap data...</span> <div class="mt-2 small" id="swap-loading-details"></div> </div> `); $('#trade-now-btn').parent().after(warningDiv)}$('#swap-loading-message').text('Preparing swap data...'); $('#swap-loading-details').text(reason); warningDiv.show()}function hideSwapLoadingWarning() {$('#swap-loading-warning').hide()}async function updateTradeButtonState() {if (!state || state.selectedOrderIndex === null || !state.orders || state.orders.length === 0) {return}const fundCheck = await checkSufficientFunds(); if (fundCheck.sufficient) {const approvalNeeded = await checkApprovalNeeded(); if (approvalNeeded) {$('#approve-single-btn-main,#approve-max-btn-main').show(); $('#approve-single-btn-main').text('Approve Single Trade').prop('disabled',false); $('#approve-max-btn-main').text('Approve Max').prop('disabled',false); $('#trade-now-btn').prop('disabled',true).attr('data-approval-required','true')}else {$('#approve-single-btn-main,#approve-max-btn-main').hide(); $('#trade-now-btn').prop('disabled',false).removeAttr('data-approval-required'); toggleButtonReadiness(true,'TRADE NOW')}$('#insufficient-funds-warning').hide()}else {toggleButtonReadiness(false,'INSUFFICIENT FUNDS'); $('#approve-single-btn-main,#approve-max-btn-main').hide(); let warningDiv = $('#insufficient-funds-warning'); if (warningDiv.length === 0) {warningDiv = $(` <div id="insufficient-funds-warning" class="alert alert-warning mt-3" role="alert"> <i class="bi bi-exclamation-triangle-fill me-2"></i> <span id="insufficient-funds-message">Insufficient funds</span> <div class="mt-2 small" id="balance-details"></div> </div> `); $('#trade-now-btn').parent().after(warningDiv)}$('#insufficient-funds-message').text(fundCheck.reason); if (fundCheck.balanceInfo) {const balanceDetails = ` Your balance: ${fundCheck.balanceInfo.balance.toFixed(fundCheck.balanceInfo.asset === 'USDC' ? 2 : 4)}${fundCheck.balanceInfo.asset}<br> Required: ${fundCheck.balanceInfo.required}${fundCheck.balanceInfo.asset}`; $('#balance-details').html(balanceDetails)}warningDiv.show()}}let refreshFundStatusTimer = null; async function refreshFundStatus() {if (refreshFundStatusTimer) {clearTimeout(refreshFundStatusTimer)}refreshFundStatusTimer = setTimeout(async () => {try {if (!state.connectedAddress) {return}if (state.selectedOrderIndex === null) {return}await updateTradeButtonState()}catch (error) {console.error("Error in debounced refreshFundStatus:",error)}finally {refreshFundStatusTimer = null}},100)}function populateSwapDropdowns() {const fromAssetSelect = $('#swap-from-asset'); const toAssetSelect = $('#swap-to-asset'); fromAssetSelect.empty(); toAssetSelect.empty(); const availableTokens = Object.keys(CONFIG.collateralMap); availableTokens.forEach(token => {fromAssetSelect.append(`<option value="${token}">${token}</option>`)}); availableTokens.forEach(token => {toAssetSelect.append(`<option value="${token}">${token}</option>`)}); fromAssetSelect.val('ETH'); toAssetSelect.val('USDC')}function initializeMainApproveButton() {const approveBtn = $('#approve-max-btn-main'); if (approveBtn.length === 0) {console.error('Main approve button not found in DOM'); return}approveBtn.prop('disabled',false); approveBtn.hide(); console.log('Main approve button initialized:',{exists: approveBtn.length > 0,visible: approveBtn.is(':visible'),disabled: approveBtn.prop('disabled'),text: approveBtn.text() })}function initializeApproveButton() {const approveBtn = $('#approve-swap-btn'); if (approveBtn.length === 0) {console.error('Approve button not found in DOM'); return}approveBtn.prop('disabled',false); approveBtn.removeClass('d-none'); approveBtn.hide(); console.log('Approve button initialized:',{exists: approveBtn.length > 0,visible: approveBtn.is(':visible'),disabled: approveBtn.prop('disabled'),text: approveBtn.text() })}function openSwapModal() {if ($('#swap-from-asset option').length === 0) {populateSwapDropdowns()}initializeApproveButton(); const currentPaymentAsset = getSelectedPaymentAsset(); console.log('Current payment asset:',currentPaymentAsset); console.log('Available payment assets:',$('input[name="payment-asset-selection"]:checked').length); $('#swap-from-asset').val('ETH'); const toAsset = currentPaymentAsset || 'USDC'; console.log('Setting to asset to:',toAsset); $('#swap-to-asset').val(toAsset); $('#swap-from-amount').val(''); $('#swap-to-amount').val(''); $('#swap-rate').text('--'); $('#swap-rate-info').hide(); $('#execute-swap-btn').prop('disabled',true); updateSwapFromBalance(); if (typeof updateWalletBalance === 'function') {updateWalletBalance()}if (typeof updateLiquidityInfo === 'function') {updateLiquidityInfo()}setTimeout(async () => {updateSwapFromBalance(); try {await checkSwapApprovalNeeded()}catch (error) {console.error('Error checking approval status on modal open:',error)}},1000); const swapModal = new bootstrap.Modal(document.getElementById('swapModal')); swapModal.show(); $('#swap-from-amount').off('input.checkApproval').on('input.checkApproval',async function() {const amount = $(this).val(); if (amount && parseFloat(amount) > 0) {console.log('Amount changed,checking approval immediately'); try {await checkSwapApprovalNeeded()}catch (error) {console.error('Error checking approval on amount change:',error)}}}); $('#swap-from-asset').off('change.checkApproval').on('change.checkApproval',async function() {console.log('Asset changed,checking approval'); try {await checkSwapApprovalNeeded()}catch (error) {console.error('Error checking approval on asset change:',error)}})}function updateSwapFromBalance() {const fromAsset = $('#swap-from-asset').val(); if (!fromAsset) {$('#swap-from-balance').text('--'); $('#swap-from-kyber-allowance').text('--'); return}if (fromAsset === 'ETH') {const ethBalanceElement = $('#eth-balance-display-main'); if (ethBalanceElement.length > 0) {const ethBalance = ethBalanceElement.text(); $('#swap-from-balance').text(ethBalance)}else {if (typeof updateETHBalance === 'function') {updateETHBalance()}$('#swap-from-balance').text('Loading...')}$('#swap-from-kyber-allowance').text('N/A (Native)')}else {if (state.paymentAssetBalances && state.paymentAssetBalances[fromAsset]) {$('#swap-from-balance').text(state.paymentAssetBalances[fromAsset])}else {$('#swap-from-balance').text('--')}if (state.userKyberAllowances && state.userKyberAllowances[fromAsset]) {$('#swap-from-kyber-allowance').text(state.userKyberAllowances[fromAsset])}else {const kyberElement = document.getElementById(`${fromAsset.toLowerCase()}-kyber-liquidity`); if (kyberElement && kyberElement.textContent !== '--') {$('#swap-from-kyber-allowance').text(kyberElement.textContent)}else {$('#swap-from-kyber-allowance').text('--')}}}}async function updateSwapCalculations() {const fromAsset = $('#swap-from-asset').val(); const toAsset = $('#swap-to-asset').val(); const fromAmount = $('#swap-from-amount').val(); if (typeof CONFIG === 'undefined') {$('#swap-to-amount').val(''); $('#swap-rate').text('Config Error'); $('#swap-rate-info').hide(); $('#execute-swap-btn').prop('disabled',true); return}if (!CONFIG.collateralMap.ETH) {CONFIG.collateralMap.ETH = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'}$('#swap-to-amount').val(''); $('#swap-rate').text('--'); $('#swap-rate-info').hide(); $('#execute-swap-btn').prop('disabled',true); if (!fromAmount || parseFloat(fromAmount) <= 0) {return}const amountFloat = parseFloat(fromAmount); if (amountFloat < 0.000001) {$('#swap-to-amount').val('Amount too small'); $('#swap-rate').text('Min: 0.000001'); return}$('#swap-to-amount').val('Calculating...'); $('#swap-rate').text('Loading...'); try {const isETHWETHSwap = (fromAsset === 'ETH' && toAsset === 'WETH') || (fromAsset === 'WETH' && toAsset === 'ETH'); if (isETHWETHSwap) {$('#swap-to-amount').val(fromAmount); $('#swap-rate').text(`1 ${fromAsset}= 1 ${toAsset}`); $('#swap-rate-display').text(`1 ${fromAsset}= 1 ${toAsset}`); $('#swap-rate-info').show(); $('#execute-swap-btn').prop('disabled',false); return}const fromTokenAddress = CONFIG.collateralMap[fromAsset]; const toTokenAddress = CONFIG.collateralMap[toAsset]; if (!fromTokenAddress || !toTokenAddress) {throw new Error(`Invalid token addresses: ${fromAsset}(${fromTokenAddress}),${toAsset}(${toTokenAddress})`)}const fromTokenDecimals = CONFIG.getCollateralDetails(fromTokenAddress).decimals; const amountInRaw = ethers.utils.parseUnits(fromAmount,fromTokenDecimals).toString(); if (BigInt(amountInRaw) <= 0n) {throw new Error(`Invalid raw amount: ${amountInRaw}`)}const quote = await kyberSwap.getQuote(fromAsset,toAsset,amountInRaw); if (quote && quote.outputAmount) {console.log('encodedSwapData:',quote.encodedSwapData); const toTokenAddress = CONFIG.collateralMap[toAsset]; const toTokenDecimals = CONFIG.getCollateralDetails(toTokenAddress).decimals; console.log('To Token Decimals:',toTokenDecimals); const outputAmount = ethers.utils.formatUnits(quote.outputAmount,toTokenDecimals); console.log('Formatted Output Amount:',outputAmount); $('#swap-to-amount').val(parseFloat(outputAmount).toFixed(toTokenDecimals)); const rate = parseFloat(outputAmount) / parseFloat(fromAmount); let formattedRate; if (rate < 0.01) formattedRate = rate.toFixed(6); else if (rate < 1) formattedRate = rate.toFixed(4); else formattedRate = rate.toFixed(2); $('#swap-rate').text(`1 ${fromAsset}= ${formattedRate}${toAsset}`); $('#swap-rate-display').text(`1 ${fromAsset}= ${formattedRate}${toAsset}`); $('#swap-rate-info').show(); $('#execute-swap-btn').prop('disabled',false); checkSwapApprovalNeeded().catch(error => {console.error('Error checking approval status:',error)})}else {throw new Error('Invalid quote response')}}catch (error) {console.error('Error calculating swap:',error); $('#swap-to-amount').val(''); $('#swap-rate').text('Error'); $('#swap-rate-info').hide(); $('#execute-swap-btn').prop('disabled',true); if (error.message.includes('Kyber API error') || error.message.includes('bad request')) {$('#swap-rate').text('API Error')}else if (error.message.includes('Invalid token addresses')) {$('#swap-rate').text('Configuration error')}else if (error.message.includes('Invalid raw amount')) {$('#swap-rate').text('Amount format error')}else {$('#swap-rate').text('Calculation failed')}}}async function executeSwap() {const fromAsset = $('#swap-from-asset').val(); const toAsset = $('#swap-to-asset').val(); const fromAmount = $('#swap-from-amount').val(); if (!fromAmount || parseFloat(fromAmount) <= 0) {showNotification('Please enter a valid amount','error'); return}if (!state.connectedAddress) {showNotification('Please connect your wallet first','error'); return}const executeBtn = $('#execute-swap-btn'); const originalText = executeBtn.html(); executeBtn.prop('disabled',true).html('<span class="spinner-border spinner-border-sm me-2" role="status"></span>Executing...'); try {const isETHWETHSwap = (fromAsset === 'ETH' && toAsset === 'WETH') || (fromAsset === 'WETH' && toAsset === 'ETH'); if (isETHWETHSwap) {let result; if (fromAsset === 'ETH' && toAsset === 'WETH') {result = await WagmiCore.wrapETH(fromAmount); showNotification(`ETH wrapping transaction submitted successfully!\n\nTransaction Hash: ${result.hash.substring(0,10)}...\n\n${fromAmount}ETH  ${fromAmount}WETH`,'success',result.hash)}else {result = await WagmiCore.unwrapWETH(fromAmount); showNotification(`WETH unwrapping transaction submitted successfully!\n\nTransaction Hash: ${result.hash.substring(0,10)}...\n\n${fromAmount}WETH  ${fromAmount}ETH`,'success',result.hash)}executeBtn.html('<span class="spinner-border spinner-border-sm me-2" role="status"></span>Waiting for confirmation...'); try {await WagmiCore.waitForTransaction({hash: result.hash }); showNotification(`Transaction confirmed! ${fromAmount}${fromAsset} ${fromAmount}${toAsset}`,'success',result.hash)}catch (error) {console.error('Error waiting for transaction confirmation:',error); showNotification(`Transaction submitted but confirmation failed: ${error.message}`,'warning')}const swapModal = bootstrap.Modal.getInstance(document.getElementById('swapModal')); if (swapModal) {swapModal.hide()}await updateSwapFromBalance(); if (typeof updatePaymentAssetBalanceDisplay === 'function') {updatePaymentAssetBalanceDisplay(getSelectedPaymentAsset())}if (typeof updateWalletBalance === 'function') {await updateWalletBalance()}$('#swap-from-amount').val(''); $('#swap-to-amount').val(''); $('#swap-rate').text('--'); $('#swap-rate-info').hide(); executeBtn.prop('disabled',false).html(originalText); return}const fromTokenAddress = CONFIG.collateralMap[fromAsset]; const fromTokenDecimals = CONFIG.getCollateralDetails(fromTokenAddress).decimals; const amountInRaw = ethers.utils.parseUnits(fromAmount,fromTokenDecimals).toString(); const quote = await kyberSwap.getQuote(fromAsset,toAsset,amountInRaw); if (!quote || !quote.encodedSwapData) {throw new Error('No swap data available. Please calculate the swap rate first.')}const bridge = window.Web3OnboardBridge; if (!bridge || !bridge.getSigner) {throw new Error('Web3Onboard bridge not available')}const signer = bridge.getSigner(); const provider = bridge.getProvider(); const transaction = {to: CONFIG.KYBER_CONTRACT_ADDRESS,data: quote.encodedSwapData,value: fromAsset === 'ETH' ? amountInRaw : 0,chainId: 8453 }; const result = await signer.sendTransaction(transaction); const successMessage = `Swap transaction submitted successfully!\n\nTransaction Hash: ${result.hash.substring(0,10)}...\n\n${fromAmount}${fromAsset} ${$('#swap-to-amount').val()}${toAsset}`; showNotification(successMessage,'success',result.hash); executeBtn.html('<span class="spinner-border spinner-border-sm me-2" role="status"></span>Waiting for confirmation...'); try {await WagmiCore.waitForTransaction({hash: result.hash }); showNotification(`Transaction confirmed! ${fromAmount}${fromAsset} ${$('#swap-to-amount').val()}${toAsset}`,'success',result.hash)}catch (error) {console.error('Error waiting for transaction confirmation:',error); showNotification(`Transaction submitted but confirmation failed: ${error.message}`,'warning')}const swapModal = bootstrap.Modal.getInstance(document.getElementById('swapModal')); if (swapModal) {swapModal.hide()}await updateSwapFromBalance(); if (typeof updatePaymentAssetBalanceDisplay === 'function') {updatePaymentAssetBalanceDisplay(getSelectedPaymentAsset())}if (typeof updateWalletBalance === 'function') {await updateWalletBalance()}$('#swap-from-amount').val(''); $('#swap-to-amount').val(''); $('#swap-rate').text('--'); $('#swap-rate-info').hide(); executeBtn.prop('disabled',false).html(originalText)}catch (error) {console.error('Error executing swap:',error); showNotification(`Swap failed: ${error.message}`,'error'); executeBtn.prop('disabled',false).html(originalText)}}window.updatePaymentAssetBalanceDisplay = function(selectedAsset) {const balanceDisplay = document.getElementById('payment-balance-display'); if (!state.paymentAssetBalances || !selectedAsset) {balanceDisplay.innerHTML = '<span class="balance-text no-balance">No balance data available</span>'; return}const balance = state.paymentAssetBalances[selectedAsset]; if (!balance || balance === '0') {balanceDisplay.innerHTML = `<span class="balance-text no-balance">0.00 ${selectedAsset}</span>`}else {let usdValue = ''; if (state.market_prices && state.market_prices[selectedAsset]) {const price = state.market_prices[selectedAsset]; const usdAmount = (parseFloat(balance) * price).toFixed(2); usdValue = `($${usdAmount})`}balanceDisplay.innerHTML = ` <span class="balance-amount">${balance}${selectedAsset}</span> <span class="balance-usd">${usdValue}</span> `}const swapBtn = document.getElementById('swap-assets-btn'); if (swapBtn) {swapBtn.innerHTML = `<i class="bi bi-arrow-repeat me-1"></i>Get more ${selectedAsset}`}}async function checkSwapApprovalNeeded() {const fromAsset = $('#swap-from-asset').val(); const fromAmount = $('#swap-from-amount').val(); const approveBtn = $('#approve-swap-btn'); const executeBtn = $('#execute-swap-btn'); console.log('checkSwapApprovalNeeded called with:',{fromAsset,fromAmount }); console.log('Button elements found:',{approveBtnExists: approveBtn.length > 0,executeBtnExists: executeBtn.length > 0,approveBtnSelector: '#approve-swap-btn',executeBtnSelector: '#execute-swap-btn' }); if (!fromAsset || !fromAmount || parseFloat(fromAmount) <= 0) {console.log('Invalid input,hiding approve button'); approveBtn.hide(); executeBtn.prop('disabled',true); return}if (fromAsset === 'ETH') {console.log('ETH selected,no approval needed'); approveBtn.hide(); executeBtn.prop('disabled',false); return}const toAsset = $('#swap-to-asset').val(); const isETHWETHSwap = (fromAsset === 'ETH' && toAsset === 'WETH') || (fromAsset === 'WETH' && toAsset === 'ETH'); if (isETHWETHSwap) {console.log('ETH/WETH swap detected,no approval needed'); approveBtn.hide(); executeBtn.prop('disabled',false); return}const now = Date.now(); const isUserInput = fromAmount && parseFloat(fromAmount) > 0; const timeSinceLastCheck = checkSwapApprovalNeeded.lastCheck ? (now - checkSwapApprovalNeeded.lastCheck) : 0; if (checkSwapApprovalNeeded.lastCheck && timeSinceLastCheck < 2000 && !isUserInput) {console.log('Rate limiting: skipping approval check (last check was',Math.round(timeSinceLastCheck / 1000),'seconds ago)'); return}checkSwapApprovalNeeded.lastCheck = now; try {const tokenAddress = CONFIG.collateralMap[fromAsset]; const {readContract }= WagmiCore; console.log('Fetching fresh allowance for:',{fromAsset,tokenAddress,userAddress: state.connectedAddress }); console.log('=== PROVIDER DEBUG INFO ==='); console.log('WagmiCore:',WagmiCore); console.log('Web3OnboardBridge:',window.Web3OnboardBridge); if (window.Web3OnboardBridge) {console.log('Bridge provider:',window.Web3OnboardBridge.getProvider && window.Web3OnboardBridge.getProvider()); console.log('Bridge direct provider:',window.Web3OnboardBridge.getDirectProvider && window.Web3OnboardBridge.getDirectProvider()); console.log('Bridge RPC info:',window.Web3OnboardBridge.getCurrentRpcInfo && window.Web3OnboardBridge.getCurrentRpcInfo())}console.log('=== END PROVIDER DEBUG ==='); const allowanceResult = await readContract({address: tokenAddress,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,CONFIG.KYBER_CONTRACT_ADDRESS],chainId: 8453 }); const tokenDecimals = CONFIG.getCollateralDetails(tokenAddress).decimals; const userAllowance = parseFloat(ethers.utils.formatUnits(allowanceResult,tokenDecimals)); const requiredAmount = parseFloat(fromAmount); console.log('Fresh approval check result:',{fromAsset,fromAmount: requiredAmount,userAllowance,needsApproval: userAllowance < requiredAmount,tokenAddress,userAddress: state.connectedAddress,rawAllowance: allowanceResult.toString() }); if (userAllowance < requiredAmount) {console.log('Showing approve button for',fromAsset); console.log('Button state before show:',{buttonExists: approveBtn.length > 0,buttonVisible: approveBtn.is(':visible'),buttonText: approveBtn.text(),buttonStyle: approveBtn.attr('style'),buttonClasses: approveBtn.attr('class'),buttonDisplay: approveBtn.css('display') }); approveBtn.show(); approveBtn.css('display','inline-block'); approveBtn.removeAttr('style'); executeBtn.prop('disabled',true); approveBtn.text(`Approve ${fromAmount}${fromAsset}`); console.log('Button state after show:',{buttonVisible: approveBtn.is(':visible'),buttonText: approveBtn.text(),buttonStyle: approveBtn.attr('style'),buttonDisplay: approveBtn.css('display') })}else {console.log('Hiding approve button for',fromAsset,'- sufficient allowance'); approveBtn.hide(); executeBtn.prop('disabled',false)}}catch (error) {console.error('Error checking Kyber allowance:',error); if (error.message && error.message.includes('rate limited')) {console.log('Rate limited,will retry later'); return}let userAllowance = 0; if (state.userKyberAllowances && state.userKyberAllowances[fromAsset]) {userAllowance = parseFloat(state.userKyberAllowances[fromAsset])}else {const kyberElement = document.getElementById(`${fromAsset.toLowerCase()}-kyber-liquidity`); if (kyberElement && kyberElement.textContent !== '--') {userAllowance = parseFloat(kyberElement.textContent)}}const requiredAmount = parseFloat(fromAmount); console.log('Fallback approval check:',{fromAsset,userAllowance,requiredAmount,needsApproval: userAllowance < requiredAmount }); if (userAllowance < requiredAmount) {console.log('Fallback: Showing approve button for',fromAsset); approveBtn.show(); executeBtn.prop('disabled',true); approveBtn.text(`Approve ${fromAmount}${fromAsset}`)}else {console.log('Fallback: Hiding approve button for',fromAsset); approveBtn.hide(); executeBtn.prop('disabled',false)}}}async function approveSwapToken() {const fromAsset = $('#swap-from-asset').val(); const fromAmount = $('#swap-from-amount').val(); const approveBtn = $('#approve-swap-btn'); const executeBtn = $('#execute-swap-btn'); if (!fromAsset || !fromAmount || parseFloat(fromAmount) <= 0) {showNotification('Invalid amount for approval','error'); return}if (fromAsset === 'ETH') {showNotification('ETH does not require approval','info'); return}try {approveBtn.prop('disabled',true).html('<span class="spinner-border spinner-border-sm me-2"></span>Approving...'); const tokenAddress = CONFIG.collateralMap[fromAsset]; const amountInRaw = ethers.utils.parseUnits(fromAmount,CONFIG.getCollateralDetails(tokenAddress).decimals); console.log('Approving token:',{fromAsset,fromAmount,amountInRaw: amountInRaw.toString(),tokenAddress }); showNotification(`Approval transaction initiated for ${fromAmount}${fromAsset}`,'info'); const result = await WagmiCore.writeContract({address: tokenAddress,abi: ERC20ABI,functionName: 'approve',args: [CONFIG.KYBER_CONTRACT_ADDRESS,amountInRaw],chainId: 8453 }); console.log('Approval transaction submitted:',result.hash); showNotification(`Waiting for approval confirmation...`,'info'); await WagmiCore.waitForTransaction({hash: result.hash }); showNotification(`Approval confirmed! You can now execute the swap.`,'success',result.hash); console.log('Approval transaction confirmed'); approveBtn.prop('disabled',false).text(`Approve ${fromAmount}${fromAsset}`); await new Promise(resolve => setTimeout(resolve,2000)); console.log('Using targeted Kyber allowance refresh instead of heavy multicall'); await refreshTokenAllowance(tokenAddress,fromAsset,CONFIG.KYBER_CONTRACT_ADDRESS,'Kyber'); try {await checkSwapApprovalNeeded()}catch (error) {console.error('Error checking approval status after confirmation:',error)}if (typeof updateWalletBalance === 'function') {updateWalletBalance()}}catch (error) {console.error('Error approving token:',error); showNotification(`Approval failed: ${error.message}`,'error'); approveBtn.prop('disabled',false).text(`Approve ${fromAmount}${fromAsset}`)}}function showNotification(message,type = 'info',txHash = null) {let container = document.getElementById('simple-notification-container'); if (!container) {container = document.createElement('div'); container.id = 'simple-notification-container'; container.className = 'simple-notification-container'; container.style.cssText = ` position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px; `; document.body.appendChild(container)}const notification = document.createElement('div'); notification.className = `alert alert-${type === 'error' ? 'danger' : type}alert-dismissible fade show mb-2`; notification.style.cssText = ` box-shadow: 0 4px 12px rgba(0,0,0,0.15); border: none; border-radius: 8px; margin-bottom: 10px; animation: slideInRight 0.3s ease-out; `; let icon = ''; switch (type) {case 'success': icon = '<i class="bi bi-check-circle-fill me-2"></i>'; break; case 'error': icon = '<i class="bi bi-x-circle-fill me-2"></i>'; break; case 'warning': icon = '<i class="bi bi-exclamation-triangle-fill me-2"></i>'; break; default: icon = '<i class="bi bi-info-circle-fill me-2"></i>'}let explorerLink = ''; if (txHash) {const basescanUrl = `https: explorerLink = ` <div class="mt-2"> <a href="${basescanUrl}" target="_blank" class="btn btn-sm btn-outline-primary"> <i class="bi bi-box-arrow-up-right me-1"></i>View on Basescan </a> </div> `}notification.innerHTML = ` ${icon}<span>${message}</span> ${explorerLink}<button type="button" class="btn-close" data-bs-dismiss="alert"></button> `; container.appendChild(notification); setTimeout(() => {if (notification.parentNode) {notification.remove()}},5000); const closeBtn = notification.querySelector('.btn-close'); if (closeBtn) {closeBtn.addEventListener('click',() => {notification.remove()})}}if (!document.getElementById('simple-notification-styles')) {const style = document.createElement('style'); style.id = 'simple-notification-styles'; style.textContent = ` @keyframes slideInRight {from {transform: translateX(100%); opacity: 0}to {transform: translateX(0); opacity: 1}}`; document.head.appendChild(style)}async function refreshTokenAllowance(tokenAddress,tokenSymbol,spenderAddress,spenderType = 'OptionBook') {try {console.log(`Refreshing ${spenderType}allowance for ${tokenSymbol}at address ${tokenAddress}`); const {readContract }= WagmiCore; const userAllowance = await readContract({address: tokenAddress,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,spenderAddress],chainId: 8453 }); const tokenDetails = CONFIG.getCollateralDetails(tokenAddress); const formattedAllowance = ethers.utils.formatUnits(userAllowance,tokenDetails.decimals); console.log(`Fresh ${spenderType}allowance for ${tokenSymbol}:`,{rawAmount: userAllowance.toString(),formattedAmount: formattedAllowance,decimals: tokenDetails.decimals }); if (spenderType === 'Kyber') {if (!state.userKyberAllowances) {state.userKyberAllowances = {}}state.userKyberAllowances[tokenSymbol] = formattedAllowance; const kyberAllowanceElement = $('#swap-from-kyber-allowance'); if (kyberAllowanceElement.length > 0) {kyberAllowanceElement.text(formattedAllowance)}const liquidityElement = document.getElementById(`${tokenSymbol.toLowerCase()}-kyber-liquidity`); if (liquidityElement) {liquidityElement.textContent = formattedAllowance}}else {if (!state.userOptionBookAllowances) {state.userOptionBookAllowances = {}}state.userOptionBookAllowances[tokenSymbol] = formattedAllowance; const selectedPaymentAsset = getSelectedPaymentAsset(); if (selectedPaymentAsset === tokenSymbol) {const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (allowanceDisplay) {allowanceDisplay.textContent = formattedAllowance}}const liquidityElement = document.getElementById(`${tokenSymbol.toLowerCase()}-liquidity`); if (liquidityElement) {liquidityElement.textContent = formattedAllowance}}console.log(`Successfully refreshed ${spenderType}allowance for ${tokenSymbol}: ${formattedAllowance}`)}catch (error) {console.error(`Error refreshing ${spenderType}allowance for ${tokenSymbol}:`,error)}}const KYBER_API_BASE = "https: const CHAIN_ID = 8453; const DEFAULT_SLIPPAGE = 20; const DEFAULT_GAS_PRICE = 1000000000; function debounce(func,wait) {let timeout; return function(...args) {const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context,args),wait)}}const kyberSwap = {isSwapNeeded: function(selectedCollateral,order) {const orderCollateral = CONFIG.getCollateralDetails(order.collateral).name; return selectedCollateral !== orderCollateral},getTokenAddress: function(symbol) {return CONFIG.collateralMap[symbol]},getUserBalance: async function(tokenSymbol) {if (!state.connectedAddress) return "0"; try {if (tokenSymbol == "init") {return "0"}const tokenAddress = this.getTokenAddress(tokenSymbol); try {ethers.utils.getAddress(tokenAddress)}catch (_) {return "0"}try {const net = await WagmiCore.getNetwork(); if (net?.chain?.id !== 8453) return "0"}catch (_) {}const {readContract }= WagmiCore; const balanceResult = await readContract({address: tokenAddress,abi: [{name: 'balanceOf',type: 'function',stateMutability: 'view',inputs: [{name: 'account',type: 'address' }],outputs: [{name: '',type: 'uint256' }] }],functionName: 'balanceOf',args: [state.connectedAddress] }); const decimalsResult = await readContract({address: tokenAddress,abi: [{name: 'decimals',type: 'function',stateMutability: 'view',inputs: [],outputs: [{name: '',type: 'uint8' }] }],functionName: 'decimals' }); return formatUnits(balanceResult.toString(),decimalsResult)}catch (error) {console.warn(`Error fetching token balance for ${tokenSymbol}:`,error?.message || error); return "0"}},getQuote: async function(tokenInSymbol,tokenOutSymbol,amountIn) {try {const tokenIn = this.getTokenAddress(tokenInSymbol); const tokenOut = this.getTokenAddress(tokenOutSymbol); if (!tokenIn || !tokenOut) {throw new Error(`Invalid token addresses: ${tokenInSymbol}(${tokenIn}),${tokenOutSymbol}(${tokenOut})`)}if (!amountIn || BigInt(amountIn) <= 0n) {throw new Error(`Invalid amount: ${amountIn}`)}const to = state.connectedAddress; const url = new URL(KYBER_API_BASE); url.searchParams.append("chainId",CHAIN_ID); url.searchParams.append("tokenIn",tokenIn); url.searchParams.append("tokenOut",tokenOut); url.searchParams.append("amountIn",amountIn); url.searchParams.append("saveGas","0"); url.searchParams.append("slippageTolerance",DEFAULT_SLIPPAGE); url.searchParams.append("gasInclude","1"); url.searchParams.append("gasPrice",DEFAULT_GAS_PRICE); if (to) url.searchParams.append("to",to); const response = await fetch(url.toString()); if (!response.ok) {const errorText = await response.text(); throw new Error(`Kyber API error: ${response.status}${response.statusText}- ${errorText}`)}const data = await response.json(); return data}catch (error) {console.error("Error getting Kyber quote:",error); throw error}},parseUnits: function(amount,decimals) {const str = amount.toString(); const [intPart,fracPart = ''] = str.split('.'); const truncatedFrac = fracPart.slice(0,decimals); const normalized = truncatedFrac ? `${intPart}.${truncatedFrac}` : intPart; return ethers.utils.parseUnits(normalized,decimals).toString()},calculateSwapForTargetAmount: async function(tokenInSymbol,tokenOutSymbol,targetAmount,bpsLimit = 0.0001,iterationLimit = 5) {try {const tokenOutAddress = this.getTokenAddress(tokenOutSymbol); const tokenInAddress = this.getTokenAddress(tokenInSymbol); const {readContract}= WagmiCore; const tokenOutDecimals = await readContract({address: tokenOutAddress,abi: [{name: 'decimals',type: 'function',stateMutability: 'view',inputs: [],outputs: [{type: 'uint8' }] }],functionName: 'decimals' }); const tokenInDecimals = await readContract({address: tokenInAddress,abi: [{name: 'decimals',type: 'function',stateMutability: 'view',inputs: [],outputs: [{type: 'uint8' }] }],functionName: 'decimals' }); const targetAmountRaw = this.parseUnits(targetAmount,tokenOutDecimals); let inputEstimate; if (tokenInSymbol === "USDC" && (tokenOutSymbol === "WETH" || tokenOutSymbol === "CBBTC")) {const assetSymbol = tokenOutSymbol === "WETH" ? "ETH" : "BTC"; inputEstimate = parseFloat(targetAmount) * state.market_prices[assetSymbol]}else if ((tokenInSymbol === "WETH" || tokenInSymbol === "CBBTC") && tokenOutSymbol === "USDC") {const assetSymbol = tokenInSymbol === "WETH" ? "ETH" : "BTC"; inputEstimate = parseFloat(targetAmount) / state.market_prices[assetSymbol]}else {inputEstimate = parseFloat(targetAmount)}let iterations = 0; let bestQuote = null; let currentInputAmount = this.parseUnits(inputEstimate.toString(),tokenInDecimals).toString(); while (iterations < iterationLimit) {iterations++; const quote = await this.getQuote(tokenInSymbol,tokenOutSymbol,currentInputAmount); if (!quote) break; bestQuote = quote; const outputAmount = quote.outputAmount; const outputAmountFloat = parseFloat(formatUnits(outputAmount,tokenOutDecimals)); const targetAmountFloat = parseFloat(targetAmount); const ratio = outputAmountFloat / targetAmountFloat; if (ratio >= (1 - bpsLimit) && ratio < 1) {break}const adjustmentFactor = targetAmountFloat / Math.max(outputAmountFloat,0.0000001); const newInputAmountFloat = parseFloat(formatUnits(currentInputAmount,tokenInDecimals)) * adjustmentFactor; currentInputAmount = this.parseUnits(newInputAmountFloat.toString(),tokenInDecimals).toString(); if (BigInt(currentInputAmount) === 0n) break}return {success: bestQuote !== null,quote: bestQuote,inputAmount: bestQuote ? bestQuote.inputAmount : "0",outputAmount: bestQuote ? bestQuote.outputAmount : "0",inputTokenSymbol: tokenInSymbol,outputTokenSymbol: tokenOutSymbol,inputTokenDecimals: tokenInDecimals,outputTokenDecimals: tokenOutDecimals }}catch (error) {console.error("Error calculating swap for target amount:",error); return {success: false,error: error.message }}},formatSwapInfo: function(swapData) {if (!swapData || !swapData.success) {return {displayText: "Swap calculation failed",isValid: false }}const inputAmount = formatUnits(swapData.inputAmount,swapData.inputTokenDecimals); const outputAmount = formatUnits(swapData.outputAmount,swapData.outputTokenDecimals); return {displayText: `Swap ${inputAmount}${swapData.inputTokenSymbol} ${outputAmount}${swapData.outputTokenSymbol}`,inputAmount,outputAmount,inputSymbol: swapData.inputTokenSymbol,outputSymbol: swapData.outputTokenSymbol,rate: parseFloat(outputAmount) / parseFloat(inputAmount),isValid: true,swapData: swapData.quote }},updateSwapDisplay: function(swapInfo) {let swapInfoEl = document.getElementById('swap-info-container'); if (!swapInfoEl) {swapInfoEl = document.createElement('div'); swapInfoEl.id = 'swap-info-container'; swapInfoEl.className = 'swap-info mt-3 p-2 rounded'; const positionSizeSection = document.querySelector('.position-size-container'); if (positionSizeSection) {positionSizeSection.after(swapInfoEl)}else {const paymentSelection = document.querySelector('.payment-selection'); paymentSelection.after(swapInfoEl)}}if (!swapInfo || !swapInfo.isValid) {swapInfoEl.innerHTML = ` <div class="alert alert-warning mb-0"> <i class="bi bi-exclamation-triangle-fill me-2"></i> <small>Swap calculation unavailable. Please try a different asset.</small> </div> `; if (typeof toggleButtonReadiness === 'function') {toggleButtonReadiness(false,'SWAP ERROR')}return}const rate = swapInfo.rate; let formattedRate; if (rate < 0.01) formattedRate = rate.toFixed(6); else if (rate < 1) formattedRate = rate.toFixed(4); else formattedRate = rate.toFixed(2); swapInfoEl.innerHTML = ` <div class="swap-info-content"> <div class="swap-header d-flex justify-content-between align-items-center"> <span class="swap-title"> <i class="bi bi-arrow-repeat me-2"></i>Token Swap Required </span> <small class="swap-rate text-muted">Rate: 1 ${swapInfo.inputSymbol}= ${formattedRate}${swapInfo.outputSymbol}</small> </div> <div class="swap-details mt-2"> <div class="swap-direction d-flex justify-content-between align-items-center"> <span class="swap-amount">${parseFloat(swapInfo.inputAmount).toFixed(6)}${swapInfo.inputSymbol}</span> <i class="bi bi-arrow-right mx-2"></i> <span class="swap-amount">${parseFloat(swapInfo.outputAmount).toFixed(6)}${swapInfo.outputSymbol}</span> </div> <small class="text-muted mt-1 d-block"> <i class="bi bi-info-circle me-1"></i> Swap will be executed when you confirm the trade </small> </div> </div> `; if (typeof toggleButtonReadiness === 'function') {toggleButtonReadiness(true,'TRADE NOW')}if (typeof hideSwapLoadingWarning === 'function') {hideSwapLoadingWarning()}},hideSwapDisplay: function() {const swapInfoEl = document.getElementById('swap-info-container'); if (swapInfoEl) {swapInfoEl.style.display = 'none'}if (typeof toggleButtonReadiness === 'function') {toggleButtonReadiness(true,'TRADE NOW')}if (typeof hideSwapLoadingWarning === 'function') {hideSwapLoadingWarning()}},updateSwapInfo: debounce(async function(order,positionSize) {const swapInfoEl = document.getElementById('swap-info-container'); if (swapInfoEl) {swapInfoEl.style.display = 'block'}const orderCollateral = CONFIG.getCollateralDetails(order.collateral); const selectedCollateral = getSelectedPaymentAsset(); const needsSwap = selectedCollateral !== orderCollateral.name; if (!needsSwap) {this.hideSwapDisplay(); state.currentSwapInfo = null; return}if (swapInfoEl) {swapInfoEl.innerHTML = ` <div class="d-flex align-items-center"> <div class="spinner-border spinner-border-sm me-2" role="status"> <span class="visually-hidden">Loading...</span> </div> <span>Calculating swap rates...</span> </div> `}if (typeof toggleButtonReadiness === 'function') {toggleButtonReadiness(false,'LOADING SWAP...')}if (typeof showSwapLoadingWarning === 'function') {showSwapLoadingWarning()}try {const swapResult = await this.calculateSwapForTargetAmount( selectedCollateral,orderCollateral.name,positionSize,0.0001,2 ); const swapInfo = this.formatSwapInfo(swapResult); this.updateSwapDisplay(swapInfo); state.currentSwapInfo = {...swapInfo,timestamp: Date.now() }}catch (error) {console.error("Error updating swap info:",error); if (swapInfoEl) {swapInfoEl.innerHTML = ` <div class="alert alert-warning mb-0"> <i class="bi bi-exclamation-triangle-fill me-2"></i> <small>Error calculating swap: ${error.message}</small> </div> `}if (typeof toggleButtonReadiness === 'function') {toggleButtonReadiness(false,'SWAP ERROR')}}},1000) }; const scoreboard = {data: [],weeklyData: [],openPositions: [],currentView: 'past_week',profitableTrades: [],weeklyProfitableTrades: [],settlementPriceCache: new Map(),init: function(autoLoadData = true) {console.log('Scoreboard init called,autoLoadData:',autoLoadData); const savedView = localStorage.getItem('scoreboard_view'); if (savedView && (savedView === 'all' || savedView === 'past_week')) {this.currentView = savedView}if (autoLoadData) {console.log('Loading scoreboard data...'); this.loadData()}else {console.log('Skipping data load on init (will load when user visits)')}this.setupEventListeners(); this.updatePeriodButtonsInitial(); console.log('Scoreboard init completed')},setupEventListeners: function() {const navScoreboard = document.getElementById('nav-scoreboard-bottom'); if (navScoreboard) {navScoreboard.addEventListener('click',(e) => {e.preventDefault(); showSection('scoreboard-section'); this.loadScoreboardData(); this.loadOpenPositionsData()})}const sortButtons = ['sort-by-pnl','sort-by-size','sort-by-time']; const periodButtons = ['scoreboard-period-all','scoreboard-period-week']; sortButtons.forEach(buttonId => {const button = document.getElementById(buttonId); if (button) {button.addEventListener('click',() => {this.updateSortButtons(buttonId); const criterion = buttonId.replace('sort-by-',''); this.sortOpenPositionsBy(criterion)})}}); periodButtons.forEach(buttonId => {const button = document.getElementById(buttonId); if (button) {button.addEventListener('click',() => {this.updatePeriodButtons(buttonId); const newView = buttonId === 'scoreboard-period-all' ? 'all' : 'past_week'; localStorage.setItem('scoreboard_view',newView); this.currentView = newView; this.renderScoreboard(); this.renderProfitableTrades()})}})},loadData: function() {this.loadScoreboardData(); this.loadOpenPositionsData()},loadScoreboardData: async function() {console.log('loadScoreboardData called'); try {document.getElementById('loading-scoreboard').style.display = 'block'; document.getElementById('no-scoreboard-data').style.display = 'none'; console.log('Fetching from https: const response = await fetch('https: if (!response.ok) {throw new Error(`Error fetching scoreboard data: ${response.status}`)}const data = await response.json(); if (!data || !data.all) {throw new Error('Invalid scoreboard data structure')}this.data = data.all.traders || []; this.weeklyData = data.past_week?.traders || []; this.profitableTrades = data.all.topProfitableTrades || []; this.weeklyProfitableTrades = data.past_week?.topProfitableTrades || []; this.renderScoreboard(); this.renderProfitableTrades(); document.getElementById('loading-scoreboard').style.display = 'none'}catch (error) {console.error("Error loading scoreboard data:",error); document.getElementById('loading-scoreboard').style.display = 'none'; document.getElementById('no-scoreboard-data').style.display = 'block'; document.getElementById('no-scoreboard-data').innerHTML = `<p>Error loading scoreboard: ${error.message}</p>`}},loadOpenPositionsData: async function() {try {document.getElementById('loading-open-positions').style.display = 'block'; document.getElementById('no-open-positions-data').style.display = 'none'; document.getElementById('open-positions-table-body').innerHTML = ''; const response = await fetch('https: if (!response.ok) {throw new Error(`Error fetching open positions data: ${response.status}`)}const data = await response.json(); if (!data || !data.positions || data.positions.length === 0) {document.getElementById('loading-open-positions').style.display = 'none'; document.getElementById('no-open-positions-data').style.display = 'block'; return}this.openPositions = data.positions; const pnlPromises = this.openPositions.map(async (position) => {try {position.pnl = await this.calculatePositionPnL(position)}catch (pnlError) {console.error(`Error calculating PnL for position ${position.address}:`,pnlError); position.pnl = {value: 0,percentage: 0,displayValue: 'Error',usd_value: 0,num_contracts: 0 }}}); await Promise.all(pnlPromises); const sortBySizeButton = document.getElementById('sort-by-size'); const sortByTimeButton = document.getElementById('sort-by-time'); let activeSortMethod = 'pnl'; if (sortBySizeButton && sortBySizeButton.classList.contains('active')) {activeSortMethod = 'size'}else if (sortByTimeButton && sortByTimeButton.classList.contains('active')) {activeSortMethod = 'time'}this.sortOpenPositionsBy(activeSortMethod); this.renderOpenPositions(); document.getElementById('loading-open-positions').style.display = 'none'; this.addRefreshButton()}catch (error) {console.error("Error loading open positions data:",error); document.getElementById('loading-open-positions').style.display = 'none'; document.getElementById('no-open-positions-data').style.display = 'block'; document.getElementById('no-open-positions-data').innerHTML = `<p>Error loading open positions: ${error.message}</p>`}},getLastSettlementTimestamp: function(asset) {const now = new Date(); const today8UTC = new Date(now.getUTCFullYear(),now.getUTCMonth(),now.getUTCDate(),8,0,0,0); if (now < today8UTC) {return new Date(today8UTC.getTime() - 24 * 60 * 60 * 1000).getTime()}else {return today8UTC.getTime()}},isSettlementTimeReached: function() {const now = new Date(); const today8UTC = new Date(now.getUTCFullYear(),now.getUTCMonth(),now.getUTCDate(),8,0,0,0); return now >= today8UTC},fetchSettlementPrice: async function(optionAddress,asset,cacheKey) {try {if (typeof WagmiCore !== 'undefined' && WagmiCore.readContract) {try {const {readContract }= WagmiCore; const twapResult = await readContract({address: optionAddress,abi: OPTION_ABI,functionName: 'getTWAP',chainId: 8453 }); const settlementPrice = parseFloat(twapResult.toString()) / 1e8; this.settlementPriceCache.set(cacheKey,settlementPrice); return settlementPrice}catch (wagmiError) {console.warn(`WagmiCore call failed for ${asset},trying fallback:`,wagmiError); throw wagmiError}}try {const rpcResult = await this.fallbackGetTWAP(optionAddress); if (rpcResult) {const settlementPrice = parseFloat(rpcResult) / 1e8; this.settlementPriceCache.set(cacheKey,settlementPrice); return settlementPrice}}catch (rpcError) {console.warn(`RPC fallback failed for ${asset}:`,rpcError)}console.error(`All methods failed to fetch settlement price for ${asset}`); return null}catch (error) {console.error(`Error fetching settlement price for ${asset}:`,error); return null}},fallbackGetTWAP: async function(optionAddress) {try {const response = await fetch('https: method: 'POST',headers: {'Content-Type': 'application/json',},body: JSON.stringify({jsonrpc: '2.0',id: 1,method: 'eth_call',params: [ {to: optionAddress,data: '0x05ecd003' },'latest' ] }) }); const result = await response.json(); if (result.error) {throw new Error(`RPC error: ${result.error.message}`)}if (result.result && result.result !== '0x') {return parseInt(result.result,16).toString()}return null}catch (error) {console.error('Fallback getTWAP failed:',error); return null}},getSettlementPrice: async function(asset,optionAddress = null) {const cacheKey = `${asset}_settlement_${this.getLastSettlementTimestamp(asset)}`; const cachedPrice = this.settlementPriceCache.get(cacheKey); if (cachedPrice !== undefined) {return cachedPrice}if (!optionAddress) {const samplePosition = this.openPositions.find(p => p.underlyingAsset === asset); if (samplePosition) {optionAddress = samplePosition.address}else {console.warn(`No option address found for ${asset},cannot fetch settlement price`); return null}}try {const settlementPrice = await this.fetchSettlementPrice(optionAddress,asset,cacheKey); return settlementPrice}catch (error) {console.error(`Failed to fetch settlement price for ${asset}:`,error); return null}},renderScoreboard: function() {const tableBody = document.getElementById('scoreboard-table-body'); tableBody.innerHTML = ''; const activeData = this.currentView === 'all' ? this.data : this.weeklyData; const scoreboardTitle = document.querySelector('#scoreboard-section h2'); if (scoreboardTitle) {scoreboardTitle.textContent = this.currentView === 'all' ? 'Trader Scoreboard' : 'Weekly Trader Scoreboard'}activeData.forEach((trader,index) => {const row = document.createElement('tr'); if (index < 3) {row.classList.add(`rank-${index + 1}`)}const displayAddress = `${trader.address.substring(0,6)}...${trader.address.substring(38)}`; const formatUSD = (value) => {if (value === null || value === undefined || isNaN(value)) {return '$0.00'}return '$' + value.toFixed(2)}; let rankDisplay = (index + 1).toString(); if (index === 0) rankDisplay = ' ' + rankDisplay; else if (index === 1) rankDisplay = ' ' + rankDisplay; else if (index === 2) rankDisplay = ' ' + rankDisplay; const streakData = trader.streaks || {}; const daysWithTrades = streakData.daysWithTrades || 0; const longestTradingStreak = streakData.longestTradingStreak || 0; const longestWinStreak = streakData.longestWinStreak || 0; const daysWithWins = streakData.daysWithWins || 0; const tradingStreakClass = longestTradingStreak >= 7 ? 'streak-impressive' : ''; const winStreakClass = longestWinStreak >= 7 ? 'streak-impressive' : ''; const streakDisplay = `${daysWithTrades}/ ${daysWithWins}/ ${longestTradingStreak}/ ${longestWinStreak}`; const streakTooltip = `Days with Trades: ${daysWithTrades}| Days with Wins: ${daysWithWins}| Longest Trading Streak: ${longestTradingStreak}days | Longest Win Streak: ${longestWinStreak}days`; row.innerHTML = ` <td><strong>${rankDisplay}</strong></td> <td title="${trader.address}" class="trader-address">${displayAddress}</td> <td>${formatUSD(trader.volume || 0)}</td> <td>${formatUSD(trader.premiumPaid || 0)}</td> <td class="${(trader.profit || 0) >= 0 ? 'text-success' : 'text-danger'}">${(trader.profit || 0) >= 0 ? '+' : ''}${formatUSD(trader.profit || 0)}</td> <td>${trader.numTrades || 0}</td> <td title="${streakTooltip}" class="streak-cell ${tradingStreakClass}${winStreakClass}">${streakDisplay}</td> <td><strong>${(trader.score || 0).toFixed(1)}</strong></td> `; tableBody.appendChild(row)}); if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')); tooltipTriggerList.map(function (tooltipTriggerEl) {return new bootstrap.Tooltip(tooltipTriggerEl)})}},updatePeriodButtons: function(activeButtonId) {const allButton = document.getElementById('scoreboard-period-all'); const weekButton = document.getElementById('scoreboard-period-week'); if (allButton) allButton.classList.remove('active'); if (weekButton) weekButton.classList.remove('active'); const activeButton = document.getElementById(activeButtonId); if (activeButton) activeButton.classList.add('active')},updatePeriodButtonsInitial: function() {const allButton = document.getElementById('scoreboard-period-all'); const weekButton = document.getElementById('scoreboard-period-week'); if (allButton) allButton.classList.remove('active'); if (weekButton) weekButton.classList.remove('active'); if (this.currentView === 'all') {if (allButton) allButton.classList.add('active')}else {if (weekButton) weekButton.classList.add('active')}},updateSortButtons: function(activeButtonId) {const sortButtons = ['sort-by-pnl','sort-by-size','sort-by-time']; sortButtons.forEach(buttonId => {const button = document.getElementById(buttonId); if (button) {button.classList.remove('active')}}); const activeButton = document.getElementById(activeButtonId); if (activeButton) {activeButton.classList.add('active')}},convertPnLToUSD: function(pnlValue,collateralSymbol) {if (!pnlValue || isNaN(pnlValue)) {return 0}if (collateralSymbol === 'USDC') {return pnlValue}if (collateralSymbol === 'WETH') {const ethPrice = state?.market_prices?.ETH || 0; return pnlValue * ethPrice}if (collateralSymbol === 'CBBTC') {const btcPrice = state?.market_prices?.BTC || 0; return pnlValue * btcPrice}return pnlValue},formatUSDTooltip: function(usdValue) {if (!usdValue || isNaN(usdValue)) {return 'USD value unavailable'}const formattedValue = Math.abs(usdValue) >= 1000 ? (usdValue / 1000).toFixed(1) + 'K' : usdValue.toFixed(2); return ` $${formattedValue}USD`},renderOpenPositions: function() {const tableBody = document.getElementById('open-positions-table-body'); tableBody.innerHTML = ''; this.openPositions.forEach((position) => {const row = document.createElement('tr'); const displayAddress = `${position.buyer.substring(0,6)}...${position.buyer.substring(38)}`; const strike = parseFloat(position.strikes[0]) / 10**8; const collateral = (parseFloat(position.numContracts) / 10**position.collateralDecimals).toFixed(4); const premium = (parseFloat(position.entryPremium) / 10**position.collateralDecimals).toFixed(4); const currentTime = Math.floor(Date.now() / 1000); const timeRemaining = Math.max(0,position.expiryTimestamp - currentTime); let timeRemainingText; if (timeRemaining <= 0) {timeRemainingText = 'Expired'}else {const hours = Math.floor(timeRemaining / 3600); const minutes = Math.floor((timeRemaining % 3600) / 60); const seconds = timeRemaining % 60; timeRemainingText = `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`}let optionTypeText; if (position.optionType === 0) {optionTypeText = 'INVERSE CALL'}else if (position.optionType === 257) {optionTypeText = 'PUT'}else {optionTypeText = `Type ${position.optionType}`}const pnlClass = position.pnl.value >= 0 ? 'text-success' : 'text-danger'; const pnlPrefix = position.pnl.value >= 0 ? '+' : ''; const pnlPercentage = position.pnl.percentage.toFixed(2); const pnlUSD = this.convertPnLToUSD(position.pnl.value,position.collateralSymbol); let usdTooltip = this.formatUSDTooltip(pnlUSD); const isExpired = position.expiryTimestamp <= currentTime; const isSettlementTimeReached = this.isSettlementTimeReached(); if (isExpired && isSettlementTimeReached) {const cacheKey = `${position.underlyingAsset}_settlement_${this.getLastSettlementTimestamp(position.underlyingAsset)}`; const cachedSettlementPrice = this.settlementPriceCache.get(cacheKey); if (cachedSettlementPrice !== undefined) {usdTooltip += `\nExpiry Price: $${cachedSettlementPrice.toFixed(2)}`; usdTooltip += `\nUsing TWAP settlement pricing`}else {usdTooltip += `\nExpired - Settlement price loading...`}}else if (isExpired && !isSettlementTimeReached) {usdTooltip += `\nExpired - Settlement at 08:00 UTC`}const expiryClass = isExpired ? 'expired-position' : ''; row.innerHTML = ` <td class="${expiryClass}">${displayAddress}</td> <td>${position.underlyingAsset}</td> <td>${optionTypeText}</td> <td>${strike.toLocaleString()}</td> <td>${collateral}${position.collateralSymbol}</td> <td>${premium}${position.collateralSymbol}</td> <td class="${pnlClass}${expiryClass}" title="${usdTooltip}" style="cursor: help;"><strong>${pnlPrefix}${position.pnl.displayValue}(${pnlPrefix}${pnlPercentage}%)</strong></td> <td class="${timeRemaining < 3600 ? 'text-danger' : ''}${expiryClass}">${timeRemainingText}</td> <td> <a href="https: View </a> </td> `; tableBody.appendChild(row)})},calculatePositionPnL: async function(position) {let currentPrice = state?.market_prices?.[position.underlyingAsset] || 0; const currentTime = Math.floor(Date.now() / 1000); const isExpired = position.expiryTimestamp < currentTime; if (isExpired && this.isSettlementTimeReached()) {const settlementPrice = await this.getSettlementPrice(position.underlyingAsset,position.address); if (settlementPrice) {currentPrice = settlementPrice}}if (!currentPrice) {return {value: 0,percentage: 0,displayValue: 'N/A' }}const strike = parseFloat(position.strikes[0]) / 10**8; const premium = parseFloat(position.entryPremium) / 10**position.collateralDecimals; let contractSize = parseFloat(position.numContracts) / 10**position.collateralDecimals; let currentValue = 0; if (position.optionType === 0) {if (currentPrice > strike) {const priceDifference = 1 - (strike / currentPrice); currentValue = contractSize * priceDifference}else {currentValue = 0}}else if (position.optionType === 257) {if (currentPrice < strike) {const priceDifference = strike - currentPrice; currentValue = contractSize * priceDifference}else {currentValue = 0}}const pnlValue = currentValue - premium; const pnlPercentage = (pnlValue / premium) * 100; let displayValue; if (position.collateralDecimals === 6) {displayValue = `$${Math.abs(pnlValue).toFixed(2)}`}else if (position.collateralDecimals === 8) {displayValue = `${Math.abs(pnlValue).toFixed(8)}${position.collateralSymbol}`}else if (position.collateralDecimals === 18) {displayValue = `${Math.abs(pnlValue).toFixed(6)}${position.collateralSymbol}`}else {displayValue = Math.abs(pnlValue).toFixed(4)}return {value: pnlValue,percentage: pnlPercentage,displayValue: displayValue,usd_value: pnlValue * (position.optionType == 0 ? currentPrice : 1),num_contracts: contractSize }},sortOpenPositionsBy: function(criterion) {if (!this.openPositions || this.openPositions.length === 0) return; switch (criterion) {case 'pnl': this.openPositions.sort((a,b) => b.pnl.usd_value - a.pnl.usd_value); break; case 'size': this.openPositions.sort((a,b) => b.pnl.num_contracts - a.pnl.num_contracts); break; case 'time': const now = Math.floor(Date.now() / 1000); this.openPositions.sort((a,b) => {const aTimeLeft = a.expiryTimestamp - now; const bTimeLeft = b.expiryTimestamp - now; return aTimeLeft - bTimeLeft}); break}this.renderOpenPositions()},renderProfitableTrades: function() {const tableBody = document.getElementById('profitable-trades-table-body'); if (!tableBody) {return}tableBody.innerHTML = ''; const loadingElement = document.getElementById('loading-profitable-trades'); const noDataElement = document.getElementById('no-profitable-trades-data'); if (loadingElement) loadingElement.style.display = 'block'; if (noDataElement) noDataElement.style.display = 'none'; const activeTrades = this.currentView === 'all' ? this.profitableTrades : this.weeklyProfitableTrades; const profitableTradesTitle = document.querySelector('#scoreboard-section h2:nth-of-type(3)'); if (profitableTradesTitle) {profitableTradesTitle.textContent = this.currentView === 'all' ? 'Top Profitable Trades' : 'Top Weekly Profitable Trades'}if (!activeTrades || activeTrades.length === 0) {if (loadingElement) loadingElement.style.display = 'none'; if (noDataElement) {noDataElement.style.display = 'block'; noDataElement.innerHTML = '<p>No profitable trades data available yet.</p>'}return}activeTrades.forEach((trade,index) => {const row = document.createElement('tr'); if (index < 3) {row.classList.add(`rank-${index + 1}`)}let displayAddress = 'Unknown'; if (trade.userAddress) {displayAddress = `${trade.userAddress.substring(0,6)}...${trade.userAddress.substring(38)}`}const formatUSD = (value) => {if (value === null || value === undefined || isNaN(value)) {return '$0.00'}return '$' + value.toFixed(2)}; let rankDisplay = (index + 1).toString(); if (index === 0) rankDisplay = ' ' + rankDisplay; else if (index === 1) rankDisplay = ' ' + rankDisplay; else if (index === 2) rankDisplay = ' ' + rankDisplay; const returnPercentage = (trade.percentageReturn || 0).toFixed(2); let tradeDescription = trade.tradeDescription || 'Trade details unavailable'; const profit = formatUSD(trade.absoluteReturn || 0); const premiumPaid = formatUSD(trade.premiumPaid || 0); const asset = trade.asset || 'Unknown'; const userAddress = trade.userAddress || ''; row.innerHTML = ` <td><strong>${rankDisplay}</strong></td> <td title="${userAddress}" class="trader-address">${displayAddress}</td> <td>${tradeDescription}</td> <td class="text-success"><strong>${profit}</strong></td> <td class="text-success"><strong>+${returnPercentage}%</strong></td> <td>${premiumPaid}</td> <td>${asset}</td> `; tableBody.appendChild(row)}); if (loadingElement) loadingElement.style.display = 'none'; if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')); tooltipTriggerList.map(function (tooltipTriggerEl) {return new bootstrap.Tooltip(tooltipTriggerEl)})}},refreshSettlementPrices: async function() {this.clearExpiredCache(); this.settlementPriceCache.clear(); const pnlPromises = this.openPositions.map(async (position) => {try {position.pnl = await this.calculatePositionPnL(position)}catch (pnlError) {console.error(`Error calculating PnL for position ${position.address}:`,pnlError); position.pnl = {value: 0,percentage: 0,displayValue: 'Error',usd_value: 0,num_contracts: 0 }}}); await Promise.all(pnlPromises); this.renderOpenPositions()},clearExpiredCache: function() {const currentTime = Date.now(); const maxCacheAge = 24 * 60 * 60 * 1000; for (const [key,value] of this.settlementPriceCache.entries()) {const timestampMatch = key.match(/_settlement_(\d+)$/); if (timestampMatch) {const cacheTimestamp = parseInt(timestampMatch[1]); if (currentTime - cacheTimestamp > maxCacheAge) {this.settlementPriceCache.delete(key)}}}},addRefreshButton: function() {const sortControls = document.querySelector('.sort-controls .btn-group'); if (sortControls && !document.getElementById('refresh-positions-btn')) {const refreshButton = document.createElement('button'); refreshButton.id = 'refresh-positions-btn'; refreshButton.className = 'btn btn-outline-primary'; refreshButton.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh'; refreshButton.title = 'Refresh positions data'; refreshButton.addEventListener('click',() => {this.loadOpenPositionsData()}); sortControls.appendChild(refreshButton)}}}; window.scoreboard = scoreboard; class AnalyticsManager {constructor() {this.analyticsApiUrl = 'https: this.currentAsset = 'ETH'; this.analyticsData = null; this.chartExpanded = false; this.analyticsCollapsed = false; this.tradingViewWidget = null; this.refreshInterval = null; this.shouldInitializeChartOnDataLoad = false; this.levelTypes = {'Put Support': 'support','Put Support 0DTE': 'support','Put Support 1W': 'support','Put Support 1M': 'support','Put Flow Support': 'support','Call Resistance': 'resistance','Call Resistance 0DTE': 'resistance','Call Resistance 1W': 'resistance','Call Resistance 1M': 'resistance','Call Flow Resistance': 'resistance','Gamma Wall (Short Gamma)': 'gamma-wall','Gamma Wall (Long Gamma)': 'gamma-wall','HVL': 'gamma-wall','HVS': 'gamma-wall','Max Pain Flow': 'gamma-wall','VWAS': 'gamma-wall' }; this.levelDescriptions = {'Put Support 0DTE': 'High open interest put strikes for today\'s expiration - often act as support levels','Call Resistance 0DTE': 'High open interest call strikes for today\'s expiration - often act as resistance levels','Put Support': 'Current weekly/monthly put support based on open interest','Call Resistance': 'Current weekly/monthly call resistance based on open interest','Gamma Wall (Short Gamma)': 'Strike where dealers are short gamma - amplifies price volatility as dealers chase the move','Gamma Wall (Long Gamma)': 'Strike where dealers are long gamma - can create volatility dampening','HVL': 'High Volume Level from recent futures trading activity','HVS': 'Highest Volume Strike from recent options flow','Max Pain Flow': 'Strike with balanced call/put flow - potential equilibrium level','Put Flow Support': 'Support level based on recent put buying activity','Call Flow Resistance': 'Resistance level based on recent call buying activity','VWAS': 'Volume Weighted Average Strike from recent options activity','1D Max': '24-hour high price level','1D Min': '24-hour low price level' }; this.initialize()}initialize() {this.setupEventListeners(); this.startPeriodicRefresh(); this.checkInitialChartState()}checkInitialChartState() {setTimeout(() => {const chartSection = document.getElementById('analytics-chart-section'); const toggleBtn = document.getElementById('toggle-analytics-view'); if (chartSection && toggleBtn && chartSection.style.display === 'block') {this.chartExpanded = true; if (this.analyticsData) {this.initializeTradingViewChart(); this.updateLevelsLegend()}else {this.shouldInitializeChartOnDataLoad = true}}},1000)}setupEventListeners() {const refreshBtn = document.getElementById('refresh-analytics'); if (refreshBtn) {refreshBtn.addEventListener('click',() => this.refreshAnalytics(true))}const toggleBtn = document.getElementById('toggle-analytics-view'); if (toggleBtn) {toggleBtn.addEventListener('click',() => this.toggleChartView())}const toggleSectionBtn = document.getElementById('toggle-analytics-section'); if (toggleSectionBtn) {toggleSectionBtn.addEventListener('click',() => this.toggleAnalyticsSection())}this.initializeDialTooltips(); const assetDropdown = document.getElementById('assetDropdown'); if (assetDropdown) {assetDropdown.parentElement.addEventListener('click',(event) => {if (event.target.hasAttribute('data-asset')) {const newAsset = event.target.getAttribute('data-asset'); if (newAsset !== this.currentAsset) {console.log(`Asset changed: ${this.currentAsset} ${newAsset}`); this.currentAsset = newAsset; setTimeout(() => this.refreshAnalytics(),100)}}})}const selectedAssetElement = document.getElementById('selected-asset'); if (selectedAssetElement) {const observer = new MutationObserver(() => {const newAsset = selectedAssetElement.textContent.trim(); if (newAsset && newAsset !== this.currentAsset) {this.currentAsset = newAsset; setTimeout(() => this.refreshAnalytics(),100)}}); observer.observe(selectedAssetElement,{childList: true,subtree: true,characterData: true }); this.assetObserver = observer}const convictionSlider = document.getElementById('conviction-slider'); if (convictionSlider) {convictionSlider.addEventListener('input',() => {clearTimeout(this.overlayUpdateTimeout); this.overlayUpdateTimeout = setTimeout(() => {this.updateLevelOverlays()},100)})}this.observePriceTargetChanges(); this.syncPriceRangeLabels()}initializeDialTooltips() {if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {const dialElements = document.querySelectorAll('.ratio-dial[title]'); dialElements.forEach(element => {new bootstrap.Tooltip(element,{placement: 'bottom',trigger: 'hover',delay: {show: 300,hide: 100 }})})}}observePriceTargetChanges() {const lowPriceElement = document.getElementById('low-price'); const highPriceElement = document.getElementById('high-price'); if (lowPriceElement && highPriceElement) {const observer = new MutationObserver(() => {clearTimeout(this.overlayUpdateTimeout); this.overlayUpdateTimeout = setTimeout(() => {this.updateLevelOverlays()},200)}); observer.observe(lowPriceElement,{childList: true,subtree: true,characterData: true }); observer.observe(highPriceElement,{childList: true,subtree: true,characterData: true }); this.priceObserver = observer}}syncPriceRangeLabels() {const updateLabels = () => {const lowPriceElement = document.getElementById('low-price'); const highPriceElement = document.getElementById('high-price'); const rangeLowDisplay = document.getElementById('range-low-display'); const rangeHighDisplay = document.getElementById('range-high-display'); if (lowPriceElement && highPriceElement && rangeLowDisplay && rangeHighDisplay) {rangeLowDisplay.textContent = lowPriceElement.textContent; rangeHighDisplay.textContent = highPriceElement.textContent}}; updateLabels(); const convictionSlider = document.getElementById('conviction-slider'); if (convictionSlider) {convictionSlider.addEventListener('input',updateLabels)}const lowPriceElement = document.getElementById('low-price'); const highPriceElement = document.getElementById('high-price'); if (lowPriceElement && highPriceElement) {const observer = new MutationObserver(updateLabels); observer.observe(lowPriceElement,{childList: true,subtree: true,characterData: true }); observer.observe(highPriceElement,{childList: true,subtree: true,characterData: true }); this.priceRangeLabelObserver = observer}}startPeriodicRefresh() {this.refreshInterval = setInterval(() => {this.refreshAnalytics()},5 * 60 * 1000); this.refreshAnalytics()}async refreshAnalytics(force = false) {const statusElement = document.getElementById('analytics-status'); if (statusElement) {statusElement.innerHTML = '<small class="text-muted"><i class="bi bi-arrow-clockwise"></i> Refreshing analytics...</small>'}try {const url = `${this.analyticsApiUrl}?currency=${this.currentAsset}${force ? '&refresh=true' : ''}`; const response = await fetch(url); if (!response.ok) {throw new Error(`Analytics API error: ${response.status}`)}const data = await response.json(); if (data.success) {this.analyticsData = data.data; this.updateAnalyticsUI(); if (statusElement) {const cacheInfo = data.data.metadata.cache_info || {}; const timestamp = data.timestamp || new Date().toISOString(); const lastUpdate = new Date(timestamp).toLocaleTimeString(); statusElement.innerHTML = `<small class="text-muted">Last updated: ${lastUpdate}| Cache: ${cacheInfo.local_cache_size || 0}items</small>`}}else {throw new Error(data.error || 'Unknown API error')}}catch (error) {console.error('Failed to fetch analytics:',error); if (statusElement) {statusElement.innerHTML = `<div class="analytics-error">Failed to load analytics: ${error.message}</div>`}}}updateAnalyticsUI() {if (!this.analyticsData) return; this.updatePutCallRatioDials(); this.updateLevelOverlays(); if (this.chartExpanded) {this.updateLevelsLegend()}if (this.shouldInitializeChartOnDataLoad) {this.initializeTradingViewChart(); this.updateLevelsLegend(); this.shouldInitializeChartOnDataLoad = false}if (this.tradingViewWidget) {this.updateTradingViewChart()}}updatePutCallRatioDials() {const ratios = this.analyticsData.metadata.put_call_ratios || {}; const dialMappings = {'overall': ratios.Current || 0,'0dte': ratios['0DTE'] || 0,'1w': ratios['1W'] || 0,'1m': ratios['1M'] || 0 }; Object.entries(dialMappings).forEach(([key,ratio]) => {this.updateDial(key,ratio)})}updateDial(dialId,ratio) {const dialNeedle = document.getElementById(`dial-${dialId}`); const dialValue = document.getElementById(`ratio-${dialId}-inline`); if (!dialNeedle || !dialValue) return; let angle = 0; if (ratio > 0) {if (ratio > 1.2) {const bearishBase = Math.min(3.0,ratio); const bearishProgress = (bearishBase - 1.2) / 1.8; angle = -30 - (bearishProgress * 60); if (ratio > 3.0) {angle = -90}}else if (ratio >= 0.8) {const neutralProgress = (ratio - 0.8) / 0.4; angle = -30 + (neutralProgress * 60)}else {const bullishRange = Math.max(0.0,Math.min(0.8,ratio)); const bullishProgress = 1 - (bullishRange / 0.8); angle = 30 + (bullishProgress * 60)}}dialNeedle.style.transform = `translate(-50%,-100%) rotate(${angle}deg)`; dialValue.textContent = ratio > 0 ? `(${ratio.toFixed(2)})` : '(--)'; if (ratio > 0) {if (ratio > 1.2) {dialValue.style.color = 'var(--negative)'}else if (ratio >= 0.8) {dialValue.style.color = 'var(--accent)'}else {dialValue.style.color = 'var(--positive)'}}else {dialValue.style.color = 'var(--text-secondary)'}}updateLevelOverlays() {if (!this.analyticsData) return; const overlay = document.getElementById('analytics-levels-overlay'); const lowPriceElement = document.getElementById('low-price'); const highPriceElement = document.getElementById('high-price'); if (!overlay || !lowPriceElement || !highPriceElement) return; const lowPriceText = lowPriceElement.textContent.replace('$','').replace(',',''); const highPriceText = highPriceElement.textContent.replace('$','').replace(',',''); const lowPrice = parseFloat(lowPriceText); const highPrice = parseFloat(highPriceText); if (!lowPrice || !highPrice || lowPrice >= highPrice) {return}overlay.innerHTML = ''; const relevantLevels = this.analyticsData.key_levels.filter(level => {const withinRange = level.value >= lowPrice && level.value <= highPrice; return withinRange}); if (relevantLevels.length === 0) {const rangeWidth = highPrice - lowPrice; const extendedLow = lowPrice - (rangeWidth * 0.5); const extendedHigh = highPrice + (rangeWidth * 0.5); const nearbyLevels = this.analyticsData.key_levels.filter(level => {return level.value >= extendedLow && level.value <= extendedHigh}); if (nearbyLevels.length > 0) {nearbyLevels.sort((a,b) => {const distA = Math.min(Math.abs(a.value - lowPrice),Math.abs(a.value - highPrice)); const distB = Math.min(Math.abs(b.value - lowPrice),Math.abs(b.value - highPrice)); return distA - distB}); const topNearby = nearbyLevels.slice(0,3); topNearby.forEach(level => {const indicator = this.createNearbyLevelIndicator(level,lowPrice,highPrice); overlay.appendChild(indicator)}); return}}const consolidatedLevels = new Map(); relevantLevels.forEach(level => {const priceKey = Math.round(level.value); if (consolidatedLevels.has(priceKey)) {const existing = consolidatedLevels.get(priceKey); existing.names.push(level.name); existing.confidence = Math.max(existing.confidence,level.confidence); existing.combinedLevel = true}else {consolidatedLevels.set(priceKey,{value: level.value,names: [level.name],distance_to_spot: level.distance_to_spot,confidence: level.confidence,combinedLevel: false })}}); const finalLevels = Array.from(consolidatedLevels.values()) .sort((a,b) => b.confidence - a.confidence); finalLevels.forEach(level => {const marker = this.createConsolidatedLevelMarker(level,lowPrice,highPrice); overlay.appendChild(marker)})}createLevelMarker(level,lowPrice,highPrice) {const marker = document.createElement('div'); marker.className = `level-marker ${this.getLevelType(level.name)}`; marker.setAttribute('data-level-name',level.name); marker.setAttribute('data-level-price',`$${level.value.toLocaleString()}`); marker.setAttribute('data-level-description',this.levelDescriptions[level.name] || 'Market level'); const position = ((level.value - lowPrice) / (highPrice - lowPrice)) * 100; marker.style.left = `${position}%`; marker.style.top = '0'; marker.addEventListener('mouseenter',(e) => {this.showLevelTooltip(e,level)}); marker.addEventListener('mouseleave',() => {this.hideLevelTooltip()}); return marker}createConsolidatedLevelMarker(level,lowPrice,highPrice) {const marker = document.createElement('div'); const firstLevelType = this.getLevelType(level.names[0]); marker.className = `level-marker ${firstLevelType}`; const displayName = level.combinedLevel ? `${level.names.length}Levels` : level.names[0]; marker.setAttribute('data-level-name',displayName); marker.setAttribute('data-level-price',`$${level.value.toLocaleString()}`); marker.setAttribute('data-level-names',level.names.join(',')); marker.setAttribute('data-combined',level.combinedLevel.toString()); const position = ((level.value - lowPrice) / (highPrice - lowPrice)) * 100; marker.style.left = `${position}%`; marker.style.top = '0'; if (level.combinedLevel) {marker.style.width = '3px'; marker.style.height = '25px'}marker.addEventListener('mouseenter',(e) => {this.showConsolidatedLevelTooltip(e,level)}); marker.addEventListener('mouseleave',() => {this.hideLevelTooltip()}); return marker}createNearbyLevelIndicator(level,lowPrice,highPrice) {const indicator = document.createElement('div'); indicator.className = `level-marker ${this.getLevelType(level.name)}nearby-level`; indicator.setAttribute('data-level-name',`${level.name}(nearby)`); indicator.setAttribute('data-level-price',`$${level.value.toLocaleString()}`); indicator.setAttribute('data-level-description',this.levelDescriptions[level.name] || 'Market level'); if (level.value < lowPrice) {indicator.style.left = '2%'}else {indicator.style.left = '98%'}indicator.style.top = '0'; indicator.addEventListener('mouseenter',(e) => {this.showLevelTooltip(e,level)}); indicator.addEventListener('mouseleave',() => {this.hideLevelTooltip()}); return indicator}getLevelType(levelName) {return this.levelTypes[levelName] || 'gamma-wall'}showLevelTooltip(event,level) {this.hideLevelTooltip(); const tooltip = document.createElement('div'); tooltip.className = 'level-tooltip show'; tooltip.innerHTML = ` <div class="tooltip-title">${level.name}</div> <div class="tooltip-price">$${level.value.toLocaleString()}</div> <div class="tooltip-description">${this.levelDescriptions[level.name] || 'Market level'}</div> `; document.body.appendChild(tooltip); const rect = event.target.getBoundingClientRect(); const scrollX = window.pageXOffset || document.documentElement.scrollLeft; const scrollY = window.pageYOffset || document.documentElement.scrollTop; tooltip.style.left = `${rect.left + scrollX - 50}px`; tooltip.style.top = `${rect.top + scrollY - tooltip.offsetHeight - 10}px`; const tooltipRect = tooltip.getBoundingClientRect(); if (tooltipRect.left < 0) {tooltip.style.left = `${scrollX + 10}px`}if (tooltipRect.right > window.innerWidth) {tooltip.style.left = `${scrollX + window.innerWidth - tooltipRect.width - 10}px`}this.currentTooltip = tooltip}showConsolidatedLevelTooltip(event,level) {this.hideLevelTooltip(); const tooltip = document.createElement('div'); tooltip.className = 'level-tooltip show'; let tooltipContent = ` <div class="tooltip-price">$${level.value.toLocaleString()}</div> `; if (level.combinedLevel) {tooltipContent += `<div class="tooltip-title">${level.names.length}Consolidated Levels</div>`; tooltipContent += `<div class="tooltip-description">`; level.names.forEach(name => {const description = this.levelDescriptions[name]; tooltipContent += `<strong>${name}</strong>`; if (description) {tooltipContent += `<br><small>${description}</small>`}tooltipContent += `<br>`}); tooltipContent += `</div>`}else {const levelName = level.names[0]; tooltipContent += `<div class="tooltip-title">${levelName}</div>`; tooltipContent += `<div class="tooltip-description">${this.levelDescriptions[levelName] || 'Market level'}</div>`}tooltip.innerHTML = tooltipContent; document.body.appendChild(tooltip); const rect = event.target.getBoundingClientRect(); const scrollX = window.pageXOffset || document.documentElement.scrollLeft; const scrollY = window.pageYOffset || document.documentElement.scrollTop; tooltip.style.left = `${rect.left + scrollX - 50}px`; tooltip.style.top = `${rect.top + scrollY - tooltip.offsetHeight - 10}px`; const tooltipRect = tooltip.getBoundingClientRect(); if (tooltipRect.left < 0) {tooltip.style.left = `${scrollX + 10}px`}if (tooltipRect.right > window.innerWidth) {tooltip.style.left = `${scrollX + window.innerWidth - tooltipRect.width - 10}px`}this.currentTooltip = tooltip}hideLevelTooltip() {if (this.currentTooltip) {this.currentTooltip.remove(); this.currentTooltip = null}}toggleChartView() {const chartSection = document.getElementById('analytics-chart-section'); const toggleBtn = document.getElementById('toggle-analytics-view'); if (!chartSection || !toggleBtn) return; this.chartExpanded = !this.chartExpanded; if (this.chartExpanded) {chartSection.style.display = 'block'; toggleBtn.innerHTML = '<i class="bi bi-arrows-collapse"></i>'; toggleBtn.setAttribute('title','Collapse Chart View'); this.initializeTradingViewChart(); this.updateLevelsLegend()}else {chartSection.style.display = 'none'; toggleBtn.innerHTML = '<i class="bi bi-arrows-fullscreen"></i>'; toggleBtn.setAttribute('title','Expand Chart View'); this.destroyTradingViewChart()}if (window.uiStateManager) {window.uiStateManager.saveState('analytics_chart_expanded',this.chartExpanded)}}toggleAnalyticsSection() {let analyticsContent = document.getElementById('analytics-content'); if (!analyticsContent) {const supportSection = document.querySelector('.support-resistance-section'); const dialSection = document.querySelector('.pc-ratio-dials'); const statusSection = document.getElementById('analytics-status'); const chartSection = document.getElementById('analytics-chart-section'); analyticsContent = {elements: [supportSection,dialSection,statusSection,chartSection].filter(Boolean),style: {display: '' }}}const toggleBtn = document.getElementById('toggle-analytics-section'); if (!toggleBtn) return; this.analyticsCollapsed = !this.analyticsCollapsed; if (this.analyticsCollapsed) {if (analyticsContent.elements) {analyticsContent.elements.forEach(element => {element.style.display = 'none'})}else {analyticsContent.style.display = 'none'}toggleBtn.innerHTML = '<i class="bi bi-chevron-down"></i>'; toggleBtn.setAttribute('title','Show Market Analytics')}else {if (analyticsContent.elements) {analyticsContent.elements.forEach(element => {element.style.display = ''})}else {analyticsContent.style.display = ''}toggleBtn.innerHTML = '<i class="bi bi-chevron-up"></i>'; toggleBtn.setAttribute('title','Hide Market Analytics')}if (window.uiStateManager) {window.uiStateManager.saveState('analytics_collapsed',this.analyticsCollapsed)}}initializeTradingViewChart() {if (this.tradingViewWidget) {this.destroyTradingViewChart()}const symbolMap = {'ETH': 'COINBASE:ETHUSD','BTC': 'COINBASE:BTCUSD' }; const symbol = symbolMap[this.currentAsset] || 'COINBASE:ETHUSD'; try {this.tradingViewWidget = new TradingView.widget({width: '100%',height: 400,symbol: symbol,interval: '15',timezone: 'Etc/UTC',theme: 'dark',style: '1',locale: 'en',toolbar_bg: '#192734',enable_publishing: false,hide_top_toolbar: false,hide_legend: false,save_image: false,container_id: 'tradingview_chart',studies: [ 'Volume@tv-basicstudies' ] }); setTimeout(() => {this.updateTradingViewChart()},2000)}catch (error) {console.error('Failed to initialize TradingView chart:',error)}}updateTradingViewChart() {}destroyTradingViewChart() {if (this.tradingViewWidget) {try {this.tradingViewWidget.remove()}catch (error) {console.error('Error destroying TradingView widget:',error)}this.tradingViewWidget = null}const chartContainer = document.getElementById('tradingview_chart'); if (chartContainer) {chartContainer.innerHTML = ''}}updateLevelsLegend() {if (!this.analyticsData) return; const legendContainer = document.getElementById('levels-list'); if (!legendContainer) return; legendContainer.innerHTML = ''; const sortedLevels = [...this.analyticsData.key_levels] .sort((a,b) => {if (b.confidence !== a.confidence) {return b.confidence - a.confidence}return Math.abs(a.distance_to_spot) - Math.abs(b.distance_to_spot)}) .slice(0,12); sortedLevels.forEach(level => {const levelItem = document.createElement('div'); levelItem.className = `level-item ${this.getLevelType(level.name)}`; levelItem.innerHTML = ` <div> <div class="level-name">${level.name}</div> </div> <div class="level-price">$${level.value.toLocaleString()}</div> `; levelItem.addEventListener('mouseenter',(e) => {this.showLevelTooltip(e,level)}); levelItem.addEventListener('mouseleave',() => {this.hideLevelTooltip()}); levelItem.style.cursor = 'pointer'; legendContainer.appendChild(levelItem)})}destroy() {if (this.refreshInterval) {clearInterval(this.refreshInterval)}if (this.overlayUpdateTimeout) {clearTimeout(this.overlayUpdateTimeout)}if (this.priceObserver) {this.priceObserver.disconnect()}if (this.assetObserver) {this.assetObserver.disconnect()}if (this.priceRangeLabelObserver) {this.priceRangeLabelObserver.disconnect()}this.destroyTradingViewChart(); this.hideLevelTooltip()}}document.addEventListener('DOMContentLoaded',function() {if (document.getElementById('analytics-dashboard')) {window.analyticsManager = new AnalyticsManager()}}); if (typeof module !== 'undefined' && module.exports) {module.exports = AnalyticsManager}const TROLLBOX_CONTENT_RULES = {minLength: 2,maxLength: 200,blockedPatterns: [ {pattern: /https?:\/\ reason: 'No links allowed in chat' },{pattern: /www\./i,reason: 'No links allowed in chat' },{pattern: /\b\w+\.(com|org|net|io|fi|xyz|me|co)\b/i,reason: 'No links allowed in chat' },{pattern: /\b(telegram|discord|join|group|channel)\b/i,reason: 'No promotional content allowed' },{pattern: /\b(airdrop|giveaway|free|claim|reward)\b/i,reason: 'No promotional content allowed' },{pattern: /\b(pump|dump|moon|scam|rug)\b/i,reason: 'No pump/dump discussion allowed' },{pattern: /\b(buy|sell)\s+(now|asap|quick|fast)\b/i,reason: 'No financial advice allowed' },{pattern: /@\w+/,reason: 'No contact information allowed' },{pattern: /\b\d{10,}\b/,reason: 'No phone numbers allowed' }],rateLimitWindow: 60000,maxMessagesPerWindow: 5,requiredFields: ['text','author','authorAddress','timestamp'],addressPattern: /^0x[a-fA-F0-9]{40}$/,adminRules: {exemptFromPatterns: true,exemptFromRateLimit: true,maxLength: 500,minLength: 1 }}; if (typeof module !== 'undefined' && module.exports) {module.exports = {TROLLBOX_CONTENT_RULES }}function generateFirebaseRules() {const rules = TROLLBOX_CONTENT_RULES; const urlPatterns = rules.blockedPatterns .filter(rule => rule.reason.includes('links')) .map(rule => rule.pattern.source.replace(/\\b/g,'').replace(/\\/g,'\\\\')) .join('|'); const spamPatterns = rules.blockedPatterns .filter(rule => rule.reason.includes('promotional') || rule.reason.includes('pump')) .map(rule => rule.pattern.source.replace(/\\b/g,'').replace(/\\/g,'\\\\')) .join('|'); return ` function isValidMessage(text) {let lowerText = text.lower(); return text.size() >= ${rules.minLength}&& text.size() <= ${rules.maxLength}&& !lowerText.matches('(${urlPatterns})') && !lowerText.matches('(${spamPatterns})')}`.trim()}class OdetteTrollbox {constructor() {this.isInitialized = false; this.db = null; this.currentUser = null; this.messagesRef = null; this.unsubscribe = null; this.lastMessageTime = 0; this.messageCount = 0; this.rateLimitWindow = TROLLBOX_CONTENT_RULES.rateLimitWindow; this.maxMessagesPerWindow = TROLLBOX_CONTENT_RULES.maxMessagesPerWindow; this.isMinimized = false; this.isHidden = true; this.unreadCount = 0; this.displayedMessages = new Set(); this.lastSeenTimestamp = this.getLastSeenTimestamp(); this.initialLoadComplete = false; this.oldestLoadedTimestamp = null; this.totalLoadedMessages = 0; this.currentEmojiPicker = null; this.availableEmojis = [ {emoji: '',name: 'thumbs_up',label: 'Thumbs up' },{emoji: '',name: 'thumbs_down',label: 'Thumbs down' },{emoji: '',name: 'laugh',label: 'Laugh' },{emoji: '',name: 'fire',label: 'Fire' },{emoji: '',name: 'cry',label: 'Cry' },{emoji: '',name: 'thinking',label: 'Thinking' }]; this.isResizing = false; this.startY = 0; this.startHeight = 0; this.savedHeight = null; this.minHeight = 300; this.maxHeight = window.innerHeight * 0.8; if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded',() => this.init())}else {this.init()}}async init() {try {await this.initializeFirebase(); this.setupEventListeners(); setTimeout(() => {this.initializeUI()},500); this.setupWalletIntegration(); await this.loadRecentMessages(); this.isInitialized = true}catch (error) {console.error('Trollbox initialization failed:',error); this.showStatus('Failed to initialize chat. Please refresh the page.')}}initializeUI() {const hasStateManager = window.uiStateManager && window.uiStateManager.loadState; if (hasStateManager) {const isVisible = window.uiStateManager.loadState('trollbox_visible'); const isMinimized = window.uiStateManager.loadState('trollbox_minimized'); if (isVisible) {this.show()}else {this.loadSavedHeight()}return}const wasDismissed = localStorage.getItem('trollbox_dismissed') === 'true'; if (wasDismissed) {this.hide(); this.loadSavedHeight()}else {setTimeout(() => {if (this.isHidden) {this.show()}},3000)}}async initializeFirebase() {if (window.firebase && window.firebase.apps.length > 0) {this.db = window.firebase.firestore(); this.setupPresenceSystem(); return}const firebaseConfig = {apiKey: "AIzaSyDOOngf29QH3KoRf8q_F9CcbyQCJkfSvD8",authDomain: "odette-trollbox.firebaseapp.com",projectId: "odette-trollbox",storageBucket: "odette-trollbox.firebasestorage.app",messagingSenderId: "927729508636",appId: "1:927729508636:web:8d120ebdaa7e6262b85ad9",measurementId: "G-LSK6HNP2V6" }; if (!window.firebase) {await this.loadFirebaseSDK()}if (!window.firebase.apps.length) {window.firebase.initializeApp(firebaseConfig)}this.db = window.firebase.firestore(); this.messagesRef = this.db.collection('trollbox_messages'); this.setupPresenceSystem()}async loadFirebaseSDK() {return new Promise((resolve,reject) => {const script1 = document.createElement('script'); script1.src = 'https: script1.onload = () => {const script2 = document.createElement('script'); script2.src = 'https: script2.onload = resolve; script2.onerror = reject; document.head.appendChild(script2)}; script1.onerror = reject; document.head.appendChild(script1)})}setupEventListeners() {const toggleBtn = document.getElementById('trollbox-toggle'); const minimizeBtn = document.getElementById('trollbox-minimize'); const closeBtn = document.getElementById('trollbox-close'); const header = document.getElementById('trollbox-header'); const input = document.getElementById('trollbox-input'); const sendBtn = document.getElementById('trollbox-send'); const resizeHandle = document.getElementById('trollbox-resize-handle'); if (toggleBtn) {toggleBtn.addEventListener('click',() => this.show())}if (header) {header.addEventListener('click',(e) => {if (!e.target.closest('.trollbox-controls')) {this.toggleMinimize()}})}if (minimizeBtn) {minimizeBtn.addEventListener('click',(e) => {e.stopPropagation(); this.minimize()})}if (closeBtn) {closeBtn.addEventListener('click',(e) => {e.stopPropagation(); this.hide()})}if (input) {input.addEventListener('keypress',(e) => {if (e.key === 'Enter' && !e.shiftKey) {e.preventDefault(); this.sendMessage()}}); input.addEventListener('input',() => {this.updateSendButton()})}if (sendBtn) {sendBtn.addEventListener('click',() => this.sendMessage())}if (resizeHandle) {resizeHandle.addEventListener('mousedown',(e) => this.startResize(e))}document.addEventListener('mousemove',(e) => this.handleResize(e)); document.addEventListener('mouseup',() => this.stopResize()); document.addEventListener('click',(e) => {if (this.currentEmojiPicker && !e.target.closest('.emoji-picker') && !e.target.closest('.message-item')) {this.hideEmojiPicker()}}); window.addEventListener('resize',() => {this.maxHeight = window.innerHeight * 0.8; this.constrainHeight()})}setupWalletIntegration() {document.addEventListener('walletConnected',(event) => {this.onWalletConnected(event.detail)}); document.addEventListener('walletDisconnected',() => {this.onWalletDisconnected()}); this.checkWalletConnection(); this.walletCheckInterval = setInterval(() => {this.checkWalletConnection()},2000)}checkWalletConnection() {const isConnected = window.state && window.state.connectedAddress; const currentAddress = isConnected ? window.state.connectedAddress : null; if (isConnected && !this.currentUser) {this.onWalletConnected({address: currentAddress,isQuickWallet: false })}else if (!isConnected && this.currentUser) {this.onWalletDisconnected()}else if (isConnected && this.currentUser && currentAddress !== this.currentUser.address) {this.onWalletConnected({address: currentAddress,isQuickWallet: false })}}onWalletConnected(walletInfo) {this.currentUser = {address: walletInfo.address,shortAddress: this.shortenAddress(walletInfo.address),isQuickWallet: walletInfo.isQuickWallet || false,joinedAt: new Date().toISOString() }; this.updateUserInterface(); this.enableChat(); this.addToPresence(); this.addSystemMessage(`${this.currentUser.shortAddress}joined the chat`)}onWalletDisconnected() {if (this.currentUser) {this.addSystemMessage(`${this.currentUser.shortAddress}left the chat`); this.removeFromPresence()}this.currentUser = null; this.updateUserInterface(); this.disableChat()}updateUserInterface() {const userBadge = document.querySelector('.user-badge'); const statusElement = document.getElementById('trollbox-status'); if (this.currentUser) {if (userBadge) {userBadge.textContent = this.currentUser.shortAddress; userBadge.className = 'user-badge'}if (statusElement) {statusElement.textContent = 'Ready to chat'}}else {if (userBadge) {userBadge.textContent = 'Anonymous'; userBadge.className = 'user-badge anonymous'}if (statusElement) {statusElement.textContent = 'Connect wallet to chat'}}}enableChat() {const input = document.getElementById('trollbox-input'); const sendBtn = document.getElementById('trollbox-send'); if (input) {input.disabled = false; input.placeholder = 'Type your message... (Enter to send)'}this.updateSendButton()}disableChat() {const input = document.getElementById('trollbox-input'); const sendBtn = document.getElementById('trollbox-send'); if (input) {input.disabled = true; input.placeholder = 'Connect wallet to chat'; input.value = ''}if (sendBtn) {sendBtn.disabled = true}}updateSendButton() {const input = document.getElementById('trollbox-input'); const sendBtn = document.getElementById('trollbox-send'); if (sendBtn && input) {const hasText = input.value.trim().length > 0; const canSend = hasText && this.currentUser && !this.isRateLimited(); sendBtn.disabled = !canSend}}async sendMessage() {const input = document.getElementById('trollbox-input'); if (!input || !this.currentUser) return; const message = input.value.trim(); if (!message) return; if (this.isRateLimited()) {this.showRateLimitWarning(); return}const contentCheck = this.checkMessageContent(message); if (!contentCheck.allowed) {this.showContentFilterWarning(contentCheck.reason); input.value = ''; return}try {const messageData = {text: message,author: this.currentUser.shortAddress,authorAddress: this.currentUser.address,timestamp: window.firebase.firestore.FieldValue.serverTimestamp(),isQuickWallet: this.currentUser.isQuickWallet || false }; await this.messagesRef.add(messageData); input.value = ''; this.updateSendButton(); this.updateRateLimit()}catch (error) {console.error('Failed to send message:',error); let errorMessage = 'Failed to send message. '; if (error.code === 'permission-denied') {errorMessage += 'Message blocked by content filter.'}else if (error.code === 'unavailable') {errorMessage += 'Connection issue. Please try again.'}else {errorMessage += 'Please try again.'}this.addSystemMessage(errorMessage,'error-message')}}checkMessageContent(text) {if (text.length < TROLLBOX_CONTENT_RULES.minLength) {return {allowed: false,reason: `Message too short (min ${TROLLBOX_CONTENT_RULES.minLength}characters)` }}if (text.length > TROLLBOX_CONTENT_RULES.maxLength) {return {allowed: false,reason: `Message too long (max ${TROLLBOX_CONTENT_RULES.maxLength}characters)` }}for (const rule of TROLLBOX_CONTENT_RULES.blockedPatterns) {if (rule.pattern.test(text)) {return {allowed: false,reason: rule.reason }}}return {allowed: true }}showContentFilterWarning(reason) {this.addSystemMessage(` Message blocked: ${reason}`,'content-filter-warning')}isRateLimited() {const now = Date.now(); if (now - this.lastMessageTime > this.rateLimitWindow) {this.messageCount = 0}return this.messageCount >= this.maxMessagesPerWindow}updateRateLimit() {const now = Date.now(); if (now - this.lastMessageTime > this.rateLimitWindow) {this.messageCount = 0}this.messageCount++; this.lastMessageTime = now}showRateLimitWarning() {this.addSystemMessage('Slow down! Too many messages. Please wait before sending another.','rate-limit-warning')}async loadRecentMessages() {if (!this.messagesRef) return; try {const snapshot = await this.messagesRef .orderBy('timestamp','desc') .limit(50) .get(); const messages = []; let latestTimestamp = this.lastSeenTimestamp; let oldestTimestamp = null; snapshot.forEach(doc => {const message = {id: doc.id,...doc.data() }; const messageTime = message.timestamp ? (message.timestamp.toDate ? message.timestamp.toDate().getTime() : message.timestamp.seconds * 1000) : Date.now(); if (!oldestTimestamp || messageTime < oldestTimestamp) {oldestTimestamp = messageTime}if (messageTime > latestTimestamp) {latestTimestamp = messageTime}messages.unshift(message); this.markMessageAsDisplayed(message.id)}); this.oldestLoadedTimestamp = oldestTimestamp; this.totalLoadedMessages = messages.length; messages.forEach(message => {this.displayMessage(message,false)}); if (latestTimestamp > this.lastSeenTimestamp) {this.saveLastSeenTimestamp(latestTimestamp)}this.setupRealtimeListener(); this.setupRealtimeReactionListener(); this.setupScrollPagination(); this.initialLoadComplete = true}catch (error) {console.error('Failed to load messages:',error); this.showStatus('Failed to load chat history.')}}setupRealtimeListener() {if (!this.messagesRef) return; const cutoffTime = new Date(this.lastSeenTimestamp); this.unsubscribe = this.messagesRef .where('timestamp','>',cutoffTime) .orderBy('timestamp','asc') .onSnapshot((snapshot) => {snapshot.docChanges().forEach((change) => {if (change.type === 'added') {const message = {id: change.doc.id,...change.doc.data() }; const messageTime = message.timestamp ? (message.timestamp.toDate ? message.timestamp.toDate().getTime() : message.timestamp.seconds * 1000) : Date.now(); if (!this.hasDisplayedMessage(message.id)) {const isGenuinelyNew = this.initialLoadComplete && messageTime > this.lastSeenTimestamp; this.displayMessage(message,isGenuinelyNew); if (isGenuinelyNew) {this.handleNewMessage(message); if (messageTime > this.lastSeenTimestamp) {this.saveLastSeenTimestamp(messageTime)}}this.markMessageAsDisplayed(message.id)}}})},(error) => {console.error('Real-time listener error:',error); this.showStatus('Connection lost. Refresh to reconnect.')})}setupScrollPagination() {const messagesContainer = document.getElementById('trollbox-messages'); if (!messagesContainer) return; let isLoading = false; messagesContainer.addEventListener('scroll',async () => {if (messagesContainer.scrollTop <= 50 && !isLoading && this.oldestLoadedTimestamp) {isLoading = true; const loadingMsg = document.createElement('div'); loadingMsg.className = 'system-message loading-more'; loadingMsg.innerHTML = '<i class="bi bi-hourglass-split"></i> Loading more messages...'; messagesContainer.insertBefore(loadingMsg,messagesContainer.firstChild); try {const oldScrollHeight = messagesContainer.scrollHeight; await this.loadMoreMessages(); const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop = newScrollHeight - oldScrollHeight + messagesContainer.scrollTop}catch (error) {console.error('Failed to load more messages:',error)}loadingMsg.remove(); isLoading = false}})}async loadMoreMessages() {if (!this.messagesRef || !this.oldestLoadedTimestamp) return; try {const snapshot = await this.messagesRef .where('timestamp','<',new Date(this.oldestLoadedTimestamp)) .orderBy('timestamp','desc') .limit(50) .get(); if (snapshot.empty) {return}const messages = []; let newOldestTimestamp = this.oldestLoadedTimestamp; snapshot.forEach(doc => {const message = {id: doc.id,...doc.data() }; const messageTime = message.timestamp ? (message.timestamp.toDate ? message.timestamp.toDate().getTime() : message.timestamp.seconds * 1000) : Date.now(); if (messageTime < newOldestTimestamp) {newOldestTimestamp = messageTime}messages.unshift(message); this.markMessageAsDisplayed(message.id)}); this.oldestLoadedTimestamp = newOldestTimestamp; this.totalLoadedMessages += messages.length; const messagesContainer = document.getElementById('trollbox-messages'); if (messagesContainer) {messages.forEach(message => {const messageElement = this.createMessageElement(message); messagesContainer.insertBefore(messageElement,messagesContainer.firstChild)})}}catch (error) {console.error('Failed to load more messages:',error)}}createMessageElement(message) {const messageElement = document.createElement('div'); messageElement.className = 'message'; messageElement.setAttribute('data-message-id',message.id); if (message.isAdmin) {messageElement.classList.add('admin-message')}if (this.currentUser && message.authorAddress === this.currentUser.address) {messageElement.classList.add('own-message')}const timestamp = message.timestamp ? (message.timestamp.toDate ? message.timestamp.toDate() : new Date(message.timestamp.seconds * 1000)) : new Date(); const now = new Date(); const isToday = timestamp.toDateString() === now.toDateString(); const isYesterday = timestamp.toDateString() === new Date(now.getTime() - 24 * 60 * 60 * 1000).toDateString(); let timeString; if (isToday) {timeString = timestamp.toLocaleTimeString([],{hour: '2-digit',minute: '2-digit' })}else if (isYesterday) {timeString = 'Yesterday ' + timestamp.toLocaleTimeString([],{hour: '2-digit',minute: '2-digit' })}else {timeString = timestamp.toLocaleDateString([],{day: '2-digit',month: '2-digit' }) + ' ' + timestamp.toLocaleTimeString([],{hour: '2-digit',minute: '2-digit' })}let authorDisplay = message.author; let adminBadge = ''; if (message.isAdmin) {authorDisplay = 'Admin'; adminBadge = '<span class="admin-badge"><i class="bi bi-shield-check-fill"></i></span>'}messageElement.innerHTML = ` <div class="message-header"> <span class="message-author ${message.isAdmin ? 'admin-author' : 'clickable-username'}" ${!message.isAdmin ? `data-address="${message.authorAddress}" title="Click to view ${message.author}'s trading profile"` : ''}> ${authorDisplay}</span> ${adminBadge}<span class="message-time">${timeString}</span> </div> <div class="message-content">${this.sanitizeMessage(message.text)}</div> <div class="message-reactions" id="reactions-${message.id}"> ${this.renderReactions(message.reactions || {})}</div> `; if (!message.isAdmin) {const usernameElement = messageElement.querySelector('.clickable-username'); if (usernameElement) {usernameElement.addEventListener('click',() => {const address = usernameElement.getAttribute('data-address'); if (address) {window.open(`userBrowser.html?address=${encodeURIComponent(address)}`,'_blank')}})}}if (this.currentUser) {const messageContentDiv = messageElement.querySelector('.message-content'); if (messageContentDiv) {messageContentDiv.addEventListener('click',(e) => {e.stopPropagation(); this.showEmojiPicker(message.id,messageElement)}); messageContentDiv.style.cursor = 'pointer'; messageContentDiv.title = 'Click to react with emoji'}}return messageElement}displayMessage(message,isNew = false) {const messagesContainer = document.getElementById('trollbox-messages'); if (!messagesContainer) return; const messageElement = document.createElement('div'); messageElement.className = 'message'; messageElement.setAttribute('data-message-id',message.id); if (isNew) {messageElement.classList.add('new-message')}if (message.isAdmin) {messageElement.classList.add('admin-message')}if (this.currentUser && message.authorAddress === this.currentUser.address) {messageElement.classList.add('own-message')}const timestamp = message.timestamp ? (message.timestamp.toDate ? message.timestamp.toDate() : new Date(message.timestamp.seconds * 1000)) : new Date(); const now = new Date(); const isToday = timestamp.toDateString() === now.toDateString(); const isYesterday = timestamp.toDateString() === new Date(now.getTime() - 24 * 60 * 60 * 1000).toDateString(); let timeString; if (isToday) {timeString = timestamp.toLocaleTimeString([],{hour: '2-digit',minute: '2-digit' })}else if (isYesterday) {timeString = 'Yesterday ' + timestamp.toLocaleTimeString([],{hour: '2-digit',minute: '2-digit' })}else {timeString = timestamp.toLocaleDateString([],{day: '2-digit',month: '2-digit' }) + ' ' + timestamp.toLocaleTimeString([],{hour: '2-digit',minute: '2-digit' })}let authorDisplay = message.author; let adminBadge = ''; if (message.isAdmin) {authorDisplay = 'Admin'; adminBadge = '<span class="admin-badge"><i class="bi bi-shield-check-fill"></i></span>'}messageElement.innerHTML = ` <div class="message-header"> <span class="message-author ${message.isAdmin ? 'admin-author' : 'clickable-username'}" ${!message.isAdmin ? `data-address="${message.authorAddress}" title="Click to view ${message.author}'s trading profile"` : ''}> ${authorDisplay}</span> ${adminBadge}<span class="message-time">${timeString}</span> </div> <div class="message-content">${this.sanitizeMessage(message.text)}</div> <div class="message-reactions" id="reactions-${message.id}"> ${this.renderReactions(message.reactions || {})}</div> `; if (!message.isAdmin) {const usernameElement = messageElement.querySelector('.clickable-username'); if (usernameElement) {usernameElement.addEventListener('click',() => {const address = usernameElement.getAttribute('data-address'); if (address) {const userBrowserUrl = `userBrowser.html?address=${encodeURIComponent(address)}`; window.open(userBrowserUrl,'_blank')}})}}if (this.currentUser) {const messageContentDiv = messageElement.querySelector('.message-content'); if (messageContentDiv) {messageContentDiv.addEventListener('click',(e) => {e.stopPropagation(); this.showEmojiPicker(message.id,messageElement)}); messageContentDiv.style.cursor = 'pointer'; messageContentDiv.title = 'Click to react with emoji'}}messagesContainer.appendChild(messageElement); if (isNew) {messagesContainer.scrollTop = messagesContainer.scrollHeight}}addSystemMessage(text,className = '') {const messagesContainer = document.getElementById('trollbox-messages'); if (!messagesContainer) return; const messageElement = document.createElement('div'); messageElement.className = `system-message ${className}`; messageElement.innerHTML = `<i class="bi bi-info-circle"></i> ${text}`; messagesContainer.appendChild(messageElement); messagesContainer.scrollTop = messagesContainer.scrollHeight}handleNewMessage(message) {if (this.currentUser && message.authorAddress === this.currentUser.address) {return}if (this.isMinimized || this.isHidden) {this.unreadCount++; this.updateNotificationBadge()}}updateNotificationBadge() {const badge = document.getElementById('chat-notification'); const toggleBtn = document.getElementById('trollbox-toggle'); if (this.unreadCount > 0) {if (badge) {badge.textContent = Math.min(this.unreadCount,99); badge.style.display = 'flex'}if (toggleBtn) {toggleBtn.style.animation = 'pulse 2s infinite'}}else {if (badge) {badge.style.display = 'none'}if (toggleBtn) {toggleBtn.style.animation = ''}}}sanitizeMessage(text) {const div = document.createElement('div'); div.textContent = text; let sanitized = div.innerHTML; sanitized = sanitized.replace( /(https?:\/\/[^\s]+)/g,'<a href="$1" target="_blank" rel="noopener">$1</a>' ); return sanitized}shortenAddress(address) {if (!address) return 'Anonymous'; return `${address.slice(0,6)}...${address.slice(-4)}`}show() {const widget = document.getElementById('trollbox-widget'); const toggle = document.getElementById('trollbox-toggle'); if (widget) {widget.classList.remove('hidden'); this.isHidden = false}if (toggle) {toggle.style.display = 'none'}this.unreadCount = 0; this.updateNotificationBadge(); this.saveLastSeenTimestamp(Date.now()); if (window.uiStateManager) {window.uiStateManager.saveState('trollbox_visible',true)}setTimeout(() => {let shouldBeMinimized = false; if (window.uiStateManager) {shouldBeMinimized = window.uiStateManager.loadState('trollbox_minimized')}if (shouldBeMinimized) {this.minimize()}else {this.loadSavedHeight()}const messages = document.getElementById('trollbox-messages'); if (messages) {messages.scrollTop = messages.scrollHeight}},200)}hide() {const widget = document.getElementById('trollbox-widget'); const toggle = document.getElementById('trollbox-toggle'); if (widget) {widget.classList.add('hidden'); this.isHidden = true}if (toggle) {toggle.style.display = 'flex'}localStorage.setItem('trollbox_dismissed','true'); if (window.uiStateManager) {window.uiStateManager.saveState('trollbox_visible',false)}}minimize() {const widget = document.getElementById('trollbox-widget'); const content = document.getElementById('trollbox-content'); if (widget && content) {if (!this.isMinimized) {this.savedHeight = widget.offsetHeight}widget.classList.add('minimized'); this.isMinimized = true; widget.style.height = ''}if (window.uiStateManager) {window.uiStateManager.saveState('trollbox_minimized',true)}}restore() {const widget = document.getElementById('trollbox-widget'); const content = document.getElementById('trollbox-content'); if (widget && content) {widget.classList.remove('minimized'); this.isMinimized = false; if (this.savedHeight) {const constrainedHeight = Math.max(this.minHeight,Math.min(this.savedHeight,this.maxHeight)); widget.style.height = constrainedHeight + 'px'}else {this.loadSavedHeight()}this.unreadCount = 0; this.updateNotificationBadge(); this.saveLastSeenTimestamp(Date.now())}if (window.uiStateManager) {window.uiStateManager.saveState('trollbox_minimized',false)}}toggleMinimize() {if (this.isMinimized) {this.restore()}else {this.minimize()}}showStatus(message) {const statusElement = document.getElementById('trollbox-status'); if (statusElement) {statusElement.textContent = message; statusElement.style.color = '#ff4757'; setTimeout(() => {this.updateUserInterface()},3000)}}destroy() {if (this.unsubscribe) {this.unsubscribe()}if (this.reactionUnsubscribe) {this.reactionUnsubscribe()}if (this.walletCheckInterval) {clearInterval(this.walletCheckInterval)}if (this.presenceUnsubscribe) {this.presenceUnsubscribe()}if (this.currentUser) {this.removeFromPresence()}this.hideEmojiPicker()}setupPresenceSystem() {if (!this.db) {return}this.presenceRef = this.db.collection('trollbox_presence'); this.presenceUnsubscribe = this.presenceRef .where('lastSeen','>',Date.now() - 120000) .onSnapshot((snapshot) => {const onlineCount = snapshot.size; this.updateOnlineCount(onlineCount)},(error) => {console.error('Presence listener error:',error); setTimeout(() => {this.setupPresenceSystem()},5000)}); setInterval(() => {this.cleanupOldPresence()},30000)}updateOnlineCount(count) {const onlineCountElement = document.getElementById('online-count'); if (onlineCountElement) {onlineCountElement.textContent = `${count}online`}}async addToPresence() {if (!this.presenceRef || !this.currentUser) {return}try {const presenceData = {address: this.currentUser.address,shortAddress: this.currentUser.shortAddress,isQuickWallet: this.currentUser.isQuickWallet || false,lastSeen: Date.now(),joinedAt: Date.now() }; await this.presenceRef.doc(this.currentUser.address).set(presenceData); if (this.presenceInterval) {clearInterval(this.presenceInterval)}this.presenceInterval = setInterval(async () => {if (this.currentUser && this.presenceRef) {try {await this.presenceRef.doc(this.currentUser.address).update({lastSeen: Date.now() })}catch (error) {console.error('Error updating presence:',error)}}},30000)}catch (error) {console.error('Error adding to presence:',error)}}async removeFromPresence() {if (!this.presenceRef || !this.currentUser) {return}try {await this.presenceRef.doc(this.currentUser.address).delete(); if (this.presenceInterval) {clearInterval(this.presenceInterval); this.presenceInterval = null}}catch (error) {console.error('Error removing from presence:',error)}}async cleanupOldPresence() {if (!this.presenceRef) return; try {const cutoffTime = Date.now() - 180000; const oldPresence = await this.presenceRef .where('lastSeen','<',cutoffTime) .get(); if (!oldPresence.empty) {const batch = this.db.batch(); oldPresence.forEach(doc => {batch.delete(doc.ref)}); await batch.commit()}}catch (error) {console.error('Error cleaning up old presence:',error)}}hasDisplayedMessage(messageId) {return this.displayedMessages.has(messageId)}markMessageAsDisplayed(messageId) {this.displayedMessages.add(messageId); if (this.displayedMessages.size > 200) {const idsArray = Array.from(this.displayedMessages); this.displayedMessages.clear(); idsArray.slice(-100).forEach(id => this.displayedMessages.add(id))}}renderReactions(reactions) {if (!reactions || Object.keys(reactions).length === 0) {return ''}const reactionElements = []; this.availableEmojis.forEach(emojiData => {const reactionData = reactions[emojiData.name]; if (reactionData && reactionData.count > 0) {const isUserReacted = this.currentUser && reactionData.users && reactionData.users.includes(this.currentUser.address); const userClass = isUserReacted ? 'user-reacted' : ''; const usersList = reactionData.users ? reactionData.users.map(addr => this.shortenAddress(addr)).join(',') : ''; reactionElements.push(` <span class="reaction-item ${userClass}" data-reaction="${emojiData.name}" title="${emojiData.label}: ${usersList}"> ${emojiData.emoji}${reactionData.count}</span> `)}}); return reactionElements.join('')}showEmojiPicker(messageId,messageElement) {this.hideEmojiPicker(); const picker = document.createElement('div'); picker.className = 'emoji-picker'; picker.innerHTML = ` <div class="emoji-picker-content"> ${this.availableEmojis.map(emoji => ` <button class="emoji-button" data-emoji="${emoji.name}" title="${emoji.label}"> ${emoji.emoji}</button> `).join('')}</div> `; const messageRect = messageElement.getBoundingClientRect(); const container = document.getElementById('trollbox-messages'); const containerRect = container.getBoundingClientRect(); picker.style.position = 'absolute'; picker.style.top = (messageRect.top - containerRect.top + container.scrollTop - 50) + 'px'; picker.style.left = (messageRect.left - containerRect.left + 10) + 'px'; picker.style.zIndex = '1000'; picker.querySelectorAll('.emoji-button').forEach(button => {button.addEventListener('click',(e) => {e.stopPropagation(); const emojiName = button.getAttribute('data-emoji'); this.toggleReaction(messageId,emojiName); this.hideEmojiPicker()})}); container.appendChild(picker); this.currentEmojiPicker = picker; setTimeout(() => {this.hideEmojiPicker()},5000)}hideEmojiPicker() {if (this.currentEmojiPicker) {this.currentEmojiPicker.remove(); this.currentEmojiPicker = null}}async toggleReaction(messageId,emojiName) {if (!this.currentUser || !this.messagesRef) {console.warn('Cannot react: user not connected or Firebase not available'); return}try {const messageRef = this.messagesRef.doc(messageId); const messageDoc = await messageRef.get(); if (!messageDoc.exists) {console.warn('Message not found'); return}const messageData = messageDoc.data(); const reactions = messageData.reactions || {}; const userAddress = this.currentUser.address; if (!reactions[emojiName]) {reactions[emojiName] = {count: 0,users: [] }}const userIndex = reactions[emojiName].users.indexOf(userAddress); if (userIndex === -1) {reactions[emojiName].users.push(userAddress); reactions[emojiName].count++}else {reactions[emojiName].users.splice(userIndex,1); reactions[emojiName].count--; if (reactions[emojiName].count === 0) {delete reactions[emojiName]}}await messageRef.update({reactions }); this.updateReactionDisplay(messageId,reactions)}catch (error) {console.error('Failed to toggle reaction:',error); if (error.code === 'permission-denied') {this.addSystemMessage(' Unable to react to messages. Please check your connection.','error-message')}}}updateReactionDisplay(messageId,reactions) {const reactionsContainer = document.getElementById(`reactions-${messageId}`); if (reactionsContainer) {const reactionsHtml = this.renderReactions(reactions); reactionsContainer.innerHTML = reactionsHtml; if (reactionsHtml.trim() === '') {reactionsContainer.style.display = 'none'}else {reactionsContainer.style.display = 'flex'; reactionsContainer.querySelectorAll('.reaction-item').forEach(item => {item.addEventListener('click',(e) => {e.stopPropagation(); const reactionName = item.getAttribute('data-reaction'); this.toggleReaction(messageId,reactionName)}); item.style.cursor = 'pointer'})}}}setupRealtimeReactionListener() {if (!this.messagesRef) return; this.reactionUnsubscribe = this.messagesRef.onSnapshot((snapshot) => {snapshot.docChanges().forEach((change) => {if (change.type === 'modified') {const message = {id: change.doc.id,...change.doc.data() }; if (this.hasDisplayedMessage(message.id)) {this.updateReactionDisplay(message.id,message.reactions || {})}}})},(error) => {console.error('Reaction listener error:',error)})}startResize(e) {if (window.innerWidth <= 768) return; this.isResizing = true; this.startY = e.clientY; const widget = document.getElementById('trollbox-widget'); if (widget) {this.startHeight = widget.offsetHeight; widget.classList.add('resizing')}e.preventDefault()}handleResize(e) {if (!this.isResizing) return; const widget = document.getElementById('trollbox-widget'); if (!widget) return; const deltaY = this.startY - e.clientY; const newHeight = this.startHeight + deltaY; const constrainedHeight = Math.max(this.minHeight,Math.min(newHeight,this.maxHeight)); widget.style.height = constrainedHeight + 'px'; e.preventDefault()}stopResize() {if (!this.isResizing) return; this.isResizing = false; const widget = document.getElementById('trollbox-widget'); if (widget) {widget.classList.remove('resizing'); const currentHeight = widget.offsetHeight; this.savedHeight = currentHeight; if (window.uiStateManager) {window.uiStateManager.saveState('trollbox_height',currentHeight)}else {localStorage.setItem('trollbox_height',currentHeight.toString())}}}constrainHeight() {const widget = document.getElementById('trollbox-widget'); if (!widget || this.isMinimized) return; const currentHeight = widget.offsetHeight; const constrainedHeight = Math.max(this.minHeight,Math.min(currentHeight,this.maxHeight)); if (constrainedHeight !== currentHeight) {widget.style.height = constrainedHeight + 'px'; this.savedHeight = constrainedHeight}}loadSavedHeight() {if (this.isMinimized) {return}let savedHeight = null; if (window.uiStateManager) {savedHeight = window.uiStateManager.loadState('trollbox_height')}if (!savedHeight) {const localStorageHeight = localStorage.getItem('trollbox_height'); if (localStorageHeight) {savedHeight = parseInt(localStorageHeight,10)}}if (savedHeight && typeof savedHeight === 'number' && savedHeight > 0) {this.savedHeight = savedHeight; const widget = document.getElementById('trollbox-widget'); if (widget) {const constrainedHeight = Math.max(this.minHeight,Math.min(savedHeight,this.maxHeight)); widget.style.height = constrainedHeight + 'px'}}}getLastSeenTimestamp() {try {const stored = localStorage.getItem('trollbox_last_seen'); return stored ? parseInt(stored) : Date.now() - (24 * 60 * 60 * 1000)}catch (error) {console.warn('Failed to load last seen timestamp:',error); return Date.now() - (24 * 60 * 60 * 1000)}}saveLastSeenTimestamp(timestamp) {try {localStorage.setItem('trollbox_last_seen',timestamp.toString()); this.lastSeenTimestamp = timestamp}catch (error) {console.warn('Failed to save last seen timestamp:',error)}}resetMessageTracking() {this.displayedMessages.clear(); this.saveLastSeenTimestamp(Date.now()); this.unreadCount = 0; this.updateNotificationBadge(); try {localStorage.removeItem('trollbox_last_seen')}catch (error) {console.warn('Failed to clear localStorage:',error)}}}window.odetteTrollbox = new OdetteTrollbox(); window.addEventListener('beforeunload',() => {if (window.odetteTrollbox) {window.odetteTrollbox.destroy()}}); if (!document.querySelector('#trollbox-pulse-style')) {const style = document.createElement('style'); style.id = 'trollbox-pulse-style'; style.textContent = ` @keyframes pulse {0%,100% {transform: scale(1)}50% {transform: scale(1.05)}}`; document.head.appendChild(style)}function showNotification(message,type = 'info',txHash = null) {let container = document.getElementById('simple-notification-container'); if (!container) {container = document.createElement('div'); container.id = 'simple-notification-container'; container.className = 'simple-notification-container'; container.style.cssText = ` position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px; `; document.body.appendChild(container)}const notification = document.createElement('div'); notification.className = `alert alert-${type === 'error' ? 'danger' : type}alert-dismissible fade show mb-2`; notification.style.cssText = ` box-shadow: 0 4px 12px rgba(0,0,0,0.15); border: none; border-radius: 8px; margin-bottom: 10px; animation: slideInRight 0.3s ease-out; `; let icon = ''; switch (type) {case 'success': icon = '<i class="bi bi-check-circle-fill me-2"></i>'; break; case 'error': icon = '<i class="bi bi-x-circle-fill me-2"></i>'; break; case 'warning': icon = '<i class="bi bi-exclamation-triangle-fill me-2"></i>'; break; default: icon = '<i class="bi bi-info-circle-fill me-2"></i>'}let explorerLink = ''; if (txHash) {const basescanUrl = `https: explorerLink = ` <div class="mt-2"> <a href="${basescanUrl}" target="_blank" class="btn btn-sm btn-outline-primary"> <i class="bi bi-box-arrow-up-right me-1"></i>View on Basescan </a> </div> `}notification.innerHTML = ` ${icon}<span>${message}</span> ${explorerLink}<button type="button" class="btn-close" data-bs-dismiss="alert"></button> `; container.appendChild(notification); setTimeout(() => {if (notification.parentNode) {notification.remove()}},5000); const closeBtn = notification.querySelector('.btn-close'); if (closeBtn) {closeBtn.addEventListener('click',() => {notification.remove()})}}if (!document.getElementById('simple-notification-styles')) {const style = document.createElement('style'); style.id = 'simple-notification-styles'; style.textContent = ` @keyframes slideInRight {from {transform: translateX(100%); opacity: 0}to {transform: translateX(0); opacity: 1}}.balance-text.loading {color: #6c757d; font-style: italic; animation: pulse 1.5s ease-in-out infinite}.balance-text.no-balance {color: #dc3545; font-weight: 500}label[data-balance*="Loading..."] {color: #6c757d !important; font-style: italic !important; animation: pulse 1.5s ease-in-out infinite !important}label[data-balance*="Error"] {color: #dc3545 !important; font-weight: 500 !important}@keyframes pulse {0%,100% {opacity: 1}50% {opacity: 0.6}}`; document.head.appendChild(style)}async function refreshData(isInitialLoad = false) {if (state.isRefreshing) {console.log('refreshData already in progress,skipping...'); return}state.isRefreshing = true; try {console.log(`refreshData called,isInitialLoad: ${isInitialLoad}`); if ($('#advanced-view-container').is(':visible')) {lastSelectedSliderPosition = parseInt($('#adv-conviction-slider').val())}else {lastSelectedSliderPosition = parseInt($('#conviction-slider').val())}const response = await fetch(MARKET_DATA_API); const data = await response.json(); const apiExpiry = getExpiryFromAPI(data.data.orders); if (apiExpiry) {state.expiryTime = apiExpiry}if (state.expiryTime) {const expiryTimestampSeconds = Math.floor(state.expiryTime / 1000); $('#option-expiry') .attr('data-countdown-expiry',expiryTimestampSeconds) .data('expiry',expiryTimestampSeconds); const expiryDate = new Date(state.expiryTime); const hours = expiryDate.getUTCHours().toString().padStart(2,'0'); const minutes = expiryDate.getUTCMinutes().toString().padStart(2,'0'); $('#expiry-time').text(`${hours}:${minutes}UTC EXPIRY`)}else {$('#option-expiry').text('--:--:--').removeAttr('data-countdown-expiry'); $('#expiry-time').text(`UNKNOWN EXPIRY`)}if (data.data.market_data) {state.market_prices = data.data.market_data; const currentAssetPrice = state.market_prices[state.selectedAsset]; if (currentAssetPrice) {updateDualUI('current-price',currentAssetPrice,'text',formatNumber)}if (typeof updateETHBalance === 'function') {updateETHBalance()}}state.orders = data.data.orders; const filteredOrders = state.orders.filter(order => {return CONFIG.getUnderlyingAsset(order.order.priceFeed) === state.selectedAsset}); state.orders = filteredOrders; state.orders.sort((a,b) => {const expiryA = parseInt(a.order.expiry) || 0; const expiryB = parseInt(b.order.expiry) || 0; return expiryA - expiryB}); console.log('Orders sorted by expiry,first few strikes:',state.orders.slice(0,3).map((order,i) => ({index: i,strike: formatUnits(order.order.strikes[0],PRICE_DECIMALS),expiry: new Date(parseInt(order.order.expiry) * 1000).toISOString() }))); updateCountdowns(); setupConvictionSlider(); if (typeof populateOptionsTable === 'function') {populateOptionsTable()}if (typeof populateExpiryButtons === 'function') {populateExpiryButtons()}if ($('#positions-section').is(':visible')) {refreshPositions()}if (isInitialLoad || $('#positions-section').is(':visible')) {await updateLiquidityInfo()}if (isInitialLoad || $('#positions-section').is(':visible')) {updateWalletBalance()}if (isInitialLoad && typeof updateETHBalance === 'function') {updateETHBalance()}if (isNearExpiry()) {$('.expiry-warning').show()}else {$('.expiry-warning').hide()}}catch (error) {console.error('Error refreshing data:',error)}finally {state.isRefreshing = false}}function populateOptionsTable() {if (window.isPopulatingTable) {return}window.isPopulatingTable = true; populateExpiryButtons(); const tableBody = $('#options-table-body'); if (!tableBody.length) {console.error('Options table body not found'); return}tableBody.empty(); if (!state.orders || state.orders.length === 0) {console.warn('No orders available to populate table'); tableBody.html('<tr><td colspan="9" class="text-center text-muted">No options available</td></tr>'); return}let filteredOrders = state.orders; if (state.selectedExpiry) {filteredOrders = filteredOrders.filter(order => {return parseInt(order.order.expiry) === state.selectedExpiry})}if (state.selectedStrike) {filteredOrders = filteredOrders.filter(order => {const strike = formatUnits(order.order.strikes[0],PRICE_DECIMALS); return parseFloat(strike) === parseFloat(state.selectedStrike)})}if (filteredOrders.length === 0) {tableBody.html('<tr><td colspan="9" class="text-center text-muted">No options match the selected filters</td></tr>'); updateTableFilterInfo(); return}for (let i = 0; i < filteredOrders.length; i++) {const order = filteredOrders[i].order; const originalIndex = state.orders.findIndex(o => o === filteredOrders[i]); if (!order || !order.strikes || !order.strikes[0]) {console.warn('Skipping invalid order:',order); continue}const optionType = order.isCall ? "CALL" : "PUT"; const collateral = CONFIG.getCollateralDetails(order.collateral); const strike = formatUnits(order.strikes[0],PRICE_DECIMALS); const premium = parseFloat(formatUnits(order.price,PRICE_DECIMALS)); const payoutRatio = optionCalculator.calculateLeverage(premium,order,collateral); const breakeven = optionCalculator.calculateBreakeven(order.isCall,parseFloat(strike),premium).toFixed(2); let theta = 0,delta = 0,iv = 0; if (filteredOrders[i].greeks) {theta = filteredOrders[i].greeks.theta || 0; delta = filteredOrders[i].greeks.delta || 0; iv = filteredOrders[i].greeks.iv || 0}let expiryDisplay = 'N/A'; if (order.expiry && order.expiry !== '0') {try {const orderExpiryTimestamp = parseInt(order.expiry) * 1000; if (!isNaN(orderExpiryTimestamp) && orderExpiryTimestamp > 0) {const expiryDate = new Date(orderExpiryTimestamp); const expiryTimeString = expiryDate.toLocaleTimeString('en-US',{hour12: false,hour: '2-digit',minute: '2-digit',timeZone: 'UTC' }); const expiryDateString = expiryDate.toLocaleDateString('en-US',{month: 'short',day: 'numeric',timeZone: 'UTC' }); expiryDisplay = `${expiryDateString}${expiryTimeString}UTC`}}catch (error) {console.warn('Error formatting expiry date for order:',order,error); expiryDisplay = 'Invalid'}}else {}const row = ` <tr class="option-row ${originalIndex === state.selectedOrderIndex ? 'selected' : ''}" data-index="${originalIndex}"> <td>$${formatNumber(strike)}</td> <td>${optionType}</td> <td title="Expires at ${expiryDisplay}">${expiryDisplay}</td> <td>$${formatNumber(premium)}</td> <td>${payoutRatio}x</td> <td>$${breakeven}</td> <td>${delta.toFixed(2)}</td> <td>${parseInt(iv*100)}%</td> </tr> `; tableBody.append(row)}updateTableFilterInfo(); window.isPopulatingTable = false}function populateExpiryButtons() {if (!state.orders || state.orders.length === 0) return; const container = $('#expiry-buttons-container'); container.empty(); const uniqueExpiries = Array.from(new Set( state.orders .filter(order => order.order && order.order.expiry && order.order.expiry !== '0') .map(order => parseInt(order.order.expiry)) )).filter(expiry => !isNaN(expiry)).sort(); uniqueExpiries.forEach(expiry => {const expiryDate = new Date(expiry * 1000); const expiryTimeString = expiryDate.toLocaleTimeString('en-US',{hour12: false,hour: '2-digit',minute: '2-digit',timeZone: 'UTC' }); const expiryDateString = expiryDate.toLocaleDateString('en-US',{month: 'short',day: 'numeric',timeZone: 'UTC' }); const displayText = `${expiryDateString}${expiryTimeString}UTC`; const button = $(`<button class="expiry-btn" data-expiry="${expiry}">${displayText}</button>`); if (state.selectedExpiry === expiry) {button.addClass('active')}button.on('click',function() {selectExpiry(expiry)}); container.append(button)})}function populateStrikeButtons(expiry) {if (!state.orders || state.orders.length === 0) return; const container = $('#strike-buttons-container'); container.empty(); const expiryOrders = state.orders.filter(order => parseInt(order.order.expiry) === expiry); const callOrders = expiryOrders.filter(order => order.order.isCall); const putOrders = expiryOrders.filter(order => !order.order.isCall); const callStrikes = Array.from(new Set( callOrders .filter(order => order.order && order.order.strikes && order.order.strikes[0]) .map(order => parseFloat(formatUnits(order.order.strikes[0],PRICE_DECIMALS))) )).filter(strike => !isNaN(strike)).sort((a,b) => a - b); const putStrikes = Array.from(new Set( putOrders .filter(order => order.order && order.order.strikes && order.order.strikes[0]) .map(order => parseFloat(formatUnits(order.order.strikes[0],PRICE_DECIMALS))) )).filter(strike => !isNaN(strike)).sort((a,b) => a - b); if (callStrikes.length > 0) {const callLabel = $('<div class="strike-section-label mb-2"><strong>CALL Options</strong></div>'); container.append(callLabel); const callContainer = $('<div class="strike-buttons-row mb-3"></div>'); callStrikes.forEach(strike => {const button = $(`<button class="strike-btn call-strike" data-strike="${strike}">$${formatNumber(strike)}</button>`); if (state.selectedStrike === strike) {button.addClass('active')}button.on('click',function() {selectStrike(strike)}); callContainer.append(button)}); container.append(callContainer)}if (putStrikes.length > 0) {const putLabel = $('<div class="strike-section-label mb-2"><strong>PUT Options</strong></div>'); container.append(putLabel); const putContainer = $('<div class="strike-buttons-row mb-3"></div>'); putStrikes.forEach(strike => {const button = $(`<button class="strike-btn put-strike" data-strike="${strike}">$${formatNumber(strike)}</button>`); if (state.selectedStrike === strike) {button.addClass('active')}button.on('click',function() {selectStrike(strike)}); putContainer.append(button)}); container.append(putContainer)}container.show()}function selectExpiry(expiry) {state.selectedStrike = null; if (state.selectedExpiry === expiry) {state.selectedExpiry = null; $('#strike-buttons-container').hide(); $('.strike-btn').removeClass('active')}else {state.selectedExpiry = expiry; populateStrikeButtons(expiry)}$('.expiry-btn').removeClass('active'); if (state.selectedExpiry) {$(`.expiry-btn[data-expiry="${state.selectedExpiry}"]`).addClass('active')}populateOptionsTable(); updateTableFilterInfo()}function selectStrike(strike) {if (state.selectedStrike === strike) {state.selectedStrike = null}else {state.selectedStrike = strike}$('.strike-btn').removeClass('active'); if (state.selectedStrike) {$(`.strike-btn[data-strike="${state.selectedStrike}"]`).addClass('active')}if (state.selectedStrike) {const matchingOrder = state.orders.find(order => {if (!order.order || !order.order.strikes || !order.order.strikes[0]) return false; const orderStrike = parseFloat(formatUnits(order.order.strikes[0],PRICE_DECIMALS)); return parseFloat(orderStrike) === parseFloat(state.selectedStrike)}); if (matchingOrder) {const orderIndex = state.orders.indexOf(matchingOrder); if (typeof selectOption === 'function') {selectOption(orderIndex)}}}populateOptionsTable(); updateTableFilterInfo()}function updateTableFilterInfo() {let filterText = 'Table sorted by expiry time (earliest first)'; if (state.selectedExpiry) {const expiryDate = new Date(state.selectedExpiry * 1000); const expiryTimeString = expiryDate.toLocaleTimeString('en-US',{hour12: false,hour: '2-digit',minute: '2-digit',timeZone: 'UTC' }); const expiryDateString = expiryDate.toLocaleDateString('en-US',{month: 'short',day: 'numeric',timeZone: 'UTC' }); filterText = `Filtered by expiry: ${expiryDateString}${expiryTimeString}UTC`; if (state.selectedStrike) {filterText += ` | Strike: $${formatNumber(state.selectedStrike)}`}}$('#table-filter-info').text(filterText)}function clearAllFilters() {state.selectedExpiry = null; state.selectedStrike = null; $('.expiry-btn').removeClass('active'); $('.strike-btn').removeClass('active'); $('#strike-buttons-container').hide(); populateOptionsTable()}function setExpiryTime() {const now = new Date(); const expiryDate = new Date(Date.UTC( now.getUTCFullYear(),now.getUTCMonth(),now.getUTCDate(),UTC_EXPIRY_HOUR,0,0,0 )); if (now >= expiryDate) {expiryDate.setUTCDate(expiryDate.getUTCDate() + 1)}state.expiryTime = expiryDate; $('#expiry-time').text(`${UTC_EXPIRY_HOUR}:00 UTC EXPIRY`)}function getTimeToExpiry() {if (!state.expiryTime) return 0; const now = Date.now(); const timeLeftMs = state.expiryTime - now; return Math.max(0,Math.floor(timeLeftMs / 1000))}function isNearExpiry() {const timeLeftSeconds = getTimeToExpiry(); return timeLeftSeconds < TWO_HOURS_IN_SECONDS}function updateCountdowns() {const now = Math.floor(Date.now() / 1000); $('[data-countdown-expiry]').each(function() {const element = $(this); const expiryTime = parseInt(element.attr('data-countdown-expiry'),10); if (isNaN(expiryTime)) {console.warn("Invalid expiry time found for element:",element); return}const timeLeft = expiryTime - now; if (timeLeft <= 0) {element.html('<span class="status-expired">Expired</span>'); element.removeClass('expiring-soon'); element.addClass('is-expired')}else {element.text(formatTimeDisplay(timeLeft)); element.removeClass('is-expired'); if (timeLeft < 300) {element.addClass('expiring-soon')}else {element.removeClass('expiring-soon')}}}); if (state.countDownInterval > 0) {clearInterval(state.countDownInterval)}state.countDownInterval = setTimeout(updateCountdowns,1000)}async function refreshPositions() {try {if (!state.connectedAddress) {console.log("Not connected,can't fetch positions"); return}const fragment = document.createDocumentFragment(); const tempContainer = document.createElement('div'); fragment.appendChild(tempContainer); const userAddress = state.connectedAddress.toLowerCase(); const response = await fetch(`https: method: 'GET',headers: {'Content-Type': 'application/json' }}); if (!response.ok) {throw new Error(`Failed to fetch positions: ${response.status}`)}const data = await response.json(); console.log("Received positions data:",data); state.userPositions = {openPositions: data,historyPositions: [] }; if (!data || data.length === 0) {tempContainer.innerHTML = ` <div class="no-positions-message"> <p>You have no active positions. <a href="#" id="go-to-trade">Start trading now</a>.</p> </div> `}else {tempContainer.innerHTML = ` <h3 class="mb-4">Open Positions</h3> <div id="open-positions" class="mb-5"></div> `; const openPositionsDiv = tempContainer.querySelector('#open-positions'); const processedPositionsPromises = data.map(async (position,index) => {try {const uiPosition = transformPositionForUI(position); return createPositionCard(uiPosition,index,'open')}catch (err) {console.error("Error processing position:",err,position); return ` <div class="alert alert-warning"> Error displaying position ${index}: ${err.message}</div> `}}); const processedPositions = await Promise.all(processedPositionsPromises); openPositionsDiv.innerHTML = processedPositions.join(''); if (openPositionsDiv.children.length === 0) {openPositionsDiv.innerHTML = ` <div class="alert alert-info"> No positions found for the selected asset. Try selecting "ALL" from the dropdown. </div> `}}const positionsContainer = document.getElementById('positions-container'); positionsContainer.innerHTML = ''; positionsContainer.appendChild(fragment); $('#go-to-trade').on('click',function(e) {e.preventDefault(); showSection('trade')}); $('.position-card').on('click',function() {const index = $(this).data('index'); const type = $(this).data('type'); showPositionDetails(index,type)})}catch (error) {console.error("Error refreshing positions:",error); $('#positions-container').html(` <div class="alert alert-danger"> Failed to load positions: ${error.message}</div> `)}}function transformPositionForUI(apiPosition) {try {let asset; if (apiPosition.priceFeed) {for (const [key,value] of Object.entries(CONFIG.priceFeedsMap)) {if (value.toLowerCase() === apiPosition.priceFeed.toLowerCase()) {asset = key; break}}}const collateral = CONFIG.getCollateralDetails(apiPosition.collateralToken); const isCall = apiPosition.optionTypeRaw === 0x0000; const optionTypeDisplay = isCall ? 'CALL' : 'PUT'; const strikePrice = parseFloat(formatUnits(apiPosition.strikes[0],PRICE_DECIMALS)); const entryPremium = apiPosition.entryPremium; const premiumDecimals = apiPosition.collateralDecimals; const cost = parseFloat(formatUnits(entryPremium,premiumDecimals)); const numContracts = apiPosition.numContracts; const payoutRatio = ethers.utils.formatUnits(numContracts,premiumDecimals); const currentPrice = state.market_prices[asset]; return {optionAddress: apiPosition.address,id: apiPosition.entryTxHash,asset: asset,optionType: optionTypeDisplay,optionTypeRaw: apiPosition.optionTypeRaw,strikePrice: strikePrice,cost: cost,collateralSymbol: apiPosition.collateralSymbol,collateralToken: apiPosition.collateralToken,payoutToken: apiPosition.collateralToken,payoutRatio: payoutRatio,currentPrice: currentPrice,timestamp: apiPosition.entryTimestamp * 1000,expiryTime: apiPosition.expiryTimestamp * 1000,status: apiPosition.status || 'open',numContracts: numContracts,estimatedPnl: 0,settlementPrice: apiPosition.settlement.settlementPrice / 1e8 }}catch (err) {console.error("Error in transformPositionForUI:",err,apiPosition); throw err}}async function fetchSettlementTWAP(optionAddress) {try {const {readContract }= WagmiCore; const twapResult = await readContract({address: optionAddress,abi: OPTION_ABI,functionName: 'getTWAP',chainId: 8453 }); return formatUnits(twapResult,PRICE_DECIMALS)}catch (error) {console.error(`Error fetching TWAP for option ${optionAddress}:`,error); return null}}async function createPositionCard(position,index,type) {const strikePrice = parseFloat(position.strikePrice); const settlementPrice = parseFloat(position.settlementPrice || 0); const currentPrice = settlementPrice > 0 ? settlementPrice : parseFloat(position.currentPrice || 0); const isPut = position.optionType === 'PUT'; const isCall = position.optionType === 'CALL'; const isInverseCall = position.optionType === 'INVERSE_CALL'; let statusClass = 'status-negative'; let statusText = ''; let pnlClass = 'pnl-negative'; let pnlText = ''; console.log("Settlement test: ",position.optionAddress,Date.now(),position.expiryTime,position.optionAddress,position.settlementPrice); if (type === 'open') {if (isCall || isInverseCall) {if (currentPrice > strikePrice) {statusClass = 'status-positive'; statusText = 'IN THE MONEY'}else {statusText = `Needs -$${(strikePrice - currentPrice).toFixed(2)}to reach strike`}}else if (isPut) {if (currentPrice < strikePrice) {statusClass = 'status-positive'; statusText = 'IN THE MONEY'}else {statusText = `Needs -$${(currentPrice - strikePrice).toFixed(2)}to reach strike`}}if (settlementPrice > 0) {if (statusClass == 'status-positive') statusText = "EXPIRED ITM"; else statusText = "EXPIRED OTM"}if (position.estimatedPnl) {const pnlAmount = parseFloat(position.estimatedPnl); const pnlPercent = (pnlAmount / position.cost) * 100; if (pnlAmount > 0) {pnlClass = 'pnl-positive'; pnlText = `+$${pnlAmount.toFixed(2)}(${pnlPercent.toFixed(1)}%)`}else {pnlText = `-$${Math.abs(pnlAmount).toFixed(2)}(${Math.abs(pnlPercent).toFixed(1)}%)`}}}else {if (position.status === 'settled' && position.payout > 0) {statusClass = 'status-positive'; statusText = 'PROFIT'; pnlClass = 'pnl-positive'; const pnlAmount = position.payout - position.cost; const pnlPercent = (pnlAmount / position.cost) * 100; pnlText = `+$${pnlAmount.toFixed(2)}(${pnlPercent.toFixed(1)}%)`}else {statusText = 'EXPIRED'; pnlText = `-$${position.cost.toFixed(2)}(100%)`}}let optionTypeDisplay = ''; if (isCall) optionTypeDisplay = 'CALL'; else if (isPut) optionTypeDisplay = 'PUT'; else if (isInverseCall) optionTypeDisplay = 'INVERSE CALL'; let timeDisplay = ''; if (type === 'open') {timeDisplay = `<div class="position-detail-item"> <div class="position-detail-label">Time Left:</div> <div class="position-detail-value countdown" data-expiry="${position.expiryTime}"> ${formatTimeDisplay(Math.max(0,(position.expiryTime - Date.now()) / 1000))}</div> </div>`}else {timeDisplay = `<div class="position-detail-item"> <div class="position-detail-label">Expired:</div> <div class="position-detail-value"> ${new Date(position.expiryTime).toLocaleString()}</div> </div>`}const optionAddress = position.optionAddress; console.log(position); const optionAddressDisplay = optionAddress ? ` <div class="collateral-address"> Fully collateralised with ${parseFloat(position.payoutRatio * (isCall || isInverseCall ? 1 : position.strikePrice)).toFixed(6)}${position.collateralSymbol}held at option contract <a href="https: </div> ` : ''; const expiryTimestampSeconds = Math.floor(position.expiryTime / 1000); const now = Math.floor(Date.now() / 1000); const isExpired = now > expiryTimestampSeconds && !position.settled; let timeRemainingHTML = ` <div class="position-detail-item"> <div class="position-detail-label">Time Left:</div> <div class="position-detail-value"> <span class="countdown" id="position-${type}-${index}-time" data-countdown-expiry="${expiryTimestampSeconds}"> ${isExpired ? '<span class="status-expired">Expired</span>' : formatTimeDisplay(expiryTimestampSeconds - now)}</span> </div> </div> `; return ` <div class="position-card" data-index="${index}" data-type="${type}"> <div class="position-header"> <h4 class="position-title"> ${position.asset}${optionTypeDisplay}@ $${strikePrice.toFixed(2)}<p> ${optionAddressDisplay}</p> </h4> <div> <span class="position-status ${statusClass}">${statusText}</span> <span class="position-pnl ${pnlClass}">${pnlText}</span> </div> </div> <div class="position-details"> <div class="position-detail-item"> <div class="position-detail-label">Cost:</div> <div class="position-detail-value">${position.cost.toFixed(6)}${position.collateralSymbol}</div> </div> <div class="position-detail-item"> <div class="position-detail-label">Payout:</div> <div class="position-detail-value">${parseFloat(position.payoutRatio).toFixed(6)}for each $1 ${isCall || isInverseCall ? 'above' : 'below'}$${strikePrice.toFixed(2)}</div> </div> <div class="position-detail-item"> <div class="position-detail-label">${position.settlementPrice ? 'TWAP Settlement Price:' : 'Current Price:'}</div> <div class="position-detail-value">$${position.settlementPrice ? position.settlementPrice : currentPrice.toFixed(2)}</div> </div> ${timeRemainingHTML}</div> <div class="position-actions"> <button class="btn btn-sm btn-outline-primary position-details-btn" data-position-index="${index}" data-position-type="${type}">View Details</button> </div> </div> `}function showPositionDetails(index,type = 'open') {try {let positions; if (type === 'open') {positions = state.userPositions?.openPositions || []}else {positions = state.userPositions?.historyPositions || []}if (!positions || index < 0 || index >= positions.length) {console.error("Position index out of bounds or positions array empty:",index,type,positions); showNotification("Could not load position details. Position not found.","error"); return}const apiPosition = positions[index]; const position = apiPosition.asset ? apiPosition : transformPositionForUI(apiPosition); console.log("Showing position details for:",position); const optionType = position.optionType || 'CALL'; const strikePrice = position.strikePrice || 0; $('#position-modal-title').text(`${position.asset || 'ETH'}${optionType}@ $${strikePrice.toFixed(2)}`); const cost = position.cost || 0; $('#position-modal-cost').text(`${cost.toFixed(6)}${position.collateralSymbol || 'USDC'}`); const isCall = apiPosition.optionTypeRaw === 0x0000; const directionText = isCall ? 'above' : 'below'; $('#position-modal-payout').text(`${position.payoutRatio || '1.0'}for every $1 ${directionText}$${strikePrice.toFixed(2)}in ${apiPosition.collateralSymbol}`); const timestamp = position.timestamp || Date.now(); $('#position-modal-time').text(new Date(timestamp).toLocaleString()); console.log("position",position,apiPosition); const currentPrice = position.settlementPrice || position.currentPrice; $('#position-modal-current-price').text(`$${currentPrice.toFixed(2)}`); const now = Math.floor(Date.now() / 1000); const expiredButNotSettled = type === 'open' && now > position.expiryTime / 1000 && !position.settled; let statusText = ''; if (type === 'open') {if (expiredButNotSettled) {statusText = 'Expired - Ready to settle'; $('#position-modal-status').html('<span class="status-expired">Expired</span> - Ready to settle'); $('#settle-option-btn').show().data('positionId',apiPosition.entryTxHash || position.id); $('#settle-option-btn').data('positionType',type)}else {const diff = isCall ? strikePrice - currentPrice : currentPrice - strikePrice; if (diff > 0) {statusText = `Needs ${isCall ? '+' : '-'}$${Math.abs(diff).toFixed(2)}to reach strike`}else {statusText = 'IN THE MONEY'}$('#position-modal-status').text(statusText); $('#settle-option-btn').hide()}}else {statusText = position.status === 'settled' && position.payout > 0 ? 'SETTLED WITH PROFIT' : 'EXPIRED WORTHLESS'; $('#position-modal-status').text(statusText); $('#settle-option-btn').hide()}let pnlText = ''; let pnlClass = ''; if (type === 'open') {const inTheMoney = isCall ? Math.max(0,currentPrice - strikePrice) : Math.max(0,strikePrice - currentPrice); const costInDollarTerms = cost * (isCall ? state.market_prices[position.asset] : 1); const numContracts = position.numContracts; const pnlAmount = (inTheMoney * numContracts / (10 ** apiPosition.collateralDecimals)) - costInDollarTerms; const pnlPercent = (pnlAmount / costInDollarTerms) * 100; console.log(isCall,inTheMoney,numContracts,apiPosition.collateralDecimals,pnlAmount,cost,costInDollarTerms); if (pnlAmount > 0) {pnlText = `+$${pnlAmount.toFixed(6)}(${pnlPercent.toFixed(1)}%)`; pnlClass = 'text-success'}else {pnlText = `-$${Math.abs(pnlAmount).toFixed(6)}(${Math.abs(pnlPercent).toFixed(1)}%)`; pnlClass = 'text-danger'}}else {pnlText = `-$${cost.toFixed(2)}(100%)`; pnlClass = 'text-danger'}$('#position-modal-pnl').text(pnlText).removeClass('text-success text-danger').addClass(pnlClass); const expiryTimestampSeconds = Math.floor((position.expiryTime || Date.now()) / 1000); const isHistory = type === 'history'; const timeLeftElement = $('#position-modal-time-left'); const timeLeftContainer = timeLeftElement.closest('.detail-item'); if (isHistory) {timeLeftContainer.find('.detail-label').text('Expired:'); timeLeftElement .text(new Date(position.expiryTime || Date.now()).toLocaleString()) .removeAttr('data-countdown-expiry') .removeClass('countdown')}else {timeLeftContainer.find('.detail-label').text('Time Left:'); timeLeftElement.addClass('countdown'); if (expiredButNotSettled) {timeLeftElement.html('<span class="status-expired">Expired</span> - Ready to settle'); timeLeftElement.removeAttr('data-countdown-expiry'); $('#settle-option-btn').show().data('positionId',apiPosition.entryTxHash || position.id).data('positionType',type)}else {timeLeftElement.attr('data-countdown-expiry',expiryTimestampSeconds); $('#settle-option-btn').hide()}}updateSettlementScenarios(position); updateSettlementInfo(position); const positionDetailModal = new bootstrap.Modal(document.getElementById('position-detail-modal')); positionDetailModal.show()}catch (error) {console.error("Error showing position details:",error); showNotification("There was an error displaying position details. Please try again.","error")}}function updateSettlementInfo(position) {const strikePrice = position.strikePrice || 0; const asset = position.asset || 'Unknown'; const isCall = position.optionType === 'CALL'; const expiryTime = new Date(position.expiryTime || Date.now()); const expiryFormatted = `${UTC_EXPIRY_HOUR}:00 UTC`; const formattedStrike = formatNumber(strikePrice); let aboveStrikeText,belowStrikeText; if (isCall) {aboveStrikeText = `If above $${formattedStrike}: Automatically settled to your wallet`; belowStrikeText = `If at/below $${formattedStrike}: Option expires worthless`}else {aboveStrikeText = `If above $${formattedStrike}: Option expires worthless`; belowStrikeText = `If at/below $${formattedStrike}: Automatically settled to your wallet`}$('.settlement-info').html(` <h6>Settlement Information:</h6> <ul> <li>Settlement Price: Chainlink Oracle for ${asset}at ${expiryFormatted},30 minute TWAP </li> <li>${aboveStrikeText}</li> <li>${belowStrikeText}</li> </ul> `)}function updateSettlementScenarios(position) {try {const scenarios = optionCalculator.calculateSettleentScenarios(position); $('#position-scenario-loss').text(scenarios.loss.description); $('#position-scenario-breakeven').text(scenarios.breakeven.description); $('#position-scenario-profit1').text(scenarios.profit1.description); $('#position-scenario-profit2').text(scenarios.profit2.description)}catch (error) {console.error("Error updating settlement scenarios:",error); $('#position-scenario-loss').text("Below strike: Option expires worthless"); $('#position-scenario-breakeven').text("At breakeven: Recover cost"); $('#position-scenario-profit1').text("Above strike: Profit increases"); $('#position-scenario-profit2').text("Further increase: Higher profit")}}async function loadTradeHistory() {try {const userAddress = state.connectedAddress.toLowerCase() if (!userAddress) {document.getElementById('no-history-message').style.display = 'block'; document.querySelector('.history-table-container table').style.display = 'none'; return}document.getElementById('history-table-body').innerHTML = '<tr><td colspan="9" class="text-center">Loading history...</td></tr>'; const response = await fetch(`https: if (!response.ok) {throw new Error('Failed to fetch history data')}const history = await response.json(); if (!history || history.length === 0) {document.getElementById('no-history-message').style.display = 'block'; document.querySelector('.history-table-container table').style.display = 'none'; return}document.getElementById('no-history-message').style.display = 'none'; document.querySelector('.history-table-container table').style.display = 'table'; const assetFilter = document.getElementById('history-asset').value; const typeFilter = document.getElementById('history-type').value; const statusFilter = document.getElementById('history-status').value; const dateRangeFilter = document.getElementById('history-date-range').value; let filteredHistory = history; if (assetFilter !== 'all') {filteredHistory = filteredHistory.filter(item => item.underlyingAsset === assetFilter)}if (typeFilter !== 'all') {filteredHistory = filteredHistory.filter(item => getOptionTypeDisplay(item.optionType).includes(typeFilter))}if (statusFilter !== 'all') {filteredHistory = filteredHistory.filter(item => item.status === statusFilter)}if (dateRangeFilter !== 'all') {const now = Math.floor(Date.now() / 1000); let cutoffTime = now; if (dateRangeFilter === 'week') {cutoffTime = now - (7 * 24 * 60 * 60)}else if (dateRangeFilter === 'month') {cutoffTime = now - (30 * 24 * 60 * 60)}filteredHistory = filteredHistory.filter(item => item.entryTimestamp >= cutoffTime)}filteredHistory.sort((a,b) => b.entryTimestamp - a.entryTimestamp); renderHistoryTable(filteredHistory)}catch (error) {console.error('Error loading trade history:',error); document.getElementById('history-table-body').innerHTML = '<tr><td colspan="9" class="text-center text-danger">Error loading history. Please try again later.</td></tr>'}}function convertPnLToUSD(pnlValue,collateralSymbol) {if (!pnlValue || isNaN(pnlValue)) return 0; switch (collateralSymbol) {case 'USDC': return pnlValue; case 'WETH': return pnlValue * (state.market_prices['ETH'] || 0); case 'CBBTC': return pnlValue * (state.market_prices['BTC'] || 0); default: return 0}}function formatUSDTooltip(usdValue) {if (usdValue === 0) return 'N/A'; const prefix = usdValue >= 0 ? '+' : ''; return `${prefix}$${Math.abs(usdValue).toFixed(2)}USD`}function renderHistoryTable(history) {const tableBody = document.getElementById('history-table-body'); tableBody.innerHTML = ''; const userAddress = state.connectedAddress.toLowerCase(); history.forEach(trade => {const row = document.createElement('tr'); let pnl = 0; let pnlPercentage = 0; if (trade.status === 'settled') {if (trade.buyer.toLowerCase() === userAddress) {pnl = trade.settlement?.payoutBuyer ? parseFloat(formatUnits(trade.settlement.payoutBuyer,trade.collateralDecimals)) - parseFloat(formatUnits(trade.entryPremium,trade.collateralDecimals)) : -parseFloat(formatUnits(trade.entryPremium,trade.collateralDecimals))}else if (trade.seller.toLowerCase() === userAddress) {pnl = trade.settlement?.collateralReturnedSeller ? parseFloat(formatUnits(trade.settlement.collateralReturnedSeller,trade.collateralDecimals)) - parseFloat(formatUnits(trade.collateralAmount,trade.collateralDecimals)) + parseFloat(formatUnits(trade.entryPremium,trade.collateralDecimals)) : parseFloat(formatUnits(trade.entryPremium,trade.collateralDecimals)) - parseFloat(formatUnits(trade.collateralAmount,trade.collateralDecimals))}const initialInvestment = trade.buyer.toLowerCase() === userAddress ? parseFloat(formatUnits(trade.entryPremium,trade.collateralDecimals)) : parseFloat(formatUnits(trade.collateralAmount,trade.collateralDecimals)) - parseFloat(formatUnits(trade.entryPremium,trade.collateralDecimals)); pnlPercentage = (pnl / initialInvestment) * 100}const tradeDate = new Date(trade.entryTimestamp * 1000); const dateString = tradeDate.toLocaleDateString() + ' ' + tradeDate.toLocaleTimeString([],{hour: '2-digit',minute:'2-digit'}); const settlementPrice = trade.settlement?.settlementPrice ? `$${formatNumberWithPrecision(formatUnits(trade.settlement.settlementPrice,8),2)}` : '-'; const userRole = trade.buyer.toLowerCase() === userAddress ? 'buyer' : 'seller'; const optionType = getOptionTypeDisplayFromRaw(trade.optionType); const contractAmount = trade.numContracts && trade.collateralDecimals ? parseFloat(formatUnits(trade.numContracts,trade.collateralDecimals)) : formatNumber(formatUnits(trade.numContracts,0)); const precision = trade.collateralSymbol === 'CBBTC' ? 8 : 4; const premiumValue = formatNumberWithPrecision(formatUnits(trade.entryPremium,trade.collateralDecimals),precision); const premiumFormatted = `${premiumValue}${trade.collateralSymbol}`; const pnlClass = pnl >= 0 ? 'text-success' : 'text-danger'; const pnlFormatted = `${pnl >= 0 ? '+' : '-'}${formatNumberWithPrecision(Math.abs(pnl),precision)}${trade.collateralSymbol}(${pnl >= 0 ? '+' : ''}${pnlPercentage.toFixed(2)}%)`; const pnlUSD = convertPnLToUSD(pnl,trade.collateralSymbol); const usdTooltip = formatUSDTooltip(pnlUSD); row.innerHTML = ` <td>${dateString}</td> <td>${trade.underlyingAsset}</td> <td>${optionType}(${userRole})</td> <td>$${formatNumber(formatUnits(trade.strikes[0],8))}</td> <td>${contractAmount}</td> <td>${premiumFormatted}</td> <td>${settlementPrice}</td> <td class="${pnlClass}" title="${usdTooltip}" style="cursor: help;">${pnlFormatted}</td> <td><span class="status-badge status-${trade.status}">${trade.status.charAt(0).toUpperCase() + trade.status.slice(1)}</span></td> `; tableBody.appendChild(row)})}function formatNumberWithPrecision(value,decimals = 4) {return parseFloat(value).toLocaleString('en-US',{minimumFractionDigits: 2,maximumFractionDigits: decimals })}function getOptionTypeDisplayFromRaw(optionType) {if (optionType === 0 || optionType === '0' || optionType === '0x0') {return 'CALL'}else if (optionType === 257 || optionType === '257' || optionType === '0x101') {return 'PUT'}else if (typeof optionType === 'string') {return getOptionTypeDisplay(optionType)}else {return `UNKNOWN (${optionType})`}}function setupHistoryFilters() {const filterElements = [ 'history-asset','history-type','history-status','history-date-range' ]; filterElements.forEach(id => {document.getElementById(id).addEventListener('change',loadTradeHistory)}); const goToTradeFromHistory = document.getElementById('go-to-trade-from-history'); if (goToTradeFromHistory) {goToTradeFromHistory.addEventListener('click',function(e) {e.preventDefault(); showSection('trade'); document.getElementById('nav-trade-bottom').classList.add('active'); document.getElementById('nav-history-bottom').classList.remove('active')})}}function getOptionTypeDisplay(optionType) {switch(optionType) {case 'CALL': return 'CALL'; case 'PUT': return 'PUT'; case 'INVERSE_CALL': return 'INVERSE CALL'; case 'INVERSE_PUT': return 'INVERSE PUT'; default: return optionType}}function shortenAddress(address) {return address.slice(0,6) + '...' + address.slice(-4)}function formatUnits(value,decimals) {return ethers.utils.formatUnits(value.toString(),decimals)}function formatNumber(value) {return parseFloat(value).toLocaleString('en-US',{minimumFractionDigits: 2,maximumFractionDigits: 2 })}function formatTimeDisplay(seconds) {seconds = parseInt(seconds); const hours = Math.floor(seconds / 3600); const minutes = Math.floor((seconds % 3600) / 60); const secs = seconds % 60; return `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`}function getExpiryFromAPI(orders) {if (!orders || orders.length === 0) return null; const expiryTimestamp = orders[0].order.expiry; return expiryTimestamp ? parseInt(expiryTimestamp) * 1000 : null}function updateUI(elementSelector,value,formatFn = null) {const formattedValue = formatFn ? formatFn(value) : value; $(elementSelector).text(formattedValue)}function updateDualUI(baseId,value,method = 'text',formatFn = null) {const formattedValue = formatFn ? formatFn(value) : value; const selector = `#${baseId},#adv-${baseId}`; switch (method) {case 'val': $(selector).val(formattedValue); break; case 'html': $(selector).html(formattedValue); break; case 'text': default: $(selector).text(formattedValue); break}}async function updateLiquidityInfo() {try {if (!state.connectedAddress) {console.log("Not connected,can't fetch liquidity information"); return}const tokens = Object.entries(CONFIG.collateralMap) .filter(([symbol,address]) => symbol !== 'ETH') .map(([symbol,address]) => {const details = CONFIG.getCollateralDetails(address); return {symbol,address,decimals: details.decimals,element: `#${symbol.toLowerCase()}-liquidity` }}); if (state.userOptionBookAllowances) {tokens.forEach(tokenInfo => {const cachedAllowance = state.userOptionBookAllowances[tokenInfo.symbol]; if (cachedAllowance && cachedAllowance !== '--') {$(tokenInfo.element).text(cachedAllowance)}}); const selectedAsset = getSelectedPaymentAsset(); if (selectedAsset && selectedAsset !== 'ETH' && state.userOptionBookAllowances[selectedAsset]) {const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (allowanceDisplay) {allowanceDisplay.textContent = state.userOptionBookAllowances[selectedAsset]}}}tokens.forEach(tokenInfo => {if (!state.userOptionBookAllowances || !state.userOptionBookAllowances[tokenInfo.symbol]) {$(tokenInfo.element).text('Loading...')}}); const selectedAsset = getSelectedPaymentAsset(); if (selectedAsset && selectedAsset !== 'ETH' && (!state.userOptionBookAllowances || !state.userOptionBookAllowances[selectedAsset])) {const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (allowanceDisplay) {allowanceDisplay.textContent = 'Loading...'}}setTimeout(async () => {try {const optionBookCalls = tokens.map(tokenInfo => ({address: tokenInfo.address,abi: ERC20ABI,functionName: 'allowance',args: [MAKER_ADDRESS,OPTION_BOOK_ADDRESS] })); const userOptionBookCalls = tokens.map(tokenInfo => ({address: tokenInfo.address,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,OPTION_BOOK_ADDRESS] })); const kyberCalls = tokens.map(tokenInfo => ({address: tokenInfo.address,abi: ERC20ABI,functionName: 'allowance',args: [state.connectedAddress,CONFIG.KYBER_CONTRACT_ADDRESS] })); const allCalls = [...optionBookCalls,...userOptionBookCalls,...kyberCalls]; try {const {readContracts }= WagmiCore; console.log('Executing multicall with',allCalls.length,'contracts'); console.log('Using multicall address:',MULTICALL_ADDRESS); console.log('All calls:',allCalls); const approvalAmounts = await readContracts({contracts: allCalls,multicallAddress: MULTICALL_ADDRESS,chainId: 8453 }); console.log('Multicall execution completed. Results type:',typeof approvalAmounts); console.log('Is using real Wagmi multicall:',!!window.__WAGMI_READ_CONTRACTS__); approvalAmounts.forEach((approvalAmountResult,index) => {if (index < tokens.length) {const tokenInfo = tokens[index]; const approvalAmount = approvalAmountResult.result; try {const formattedAmount = ethers.utils.formatUnits(approvalAmount,tokenInfo.decimals); $(tokenInfo.element).text(formattedAmount)}catch (error) {console.error(`Error processing approval for ${tokenInfo.symbol}:`,error); $(tokenInfo.element).text('--')}}else if (index < tokens.length * 2) {const tokenInfo = tokens[index - tokens.length]; const userApprovalAmount = approvalAmountResult.result; try {const formattedAmount = ethers.utils.formatUnits(userApprovalAmount,tokenInfo.decimals); if (!state.userOptionBookAllowances) {state.userOptionBookAllowances = {}}state.userOptionBookAllowances[tokenInfo.symbol] = formattedAmount; const selectedAsset = getSelectedPaymentAsset(); if (selectedAsset === tokenInfo.symbol) {const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (allowanceDisplay) {allowanceDisplay.textContent = formattedAmount}}}catch (error) {console.error(`Error processing user OptionBook approval for ${tokenInfo.symbol}:`,error); if (!state.userOptionBookAllowances) {state.userOptionBookAllowances = {}}state.userOptionBookAllowances[tokenInfo.symbol] = '--'}}else {const tokenInfo = tokens[index - tokens.length * 2]; const kyberApprovalAmount = approvalAmountResult.result; try {if (!kyberApprovalAmount || kyberApprovalAmount.toString() === '0') {const formattedAmount = '0'; if (!state.userKyberAllowances) {state.userKyberAllowances = {}}state.userKyberAllowances[tokenInfo.symbol] = formattedAmount; const kyberElement = `#${tokenInfo.symbol.toLowerCase()}-kyber-liquidity`; if ($(kyberElement).length === 0) {const optionBookElement = $(tokenInfo.element); const kyberDisplay = optionBookElement.clone(); kyberDisplay.attr('id',tokenInfo.symbol.toLowerCase() + '-kyber-liquidity'); kyberDisplay.text(formattedAmount); optionBookElement.after(kyberDisplay)}else {$(kyberElement).text(formattedAmount)}return}const formattedAmount = ethers.utils.formatUnits(kyberApprovalAmount,tokenInfo.decimals); if (!state.userKyberAllowances) {state.userKyberAllowances = {}}state.userKyberAllowances[tokenInfo.symbol] = formattedAmount; const kyberElement = `#${tokenInfo.symbol.toLowerCase()}-kyber-liquidity`; if ($(kyberElement).length === 0) {const optionBookElement = $(tokenInfo.element); const kyberDisplay = optionBookElement.clone(); kyberDisplay.attr('id',tokenInfo.symbol.toLowerCase() + '-kyber-liquidity'); kyberDisplay.text(formattedAmount); optionBookElement.after(kyberDisplay)}else {$(kyberElement).text(formattedAmount)}}catch (error) {console.error(`Error processing Kyber approval for ${tokenInfo.symbol}:`,error); const kyberElement = `#${tokenInfo.symbol.toLowerCase()}-kyber-liquidity`; if ($(kyberElement).length > 0) {$(kyberElement).text('--')}}}})}catch (error) {console.error('Error in multicall:',error); tokens.forEach(tokenInfo => {$(tokenInfo.element).text('--'); const kyberElement = `#${tokenInfo.symbol.toLowerCase()}-kyber-liquidity`; if ($(kyberElement).length > 0) {$(kyberElement).text('--')}}); const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (allowanceDisplay) {allowanceDisplay.textContent = 'Failed'}}}catch (error) {console.error('Error in background liquidity update:',error); tokens.forEach(tokenInfo => {$(tokenInfo.element).text('Failed')}); const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (allowanceDisplay) {allowanceDisplay.textContent = 'Failed'}}},150)}catch (error) {console.error('Error updating liquidity information:',error)}}function updateLiquidityRenewalCountdown() {const now = new Date(); const renewalDate = new Date(Date.UTC( now.getUTCFullYear(),now.getUTCMonth(),now.getUTCDate(),9,0,0,0 )); if (now >= renewalDate) {renewalDate.setUTCDate(renewalDate.getUTCDate() + 1)}const renewalTimestampSeconds = Math.floor(renewalDate.getTime() / 1000); $('.renewal-info').siblings('.countdown').attr('data-countdown-expiry',renewalTimestampSeconds)}async function updateWalletBalance() {try {if (!state.connectedAddress) return; const erc20Tokens = ['USDC','CBBTC','WETH']; const nativeTokens = ['ETH']; const currentSelection = getSelectedPaymentAsset(); if (state.paymentAssetBalances) {erc20Tokens.forEach(token => {const cachedBalance = state.paymentAssetBalances[token]; if (cachedBalance && cachedBalance !== 'Loading...' && cachedBalance !== 'Error' && cachedBalance !== 'Failed') {updateBalanceDisplay(token,cachedBalance)}})}erc20Tokens.forEach(token => {if (!state.paymentAssetBalances || !state.paymentAssetBalances[token] || state.paymentAssetBalances[token] === 'Loading...' || state.paymentAssetBalances[token] === 'Error' || state.paymentAssetBalances[token] === 'Failed') {if (!state.paymentAssetBalances) {state.paymentAssetBalances = {}}state.paymentAssetBalances[token] = 'Loading...'; updateBalanceDisplay(token,'Loading...')}}); setTimeout(async () => {try {const {readContracts }= WagmiCore; const contracts = erc20Tokens.map(token => ({address: CONFIG.collateralMap[token],abi: ERC20ABI,functionName: 'balanceOf',args: [state.connectedAddress],chainId: 8453 })); const balances = await readContracts({contracts }); if (!state.paymentAssetBalances) {state.paymentAssetBalances = {}}erc20Tokens.forEach((token,i) => {try {const balance = formatUnits(balances[i].result,CONFIG.getCollateralDetails(CONFIG.collateralMap[token]).decimals); state.paymentAssetBalances[token] = balance; updateBalanceDisplay(token,balance); updateBalanceTooltip(token,balance)}catch (error) {console.error(`Error processing balance for ${token}:`,error); state.paymentAssetBalances[token] = 'Error'; updateBalanceDisplay(token,'Error')}}); updatePaymentAssetBalanceDisplay(currentSelection); if (typeof refreshFundStatus === 'function') {refreshFundStatus()}}catch (error) {console.error('Error updating payment asset balances:',error); erc20Tokens.forEach(token => {if (!state.paymentAssetBalances) {state.paymentAssetBalances = {}}state.paymentAssetBalances[token] = 'Failed'; updateBalanceDisplay(token,'Failed')})}},100); state.paymentAssetBalances = state.paymentAssetBalances || {}; state.paymentAssetBalances['ETH'] = '0'; updatePaymentAssetBalanceDisplay(currentSelection); if (typeof refreshFundStatus === 'function') {refreshFundStatus()}if (typeof updateETHBalance === 'function') {updateETHBalance()}}catch (error) {console.error('Error updating payment asset balances:',error)}}function updateBalanceDisplay(token,balance) {const button = document.querySelector(`input[name="payment-asset-selection"][value="${token}"]`); if (button) {const label = button.nextElementSibling; if (label) {if (balance === 'Loading...') {label.setAttribute('data-balance',`Loading...`); label.classList.add('loading')}else if (balance === 'Error' || balance === 'Failed') {label.setAttribute('data-balance',`Error loading balance`); label.classList.remove('loading'); label.classList.add('error')}else {label.classList.remove('loading','error'); let usdValue = ''; if (state.market_prices && state.market_prices[token]) {const price = state.market_prices[token]; const usdAmount = (parseFloat(balance) * price).toFixed(2); usdValue = ` ($${usdAmount})`}label.setAttribute('data-balance',`${balance}${token}${usdValue}`)}}}}function updateBalanceTooltip(token,balance) {const button = document.querySelector(`input[name="payment-asset-selection"][value="${token}"]`); if (button) {const label = button.nextElementSibling; if (label) {let usdValue = ''; if (state.market_prices && state.market_prices[token]) {const price = state.market_prices[token]; const usdAmount = (parseFloat(balance) * price).toFixed(2); usdValue = ` ($${usdAmount})`}label.setAttribute('data-balance',`${balance}${token}${usdValue}`)}}}window.getSelectedPaymentAsset = function() {const selectedButton = document.querySelector('input[name="payment-asset-selection"]:checked'); return selectedButton ? selectedButton.value : 'USDC'}window.updatePaymentAssetBalanceDisplay = function(selectedAsset) {const balanceDisplay = document.getElementById('payment-balance-display'); const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (!state.paymentAssetBalances || !selectedAsset) {balanceDisplay.innerHTML = '<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text no-balance">No balance data available</span></small>'; if (allowanceDisplay) allowanceDisplay.textContent = '--'; return}if (selectedAsset === 'ETH') {balanceDisplay.innerHTML = '<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text">Native ETH balance shown above</span></small>'; if (allowanceDisplay) allowanceDisplay.textContent = 'N/A (Native)'; return}const balance = state.paymentAssetBalances[selectedAsset]; if (!balance || balance === 'Loading...' || balance === 'Error' || balance === 'Failed') {if (balance === 'Loading...') {balanceDisplay.innerHTML = '<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text loading">Loading balance...</span></small>'}else if (balance === 'Error' || balance === 'Failed') {balanceDisplay.innerHTML = '<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text no-balance">Failed to load balance</span></small>'}else {balanceDisplay.innerHTML = '<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text loading">Loading balance...</span></small>'}if (allowanceDisplay) allowanceDisplay.textContent = '--'; return}if (parseFloat(balance) === 0) {balanceDisplay.innerHTML = `<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text no-balance">0.00 ${selectedAsset}</span></small>`}else {let usdValue = ''; if (state.market_prices && state.market_prices[selectedAsset]) {const price = state.market_prices[selectedAsset]; const usdAmount = (parseFloat(balance) * price).toFixed(2); usdValue = `($${usdAmount})`}balanceDisplay.innerHTML = ` <small class="text-muted"> <i class="bi bi-wallet2 me-1"></i> <span class="balance-amount">${balance}${selectedAsset}</span> <span class="balance-usd">${usdValue}</span> </small> `}if (allowanceDisplay) {if (state.userOptionBookAllowances && state.userOptionBookAllowances[selectedAsset]) {allowanceDisplay.textContent = state.userOptionBookAllowances[selectedAsset]}else {const liquidityElement = document.getElementById(`${selectedAsset.toLowerCase()}-liquidity`); if (liquidityElement && liquidityElement.textContent !== '--' && liquidityElement.textContent !== 'Loading...') {allowanceDisplay.textContent = liquidityElement.textContent}else {allowanceDisplay.textContent = 'Loading...'}}}const swapBtn = document.getElementById('swap-assets-btn'); if (swapBtn) {swapBtn.innerHTML = `<i class="bi bi-arrow-repeat me-1"></i>Get more ${selectedAsset}`}}window.updateAllowanceDisplay = function(selectedAsset) {const allowanceDisplay = document.getElementById('payment-allowance-amount'); if (!allowanceDisplay) return; if (selectedAsset === 'ETH') {allowanceDisplay.textContent = 'N/A (Native)'; return}if (state.userOptionBookAllowances && state.userOptionBookAllowances[selectedAsset]) {allowanceDisplay.textContent = state.userOptionBookAllowances[selectedAsset]}else {allowanceDisplay.textContent = 'Loading...'}}window.debugAllowances = function() {console.log('=== DEBUG ALLOWANCES ==='); console.log('state.userKyberAllowances:',state.userKyberAllowances); console.log('state.userOptionBookAllowances:',state.userOptionBookAllowances); if (state.userKyberAllowances) {Object.entries(state.userKyberAllowances).forEach(([symbol,amount]) => {console.log(`Kyber ${symbol}:`,amount,'Type:',typeof amount)})}['usdc','weth','cbbtc'].forEach(symbol => {const kyberElement = document.getElementById(`${symbol}-kyber-liquidity`); if (kyberElement) {console.log(`${symbol}Kyber element:`,kyberElement.textContent)}else {console.log(`${symbol}Kyber element: not found`)}}); console.log('========================')}; window.refreshAllowances = async function() {if (typeof updateLiquidityInfo === 'function') {try {await updateLiquidityInfo(); console.log('Allowances manually refreshed successfully'); showNotification('Allowances refreshed successfully','success')}catch (error) {console.error('Failed to manually refresh allowances:',error); showNotification('Failed to refresh allowances: ' + error.message,'error')}}else {showNotification('Allowance refresh function not available','error')}}; async function initialize() {setupEventListeners(); setExpiryTime(); updateLiquidityRenewalCountdown(); const balanceDisplay = document.getElementById('payment-balance-display'); if (balanceDisplay) {balanceDisplay.innerHTML = '<small class="text-muted"><i class="bi bi-wallet2 me-1"></i><span class="balance-text loading">Loading balances...</span></small>'}let walletReady = false; let attempts = 0; const maxAttempts = 10; while (!walletReady && attempts < maxAttempts) {if (window.Web3OnboardBridge && typeof window.Web3OnboardBridge.init === 'function') {walletReady = true; await new Promise(resolve => setTimeout(resolve,1500))}else {await new Promise(resolve => setTimeout(resolve,500)); attempts++}}await refreshData(true); setTimeout(() => {try {const selectedAsset = getSelectedPaymentAsset(); if (selectedAsset && typeof updateAllowanceDisplay === 'function') {updateAllowanceDisplay(selectedAsset)}}catch (error) {console.warn('Initial allowance display update failed:',error)}},100); setTimeout(async () => {try {if (state.connectedAddress) {console.log('Preloading balances and allowances in background...'); if (typeof updateWalletBalance === 'function') {updateWalletBalance()}if (typeof updateLiquidityInfo === 'function') {updateLiquidityInfo()}}}catch (error) {console.warn('Background preload failed:',error)}},2000); state.refreshTimer = setInterval(() => refreshData(false),REFRESH_INTERVAL); state.viewMode = 'advanced'; $('.options-table-container').show(); showSection('trade'); if (state.orders && state.orders.length > 0 && typeof populateOptionsTable === 'function') {populateOptionsTable()}if (typeof updateTradeButtonState === 'function') {updateTradeButtonState()}else {$('#trade-now-btn').prop('disabled',false).removeClass('btn-secondary').addClass('btn-primary').text('TRADE NOW')}$('#history-asset,#history-type,#history-status,#history-date-range').on('change',function() {loadTradeHistory()}); if (window.scoreboard && typeof window.scoreboard.init === 'function') {window.scoreboard.init(false)}const positionAssetDropdown = $('#positionAssetDropdown'); if (positionAssetDropdown.length > 0) {positionAssetDropdown.on('click','.dropdown-item',function(e) {e.preventDefault(); const asset = $(this).data('asset'); const positionsSelectedAsset = $('#positions-selected-asset'); if (positionsSelectedAsset.length > 0) {positionsSelectedAsset.text(asset)}refreshPositions()})}}$(document).ready(() => {initialize(); setTimeout(() => {if (typeof selectAsset === 'function') {selectAsset(null)}},100)}); document.addEventListener('DOMContentLoaded',function() {if (window.analyticsManager) {const selectedAsset = document.getElementById('selected-asset'); if (selectedAsset) {const currentAsset = selectedAsset.textContent.trim(); window.analyticsManager.currentAsset = currentAsset}const assetDropdownItems = document.querySelectorAll('[data-asset]'); assetDropdownItems.forEach(item => {item.addEventListener('click',() => {const asset = item.getAttribute('data-asset'); if (window.analyticsManager && asset !== window.analyticsManager.currentAsset) {setTimeout(() => {window.analyticsManager.currentAsset = asset; window.analyticsManager.refreshAnalytics()},200)}})})}}); class CustomChartManager {constructor() {this.chart = null; this.priceData = []; this.currentPrice = 2500; this.currentAsset = 'ETH'; this.lastHoveredPrice = null}async generateMockPriceData(asset) {let currentRealPrice = null; if (window.state && window.state.market_prices && window.state.market_prices[asset]) {currentRealPrice = window.state.market_prices[asset]}else {currentRealPrice = asset === 'BTC' ? 100000 : 2500; console.warn(`Using fallback ${asset}price: $${currentRealPrice}`)}const data = []; const now = new Date(); for (let i = 48; i >= 0; i--) {const timestamp = new Date(now.getTime() - i * 30 * 60 * 1000); const timeBasedVariation = (i / 48) * 0.02; const randomVariation = (Math.random() - 0.5) * 0.01; const totalVariation = timeBasedVariation + randomVariation; let price; if (i === 0) {price = currentRealPrice}else {price = currentRealPrice * (1 + totalVariation)}data.push({x: timestamp,y: price })}this.currentPrice = currentRealPrice; this.priceData = data; this.currentAsset = asset; this.startAutoRefresh(); return data}startAutoRefresh() {if (this.refreshTimer) {clearInterval(this.refreshTimer)}this.refreshTimer = setInterval(() => {this.refreshPriceData()},30000)}refreshPriceData() {if (!this.chart || !this.priceData) return; const now = new Date(); let newPrice = this.currentPrice; if (window.state && window.state.market_prices && window.state.market_prices[this.currentAsset]) {newPrice = window.state.market_prices[this.currentAsset]}this.priceData.forEach(point => {point.x = new Date(point.x.getTime() + 30000)}); const variation = (Math.random() - 0.5) * 0.001; const latestPrice = newPrice * (1 + variation); this.priceData.shift(); this.priceData.push({x: now,y: latestPrice }); this.currentPrice = latestPrice; if (this.chart) {this.chart.data.datasets[0].data = this.priceData.map((point,index) => ({x: index,y: point.y })); this.chart.update('none')}}initializeChart() {const ctx = document.getElementById('priceChart'); if (!ctx) {console.warn('Chart canvas not found'); return}if (this.chart) {this.chart.destroy()}const chartManager = this; this.chart = new Chart(ctx,{type: 'line',data: {datasets: [{label: 'Price',data: this.priceData.map((point,index) => ({x: index,y: point.y })),borderColor: '#00d4aa',backgroundColor: 'rgba(0,212,170,0.1)',borderWidth: 2,fill: true,tension: 0.1,pointRadius: 0,pointHoverRadius: 4,isLevel: false }] },options: {responsive: true,maintainAspectRatio: false,interaction: {intersect: false,mode: 'nearest',axis: 'xy' },onHover: (event,activeElements,chart) => {event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default'; if (activeElements.length > 0) {const activeElement = activeElements[0]; const dataset = chart.data.datasets[activeElement.datasetIndex]; if (dataset.isLevel) {const hoveredPrice = dataset.levelData.value; if (!chartManager.lastHoveredPrice || Math.abs(hoveredPrice - chartManager.lastHoveredPrice) > hoveredPrice * 0.001) {chartManager.lastHoveredPrice = hoveredPrice}const priceThreshold = hoveredPrice * 0.002; const clusteredLevels = []; const seenLevels = new Set(); chart.data.datasets.forEach((ds,index) => {if (ds.isLevel && ds.levelData) {const priceDiff = Math.abs(ds.levelData.value - hoveredPrice); const levelKey = `${ds.levelData.name}_${ds.levelData.value}`; if (priceDiff <= priceThreshold && !seenLevels.has(levelKey)) {seenLevels.add(levelKey); clusteredLevels.push({dataset: ds,index: index,levelData: ds.levelData })}}}); if (!chart._lastClusterSize || chart._lastClusterSize !== clusteredLevels.length || !chart._lastClusterPrice || Math.abs(chart._lastClusterPrice - hoveredPrice) > hoveredPrice * 0.001) {console.log(`Found ${clusteredLevels.length}unique levels around $${hoveredPrice.toLocaleString()}: ${clusteredLevels.map(l => l.levelData.name).join(',')}`); chart._lastClusterSize = clusteredLevels.length; chart._lastClusterPrice = hoveredPrice}chart.data.datasets.forEach((ds) => {if (ds.isLevel) {ds.borderWidth = ds.levelData.confidence > 0.8 ? 3 : 2; ds.borderColor = chartManager.getLevelColor(chartManager.getLevelType(ds.levelData.name))}}); clusteredLevels.forEach(({dataset}) => {dataset.borderWidth = 4; dataset.borderColor = chartManager.getBrightLevelColor(chartManager.getLevelType(dataset.levelData.name))}); chart._clusteredLevels = clusteredLevels.map(({levelData}) => levelData); chart.update('none')}}else {let needsUpdate = false; chart.data.datasets.forEach((ds) => {if (ds.isLevel) {const normalWidth = ds.levelData.confidence > 0.8 ? 3 : 2; if (ds.borderWidth !== normalWidth) {ds.borderWidth = normalWidth; ds.borderColor = chartManager.getLevelColor(chartManager.getLevelType(ds.levelData.name)); needsUpdate = true}}}); chart._clusteredLevels = null; chart._lastClusterSize = null; chart._lastClusterPrice = null; chartManager.lastHoveredPrice = null; if (needsUpdate) {chart.update('none')}}},plugins: {legend: {display: false },tooltip: {backgroundColor: 'rgba(0,0,0,0.9)',titleColor: '#ffffff',bodyColor: '#ffffff',borderColor: '#00d4aa',borderWidth: 1,callbacks: {title: function(context) {const activeElement = context[0]; const dataset = activeElement.dataset; const chart = activeElement.chart; if (dataset.isLevel) {if (chart._clusteredLevels && chart._clusteredLevels.length > 1) {const levelNames = chart._clusteredLevels.map(level => level.name); return `${levelNames.length}Levels at $${dataset.levelData.value.toLocaleString()}`}else {return dataset.levelData.name}}else {const index = activeElement.dataIndex; const timeAgo = Math.floor((48 - index) / 2); return timeAgo > 0 ? `${timeAgo}h ago` : 'Now'}},label: function(context) {const dataset = context.dataset; const chart = context.chart; if (dataset.isLevel) {if (chart._clusteredLevels && chart._clusteredLevels.length > 1) {const firstClusteredLevel = chart._clusteredLevels[0]; if (dataset.levelData.name === firstClusteredLevel.name) {const labels = []; const uniqueLevels = new Map(); chart._clusteredLevels.forEach(levelData => {const key = `${levelData.name}_${levelData.value}`; if (!uniqueLevels.has(key)) {uniqueLevels.set(key,levelData)}}); const sortedLevels = Array.from(uniqueLevels.values()) .sort((a,b) => b.confidence - a.confidence); sortedLevels.forEach((levelData,index) => {const levelType = chartManager.getLevelType(levelData.name); const typeSymbol = levelType === 'support' ? '' : levelType === 'resistance' ? '' : ''; labels.push(`${typeSymbol}${levelData.name}`); labels.push(` Price: $${levelData.value.toLocaleString()}`); labels.push(` Confidence: ${(levelData.confidence * 100).toFixed(0)}%`); labels.push(` Distance: ${levelData.distance_to_spot > 0 ? '+' : ''}${levelData.distance_to_spot?.toLocaleString() || 'N/A'}`); if (index < sortedLevels.length - 1) {labels.push('')}}); return labels}else {return []}}else {const levelData = dataset.levelData; return [ `Price: $${levelData.value.toLocaleString()}`,`Confidence: ${(levelData.confidence * 100).toFixed(0)}%`,`Distance: ${levelData.distance_to_spot > 0 ? '+' : ''}${levelData.distance_to_spot?.toLocaleString() || 'N/A'}` ]}}else {return `Price: $${context.parsed.y.toLocaleString()}`}},afterBody: function(context) {const activeElement = context[0]; const dataset = activeElement.dataset; if (!dataset.isLevel) {const chart = activeElement.chart; const levels = []; chart.data.datasets.forEach((ds,index) => {if (ds.isLevel && index > 0) {const levelData = ds.levelData; levels.push(`${levelData.name}: $${levelData.value.toLocaleString()}`)}}); return levels.length > 0 ? ['','All Key Levels:',...levels.slice(0,8)] : []}return []},afterLabel: function(context) {const dataset = context.dataset; const chart = context.chart; if (dataset.isLevel) {if (chart._clusteredLevels && chart._clusteredLevels.length > 1) {const firstClusteredLevel = chart._clusteredLevels[0]; if (dataset.levelData.name === firstClusteredLevel.name) {const levelTypes = chart._clusteredLevels.map(level => chartManager.getLevelType(level.name) ); const uniqueTypes = [...new Set(levelTypes)]; const typeDescriptions = {'support': 'Support zones where price may bounce up','resistance': 'Resistance zones where price may face selling pressure','gamma-wall': 'High options activity zones' }; const descriptions = uniqueTypes.map(type => typeDescriptions[type]).filter(Boolean); return ['',...descriptions]}else {return ''}}else {const levelType = chartManager.getLevelType(dataset.levelData.name); const descriptions = {'support': 'Support Level - Price may bounce up from here','resistance': 'Resistance Level - Price may face selling pressure','gamma-wall': 'Gamma Wall - High options activity zone' }; return descriptions[levelType] || 'Key market level'}}return ''}}}},scales: {x: {type: 'linear',position: 'bottom',grid: {color: 'rgba(255,255,255,0.1)' },ticks: {color: '#888',callback: function(value,index) {const hoursAgo = Math.floor((48 - index) / 2); return hoursAgo > 0 ? `-${hoursAgo}h` : 'Now'}}},y: {position: 'right',grid: {color: 'rgba(255,255,255,0.1)' },ticks: {color: '#888',callback: function(value) {return '$' + value.toLocaleString()}}}}}}); console.log('Chart initialized successfully')}addAnalyticsLevels(analyticsData,forceAsset = null) {if (!this.chart) {console.warn('Chart not initialized,cannot add levels'); return}if (!analyticsData || !analyticsData.key_levels) {console.warn('No analytics data or key_levels found'); return}const expectedAsset = forceAsset || this.currentAsset; console.log(`Adding levels for asset: ${expectedAsset},Chart asset: ${this.currentAsset}`); if (forceAsset && forceAsset !== this.currentAsset) {console.warn(`Asset mismatch: Expected ${forceAsset},Chart has ${this.currentAsset}. Skipping level update.`); return}console.log('Analytics data received:',analyticsData); console.log('Available levels:',analyticsData.key_levels.map(l => `${l.name}: $${l.value}`)); this.chart.data.datasets = this.chart.data.datasets.filter(ds => !ds.isLevel); const levelValues = analyticsData.key_levels.map(level => level.value); const currentPrices = this.priceData.map(d => d.y); const allValues = [...levelValues,...currentPrices]; const minValue = Math.min(...allValues); const maxValue = Math.max(...allValues); const valueRange = maxValue - minValue; const padding = valueRange * 0.05; const chartMin = minValue - padding; const chartMax = maxValue + padding; console.log(`Full range: $${minValue.toLocaleString()}- $${maxValue.toLocaleString()}`); console.log(`Chart range with padding: $${chartMin.toLocaleString()}- $${chartMax.toLocaleString()}`); this.chart.options.scales.y.min = chartMin; this.chart.options.scales.y.max = chartMax; const sortedLevels = [...analyticsData.key_levels] .sort((a,b) => b.confidence - a.confidence); console.log(`Adding all ${sortedLevels.length}levels to chart:`,sortedLevels.map(l => `${l.name}: $${l.value.toLocaleString()}`)); sortedLevels.forEach((level,index) => {const levelType = this.getLevelType(level.name); const color = this.getLevelColor(levelType); const alpha = Math.max(0.4,level.confidence); const lineData = this.priceData.map((point,idx) => ({x: idx,y: level.value })); this.chart.data.datasets.push({label: level.name,data: lineData,borderColor: color,backgroundColor: color,borderWidth: level.confidence > 0.8 ? 3 : 2,borderDash: this.getLevelDash(levelType),fill: false,tension: 0,pointRadius: 0,pointHoverRadius: 0,isLevel: true,levelData: level,order: index + 1 })}); console.log(`Chart now has ${this.chart.data.datasets.length}datasets (1 price + ${sortedLevels.length}levels)`); console.log(`Y-axis range set to: $${chartMin.toLocaleString()}- $${chartMax.toLocaleString()}`); this.chart.update('none')}clearLevels() {if (this.chart) {console.log('Clearing existing levels from chart'); this.chart.data.datasets = this.chart.data.datasets.filter(ds => !ds.isLevel); this.chart.update('none')}}getLevelType(levelName) {const levelTypes = {'Put Support': 'support','Put Support 0DTE': 'support','Put Support 1W': 'support','Put Support 1M': 'support','Put Flow Support': 'support','Call Resistance': 'resistance','Call Resistance 0DTE': 'resistance','Call Resistance 1W': 'resistance','Call Resistance 1M': 'resistance','Call Flow Resistance': 'resistance','Gamma Wall (Short Gamma)': 'gamma-wall','Gamma Wall (Long Gamma)': 'gamma-wall','HVL': 'gamma-wall','HVS': 'gamma-wall','Max Pain Flow': 'gamma-wall','VWAS': 'gamma-wall' }; return levelTypes[levelName] || 'gamma-wall'}getLevelColor(levelType) {const colors = {'support': '#00d4aa','resistance': '#ff4757','gamma-wall': '#ffa726' }; return colors[levelType] || '#ffa726'}getBrightLevelColor(levelType) {const brightColors = {'support': '#00ff88','resistance': '#ff6b6b','gamma-wall': '#ffb347' }; return brightColors[levelType] || '#ffb347'}getLevelDash(levelType) {const dashes = {'support': [5,5],'resistance': [5,5],'gamma-wall': [10,5] }; return dashes[levelType] || [5,5]}async updateChart(asset) {console.log(`Updating chart for ${asset}`); this.clearLevels(); await this.generateMockPriceData(asset); if (this.chart) {this.chart.data.datasets[0].data = this.priceData.map((point,index) => ({x: index,y: point.y })); this.chart.update(); console.log(`Chart updated for ${asset},levels cleared`)}}destroy() {if (this.chart) {this.chart.destroy(); this.chart = null}if (this.refreshTimer) {clearInterval(this.refreshTimer); this.refreshTimer = null}}}window.customChartManager = new CustomChartManager(); document.addEventListener('DOMContentLoaded',function() {console.log('App loaded,setting up custom chart integration...'); setTimeout(() => {if (window.analyticsManager && window.analyticsManager.constructor) {const originalUpdateAnalyticsUI = window.analyticsManager.updateAnalyticsUI; window.analyticsManager.initializeTradingViewChart = function() {console.log('Initializing Chart.js instead of TradingView...'); window.customChartManager.generateMockPriceData(this.currentAsset).then(() => {window.customChartManager.initializeChart(); if (this.analyticsData) {setTimeout(() => {window.customChartManager.addAnalyticsLevels(this.analyticsData,this.currentAsset)},100)}})}; window.analyticsManager.updateTradingViewChart = function() {console.log('Updating Chart.js with analytics levels...'); if (this.analyticsData && window.customChartManager && window.customChartManager.chart) {window.customChartManager.addAnalyticsLevels(this.analyticsData,this.currentAsset)}}; window.analyticsManager.destroyTradingViewChart = function() {console.log('Destroying Chart.js...'); window.customChartManager.destroy()}; window.analyticsManager.updateAnalyticsUI = function() {originalUpdateAnalyticsUI.call(this); if (window.customChartManager && window.customChartManager.chart && this.analyticsData) {setTimeout(() => {window.customChartManager.addAnalyticsLevels(this.analyticsData,this.currentAsset)},100)}if (this.shouldInitializeChartOnDataLoad) {console.log(' Initializing custom chart after data load (from saved state)...'); setTimeout(() => {if (window.customChartManager && !window.customChartManager.chart) {window.customChartManager.generateMockPriceData(this.currentAsset).then(() => {window.customChartManager.initializeChart(); if (this.analyticsData) {window.customChartManager.addAnalyticsLevels(this.analyticsData,this.currentAsset)}})}},200); this.shouldInitializeChartOnDataLoad = false}}; if (window.customChartManager) {const initialAsset = window.analyticsManager.currentAsset || 'ETH'; window.customChartManager.generateMockPriceData(initialAsset).then(() => {})}}else {console.warn('AnalyticsManager not found,TradingView overrides not applied')}},1000)}); let optionTypeFilter = 'all'; function initializeOptionTypeFilter() {console.log('Initializing option type filter...'); $('input[name="option-type-filter"]').on('change',function() {const selectedFilter = $(this).val(); handleOptionTypeFilterChange(selectedFilter)}); updateFilterDescription('all'); setupConvictionSliderStyleWatcher()}function setupConvictionSliderStyleWatcher() {const sliderContainer = document.querySelector('.conviction-slider-container'); if (!sliderContainer) return; const observer = new MutationObserver((mutations) => {let shouldReapplyStyles = false; mutations.forEach((mutation) => {if (mutation.type === 'childList') {const addedNodes = Array.from(mutation.addedNodes); if (addedNodes.some(node => node.classList && node.classList.contains('form-range'))) {shouldReapplyStyles = true}}if (mutation.type === 'attributes' && mutation.attributeName === 'class') {shouldReapplyStyles = true}}); if (shouldReapplyStyles) {console.log('Detected slider style changes,reapplying filter styles...'); setTimeout(() => {updateFilterDescription(optionTypeFilter)},50)}}); observer.observe(sliderContainer,{childList: true,subtree: true,attributes: true,attributeFilter: ['class','style'] }); setInterval(() => {const container = $('.conviction-slider-container'); if (optionTypeFilter !== 'all' && !container.hasClass(optionTypeFilter + '-mode')) {console.log('Periodic check: reapplying filter styles...'); updateFilterDescription(optionTypeFilter)}},2000)}function handleOptionTypeFilterChange(filterType) {console.log(`Option filter changed to: ${filterType}`); optionTypeFilter = filterType; updateFilterDescription(filterType); setupConvictionSliderWithFilter(); if (state.viewMode === 'advanced') {populateOptionsTableWithFilter()}if (window.analyticsManager) {window.analyticsManager.updateLevelOverlays()}selectOptionBasedOnConviction()}function updateFilterDescription(filterType) {const descriptions = {'all': 'Showing all options','puts': 'PUT options only','calls': 'CALL options only' }; $('#filter-description').text(descriptions[filterType]); const sliderContainer = $('.conviction-slider-container'); sliderContainer.removeClass('filter-mode puts-mode calls-mode'); if (filterType === 'puts') {sliderContainer.addClass('puts-mode')}else if (filterType === 'calls') {sliderContainer.addClass('calls-mode')}setTimeout(() => {const slider = $('#conviction-slider,#adv-conviction-slider'); if (slider.length) {slider.hide().show(0); console.log(`Classes on container: ${sliderContainer.attr('class')}`)}},50); $('.conviction-labels .bearish-label,.conviction-labels .bullish-label').show()}function getFilteredOrders() {if (!state.orders || state.orders.length === 0) return []; switch (optionTypeFilter) {case 'puts': return state.orders.filter(orderWrapper => !orderWrapper.order.isCall); case 'calls': return state.orders.filter(orderWrapper => orderWrapper.order.isCall); case 'all': default: return state.orders}}function setupConvictionSliderWithFilter() {const filteredOrders = getFilteredOrders(); if (!filteredOrders || filteredOrders.length === 0) {console.warn('No orders available for current filter'); updateDualUI('current-target','No options available'); return}const strikes = filteredOrders.map(orderWrapper => {return parseFloat(formatUnits(orderWrapper.order.strikes[0],PRICE_DECIMALS))}).sort((a,b) => a - b); const uniqueStrikes = [...new Set(strikes)]; if (uniqueStrikes.length === 0) return; state.sliderTicks = []; state.priceTicks = []; state.priceTicks = uniqueStrikes; const numStrikes = uniqueStrikes.length; for (let i = 0; i < numStrikes; i++) {const tickPosition = Math.round((i / (numStrikes - 1)) * 100); state.sliderTicks.push(tickPosition)}$('#conviction-datalist,#adv-conviction-datalist').empty(); state.sliderTicks.forEach(tick => {$('#conviction-datalist,#adv-conviction-datalist').append(`<option value="${tick}"></option>`)}); updateDualUI('low-price',`$${formatNumber(uniqueStrikes[0])}`); updateDualUI('high-price',`$${formatNumber(uniqueStrikes[uniqueStrikes.length - 1])}`); let initialSliderIndex = Math.floor(uniqueStrikes.length / 2); let initialSliderTickValue = state.sliderTicks[initialSliderIndex] || 50; if (lastSelectedStrike !== null) {let closestIndex = 0; let minDiff = Math.abs(uniqueStrikes[0] - lastSelectedStrike); for (let i = 1; i < uniqueStrikes.length; i++) {const diff = Math.abs(uniqueStrikes[i] - lastSelectedStrike); if (diff < minDiff) {minDiff = diff; closestIndex = i}}initialSliderIndex = closestIndex; initialSliderTickValue = state.sliderTicks[closestIndex]}updateDualUI('current-target',`$${formatNumber(uniqueStrikes[initialSliderIndex])}`); updateDualUI('conviction-slider',initialSliderTickValue,'val'); if (lastSelectedSliderPosition !== null) {let closestTick = state.sliderTicks[0]; let minDistance = Math.abs(lastSelectedSliderPosition - closestTick); for (let i = 1; i < state.sliderTicks.length; i++) {const distance = Math.abs(lastSelectedSliderPosition - state.sliderTicks[i]); if (distance < minDistance) {minDistance = distance; closestTick = state.sliderTicks[i]}}updateDualUI('conviction-slider',closestTick,'val')}}function populateOptionsTableWithFilter() {const tableBody = $('#options-table-body'); tableBody.empty(); const filteredOrders = getFilteredOrders(); if (filteredOrders.length === 0) {const filterName = optionTypeFilter.toUpperCase(); tableBody.append(` <tr> <td colspan="9" class="text-center text-muted"> No ${filterName === 'ALL' ? '' : filterName}options available for ${state.selectedAsset}</td> </tr> `); return}const sortedFilteredOrders = [...filteredOrders].sort((a,b) => {const expiryA = parseInt(a.order.expiry) || 0; const expiryB = parseInt(b.order.expiry) || 0; return expiryA - expiryB}); for (let i = 0; i < sortedFilteredOrders.length; i++) {const orderWrapper = sortedFilteredOrders[i]; const order = orderWrapper.order; const optionType = order.isCall ? "CALL" : "PUT"; const collateral = CONFIG.getCollateralDetails(order.collateral); const strike = formatUnits(order.strikes[0],PRICE_DECIMALS); const premium = parseFloat(formatUnits(order.price,PRICE_DECIMALS)); const payoutRatio = optionCalculator.calculateLeverage(premium,order,collateral); const breakeven = optionCalculator.calculateBreakeven(order.isCall,parseFloat(strike),premium).toFixed(2); const {theta,delta,iv }= orderWrapper.greeks; const originalIndex = state.orders.findIndex(originalOrderWrapper => originalOrderWrapper.order.strikes[0] === order.strikes[0] && originalOrderWrapper.order.isCall === order.isCall ); let expiryDisplay = 'N/A'; if (order.expiry) {try {const orderExpiryTimestamp = parseInt(order.expiry) * 1000; if (!isNaN(orderExpiryTimestamp) && orderExpiryTimestamp > 0) {const expiryDate = new Date(orderExpiryTimestamp); const expiryTimeString = expiryDate.toLocaleTimeString('en-US',{hour12: false,hour: '2-digit',minute: '2-digit',timeZone: 'UTC' }); const expiryDateString = expiryDate.toLocaleDateString('en-US',{month: 'short',day: 'numeric',timeZone: 'UTC' }); expiryDisplay = `${expiryDateString}${expiryTimeString}UTC`}}catch (error) {console.warn('Error formatting expiry date for order:',order,error); expiryDisplay = 'Invalid'}}const row = ` <tr class="option-row ${originalIndex === state.selectedOrderIndex ? 'selected' : ''}" data-index="${originalIndex}"> <td>$${formatNumber(strike)}</td> <td><span class="badge ${order.isCall ? 'bg-success' : 'bg-danger'}">${optionType}</span></td> <td title="Expires at ${expiryDisplay}">${expiryDisplay}</td> <td>$${formatNumber(premium)}</td> <td>${payoutRatio}x</td> <td>$${breakeven}</td> <td>${delta.toFixed(2)}</td> <td>${parseInt(iv*100)}%</td> <td><button class="btn btn-sm btn-outline-primary select-option-btn">Select</button></td> </tr> `; tableBody.append(row)}}async function selectOptionBasedOnConvictionWithFilter(updatePaymentAsset = false) {let sliderValue; if ($('#advanced-view-container').is(':visible')) {sliderValue = parseInt($('#adv-conviction-slider').val())}else {sliderValue = parseInt($('#conviction-slider').val())}const filteredOrders = getFilteredOrders(); if (!filteredOrders || filteredOrders.length === 0 || !state.sliderTicks || state.sliderTicks.length === 0) {console.warn('No filtered orders available for selection'); return}const tickIndex = state.sliderTicks.indexOf(sliderValue); if (tickIndex === -1) return; const targetPrice = state.priceTicks[tickIndex]; if (!targetPrice) return; const extractStrike = orderWrapper => parseFloat(formatUnits(orderWrapper.order.strikes[0],PRICE_DECIMALS)); const bestFilteredOrderIndex = findNearestOption(targetPrice,filteredOrders,extractStrike); if (bestFilteredOrderIndex !== null) {const selectedFilteredOrder = filteredOrders[bestFilteredOrderIndex]; const originalIndex = state.orders.findIndex(orderWrapper => orderWrapper.order.strikes[0] === selectedFilteredOrder.order.strikes[0] && orderWrapper.order.isCall === selectedFilteredOrder.order.isCall ); if (originalIndex !== -1) {await selectOption(originalIndex)}}setTimeout(updatePositionSizeWithContracts,200)}function integrateWithExistingCode() {const originalSetupConvictionSlider = window.setupConvictionSlider; const originalPopulateOptionsTable = window.populateOptionsTable; const originalSelectOptionBasedOnConviction = window.selectOptionBasedOnConviction; window.setupConvictionSlider = function() {const result = optionTypeFilter === 'all' ? originalSetupConvictionSlider.call(this) : setupConvictionSliderWithFilter(); setTimeout(() => {updateFilterDescription(optionTypeFilter)},100); return result}; window.populateOptionsTable = function() {if (optionTypeFilter === 'all') {return originalPopulateOptionsTable.call(this)}else {return populateOptionsTableWithFilter()}}; window.selectOptionBasedOnConviction = function(updatePaymentAsset = false) {const result = optionTypeFilter === 'all' ? originalSelectOptionBasedOnConviction.call(this,updatePaymentAsset) : selectOptionBasedOnConvictionWithFilter(updatePaymentAsset); setTimeout(() => {updateFilterDescription(optionTypeFilter)},50); return result}}function updatePositionSizeWithContracts() {const orderIndex = state.selectedOrderIndex; if (orderIndex === null || !state.orders || state.orders.length === 0) return; const order = state.orders[orderIndex].order; const collateral = CONFIG.getCollateralDetails(order.collateral); const percentage = state.selectedPositionPercentage || 50; const {positionCost,selectedContracts }= optionCalculator.calculatePositionDetails( order,collateral,percentage ); console.log('Slider calculation - percentage:',percentage,'positionCost:',positionCost,'selectedContracts:',selectedContracts); const optionType = order.isCall ? "CALL" : "PUT"; const formattedCost = positionCost.toFixed(collateral.decimals === 6 ? 2 : 4); const contractsFormatted = selectedContracts.toFixed(4); let usdValue = 0; if (typeof convertToDollarValue === 'function') {usdValue = convertToDollarValue(positionCost,collateral.asset)}else {switch (collateral.asset) {case 'USDC': usdValue = positionCost; break; case 'WETH': usdValue = positionCost * (state.market_prices?.['ETH'] || 2500); break; case 'CBBTC': usdValue = positionCost * (state.market_prices?.['BTC'] || 50000); break; default: usdValue = 0}}const formattedUsdValue = usdValue > 0 ? `$${usdValue.toLocaleString('en-US',{minimumFractionDigits: 2,maximumFractionDigits: 2 })}` : ''; const sizeDisplay = document.getElementById('current-size'); if (sizeDisplay) {let displayText = `${formattedCost}${collateral.asset}`; let combinedInfo = ''; if (formattedUsdValue && collateral.asset !== 'USDC') {combinedInfo = `${formattedUsdValue},${contractsFormatted}x ${optionType}`}else {combinedInfo = `${contractsFormatted}x ${optionType}`}displayText += ` <span class="combined-info">(${combinedInfo})</span>`; sizeDisplay.innerHTML = displayText}}function integratePositionSizeDisplay() {const originalUpdatePositionSize = window.updatePositionSize; const originalCalculateAndUpdatePositionCost = window.calculateAndUpdatePositionCost; if (originalUpdatePositionSize) {window.updatePositionSize = function() {originalUpdatePositionSize.call(this); updatePositionSizeWithContracts()}}if (originalCalculateAndUpdatePositionCost) {window.calculateAndUpdatePositionCost = function(order,collateral,percentage) {const result = originalCalculateAndUpdatePositionCost.call(this,order,collateral,percentage); updatePositionSizeWithContracts(); return result}}$(document).on('input','#position-size-slider,#adv-position-size-slider',function() {setTimeout(updatePositionSizeWithContracts,100)})}$(document).ready(function() {setTimeout(() => {initializeOptionTypeFilter(); integrateWithExistingCode(); integratePositionSizeDisplay(); console.log('Option type filter initialized successfully')},1000)}); window.optionTypeFilter = {getCurrentFilter: () => optionTypeFilter,setFilter: handleOptionTypeFilterChange,getFilteredOrders: getFilteredOrders,updatePositionSizeWithContracts: updatePositionSizeWithContracts }})();